// WARNING: THIS FILE IS AUTOGENERATED! As such, it should not be edited.
// Edits need to be made to the proto files
// (see https://github.com/mavlink/MAVSDK-Proto/blob/main/protos/camera/camera.proto)

#include "camera.h"

#include <mavsdk/plugins/camera/camera.h>
#include <algorithm>
#include <cstring>
#include <mutex>
#include <vector>

// ===== C++ to C Type Conversions =====

static mavsdk_camera_result_t
translate_result(mavsdk::Camera::Result cpp_result) {
    switch(cpp_result) {
        case mavsdk::Camera::Result::Unknown:
            return MAVSDK_CAMERA_RESULT_UNKNOWN;
        case mavsdk::Camera::Result::Success:
            return MAVSDK_CAMERA_RESULT_SUCCESS;
        case mavsdk::Camera::Result::InProgress:
            return MAVSDK_CAMERA_RESULT_IN_PROGRESS;
        case mavsdk::Camera::Result::Busy:
            return MAVSDK_CAMERA_RESULT_BUSY;
        case mavsdk::Camera::Result::Denied:
            return MAVSDK_CAMERA_RESULT_DENIED;
        case mavsdk::Camera::Result::Error:
            return MAVSDK_CAMERA_RESULT_ERROR;
        case mavsdk::Camera::Result::Timeout:
            return MAVSDK_CAMERA_RESULT_TIMEOUT;
        case mavsdk::Camera::Result::WrongArgument:
            return MAVSDK_CAMERA_RESULT_WRONG_ARGUMENT;
        case mavsdk::Camera::Result::NoSystem:
            return MAVSDK_CAMERA_RESULT_NO_SYSTEM;
        case mavsdk::Camera::Result::ProtocolUnsupported:
            return MAVSDK_CAMERA_RESULT_PROTOCOL_UNSUPPORTED;
        case mavsdk::Camera::Result::Unavailable:
            return MAVSDK_CAMERA_RESULT_UNAVAILABLE;
        case mavsdk::Camera::Result::CameraIdInvalid:
            return MAVSDK_CAMERA_RESULT_CAMERA_ID_INVALID;
        case mavsdk::Camera::Result::ActionUnsupported:
            return MAVSDK_CAMERA_RESULT_ACTION_UNSUPPORTED;
    }
}

static mavsdk::Camera::Mode
translate_mode_from_c(mavsdk_camera_mode_t c_enum) {
    switch(c_enum) {
        case MAVSDK_CAMERA_MODE_UNKNOWN:
            return mavsdk::Camera::Mode::Unknown;
        case MAVSDK_CAMERA_MODE_PHOTO:
            return mavsdk::Camera::Mode::Photo;
        case MAVSDK_CAMERA_MODE_VIDEO:
            return mavsdk::Camera::Mode::Video;
    }
    return mavsdk::Camera::Mode::Unknown;
}

static mavsdk_camera_mode_t
translate_mode_to_c(mavsdk::Camera::Mode cpp_enum) {
    switch(cpp_enum) {
        case mavsdk::Camera::Mode::Unknown:
            return MAVSDK_CAMERA_MODE_UNKNOWN;
        case mavsdk::Camera::Mode::Photo:
            return MAVSDK_CAMERA_MODE_PHOTO;
        case mavsdk::Camera::Mode::Video:
            return MAVSDK_CAMERA_MODE_VIDEO;
    }
    return MAVSDK_CAMERA_MODE_UNKNOWN;
}

static mavsdk::Camera::PhotosRange
translate_photos_range_from_c(mavsdk_camera_photos_range_t c_enum) {
    switch(c_enum) {
        case MAVSDK_CAMERA_PHOTOS_RANGE_ALL:
            return mavsdk::Camera::PhotosRange::All;
        case MAVSDK_CAMERA_PHOTOS_RANGE_SINCE_CONNECTION:
            return mavsdk::Camera::PhotosRange::SinceConnection;
    }
    return mavsdk::Camera::PhotosRange::All;
}

static mavsdk_camera_photos_range_t
translate_photos_range_to_c(mavsdk::Camera::PhotosRange cpp_enum) {
    switch(cpp_enum) {
        case mavsdk::Camera::PhotosRange::All:
            return MAVSDK_CAMERA_PHOTOS_RANGE_ALL;
        case mavsdk::Camera::PhotosRange::SinceConnection:
            return MAVSDK_CAMERA_PHOTOS_RANGE_SINCE_CONNECTION;
    }
    return MAVSDK_CAMERA_PHOTOS_RANGE_ALL;
}



static mavsdk::Camera::Option
translate_option_from_c(const mavsdk_camera_option_t& c_struct) {
    mavsdk::Camera::Option cpp_struct{};
    if (c_struct.option_id) {
        cpp_struct.option_id = c_struct.option_id;
    }
    if (c_struct.option_description) {
        cpp_struct.option_description = c_struct.option_description;
    }
    return cpp_struct;
}

static mavsdk_camera_option_t
translate_option_to_c(const mavsdk::Camera::Option& cpp_struct) {
    mavsdk_camera_option_t c_struct{};
    c_struct.option_id = strdup(cpp_struct.option_id.c_str());
    c_struct.option_description = strdup(cpp_struct.option_description.c_str());
    return c_struct;
}

void mavsdk_camera_option_destroy(
    mavsdk_camera_option_t* target) {
    if (!target) return;
    if (target->option_id) {
        free((void*)target->option_id);
        target->option_id = nullptr;
    }
    if (target->option_description) {
        free((void*)target->option_description);
        target->option_description = nullptr;
    }
}

void mavsdk_camera_option_array_destroy(
    mavsdk_camera_option_t** array,
    size_t size) {
    if (!array || !*array) return;

    for (size_t i = 0; i < size; i++) {
        mavsdk_camera_option_destroy(&(*array)[i]);
    }

    delete[] *array;
    *array = nullptr;
}


static mavsdk::Camera::Setting
translate_setting_from_c(const mavsdk_camera_setting_t& c_struct) {
    mavsdk::Camera::Setting cpp_struct{};
    if (c_struct.setting_id) {
        cpp_struct.setting_id = c_struct.setting_id;
    }
    if (c_struct.setting_description) {
        cpp_struct.setting_description = c_struct.setting_description;
    }
    cpp_struct.option = translate_option_from_c(c_struct.option);
    cpp_struct.is_range = c_struct.is_range;
    return cpp_struct;
}

static mavsdk_camera_setting_t
translate_setting_to_c(const mavsdk::Camera::Setting& cpp_struct) {
    mavsdk_camera_setting_t c_struct{};
    c_struct.setting_id = strdup(cpp_struct.setting_id.c_str());
    c_struct.setting_description = strdup(cpp_struct.setting_description.c_str());
    c_struct.option = translate_option_to_c(cpp_struct.option);
    c_struct.is_range = cpp_struct.is_range;
    return c_struct;
}

void mavsdk_camera_setting_destroy(
    mavsdk_camera_setting_t* target) {
    if (!target) return;
    if (target->setting_id) {
        free((void*)target->setting_id);
        target->setting_id = nullptr;
    }
    if (target->setting_description) {
        free((void*)target->setting_description);
        target->setting_description = nullptr;
    }
}

void mavsdk_camera_setting_array_destroy(
    mavsdk_camera_setting_t** array,
    size_t size) {
    if (!array || !*array) return;

    for (size_t i = 0; i < size; i++) {
        mavsdk_camera_setting_destroy(&(*array)[i]);
    }

    delete[] *array;
    *array = nullptr;
}


static mavsdk::Camera::SettingOptions
translate_setting_options_from_c(const mavsdk_camera_setting_options_t& c_struct) {
    mavsdk::Camera::SettingOptions cpp_struct{};
    cpp_struct.component_id = c_struct.component_id;
    if (c_struct.setting_id) {
        cpp_struct.setting_id = c_struct.setting_id;
    }
    if (c_struct.setting_description) {
        cpp_struct.setting_description = c_struct.setting_description;
    }
    cpp_struct.options.reserve(c_struct.options_size);
    for (size_t i = 0; i < c_struct.options_size; i++) {
        cpp_struct.options.push_back(
            translate_option_from_c(c_struct.options[i]));
    }
    cpp_struct.is_range = c_struct.is_range;
    return cpp_struct;
}

static mavsdk_camera_setting_options_t
translate_setting_options_to_c(const mavsdk::Camera::SettingOptions& cpp_struct) {
    mavsdk_camera_setting_options_t c_struct{};
    c_struct.component_id = cpp_struct.component_id;
    c_struct.setting_id = strdup(cpp_struct.setting_id.c_str());
    c_struct.setting_description = strdup(cpp_struct.setting_description.c_str());
    c_struct.options_size = cpp_struct.options.size();
    c_struct.options = new mavsdk_camera_option_t[c_struct.options_size];
    for (size_t i = 0; i < c_struct.options_size; i++) {
        c_struct.options[i] = translate_option_to_c(cpp_struct.options[i]);
    }
    c_struct.is_range = cpp_struct.is_range;
    return c_struct;
}

void mavsdk_camera_setting_options_destroy(
    mavsdk_camera_setting_options_t* target) {
    if (!target) return;
    if (target->setting_id) {
        free((void*)target->setting_id);
        target->setting_id = nullptr;
    }
    if (target->setting_description) {
        free((void*)target->setting_description);
        target->setting_description = nullptr;
    }
    if (target->options) {
        for (size_t i = 0; i < target->options_size; i++) {
            mavsdk_camera_option_destroy(&target->options[i]);
        }
        delete[] target->options;
        target->options = nullptr;
        target->options_size = 0;
    }
}

void mavsdk_camera_setting_options_array_destroy(
    mavsdk_camera_setting_options_t** array,
    size_t size) {
    if (!array || !*array) return;

    for (size_t i = 0; i < size; i++) {
        mavsdk_camera_setting_options_destroy(&(*array)[i]);
    }

    delete[] *array;
    *array = nullptr;
}


static mavsdk::Camera::VideoStreamSettings
translate_video_stream_settings_from_c(const mavsdk_camera_video_stream_settings_t& c_struct) {
    mavsdk::Camera::VideoStreamSettings cpp_struct{};
    cpp_struct.frame_rate_hz = c_struct.frame_rate_hz;
    cpp_struct.horizontal_resolution_pix = c_struct.horizontal_resolution_pix;
    cpp_struct.vertical_resolution_pix = c_struct.vertical_resolution_pix;
    cpp_struct.bit_rate_b_s = c_struct.bit_rate_b_s;
    cpp_struct.rotation_deg = c_struct.rotation_deg;
    if (c_struct.uri) {
        cpp_struct.uri = c_struct.uri;
    }
    cpp_struct.horizontal_fov_deg = c_struct.horizontal_fov_deg;
    return cpp_struct;
}

static mavsdk_camera_video_stream_settings_t
translate_video_stream_settings_to_c(const mavsdk::Camera::VideoStreamSettings& cpp_struct) {
    mavsdk_camera_video_stream_settings_t c_struct{};
    c_struct.frame_rate_hz = cpp_struct.frame_rate_hz;
    c_struct.horizontal_resolution_pix = cpp_struct.horizontal_resolution_pix;
    c_struct.vertical_resolution_pix = cpp_struct.vertical_resolution_pix;
    c_struct.bit_rate_b_s = cpp_struct.bit_rate_b_s;
    c_struct.rotation_deg = cpp_struct.rotation_deg;
    c_struct.uri = strdup(cpp_struct.uri.c_str());
    c_struct.horizontal_fov_deg = cpp_struct.horizontal_fov_deg;
    return c_struct;
}

void mavsdk_camera_video_stream_settings_destroy(
    mavsdk_camera_video_stream_settings_t* target) {
    if (!target) return;
    if (target->uri) {
        free((void*)target->uri);
        target->uri = nullptr;
    }
}

void mavsdk_camera_video_stream_settings_array_destroy(
    mavsdk_camera_video_stream_settings_t** array,
    size_t size) {
    if (!array || !*array) return;

    for (size_t i = 0; i < size; i++) {
        mavsdk_camera_video_stream_settings_destroy(&(*array)[i]);
    }

    delete[] *array;
    *array = nullptr;
}


static mavsdk::Camera::VideoStreamInfo::VideoStreamStatus
translate_video_stream_info_video_stream_status_from_c(mavsdk_camera_video_stream_info_video_stream_status_t c_enum) {
    switch(c_enum) {
        case MAVSDK_CAMERA_VIDEO_STREAM_INFO_VIDEO_STREAM_STATUS_NOT_RUNNING:
            return mavsdk::Camera::VideoStreamInfo::VideoStreamStatus::NotRunning;
        case MAVSDK_CAMERA_VIDEO_STREAM_INFO_VIDEO_STREAM_STATUS_IN_PROGRESS:
            return mavsdk::Camera::VideoStreamInfo::VideoStreamStatus::InProgress;
    }
    return mavsdk::Camera::VideoStreamInfo::VideoStreamStatus::NotRunning;
}


static mavsdk::Camera::VideoStreamInfo::VideoStreamSpectrum
translate_video_stream_info_video_stream_spectrum_from_c(mavsdk_camera_video_stream_info_video_stream_spectrum_t c_enum) {
    switch(c_enum) {
        case MAVSDK_CAMERA_VIDEO_STREAM_INFO_VIDEO_STREAM_SPECTRUM_UNKNOWN:
            return mavsdk::Camera::VideoStreamInfo::VideoStreamSpectrum::Unknown;
        case MAVSDK_CAMERA_VIDEO_STREAM_INFO_VIDEO_STREAM_SPECTRUM_VISIBLE_LIGHT:
            return mavsdk::Camera::VideoStreamInfo::VideoStreamSpectrum::VisibleLight;
        case MAVSDK_CAMERA_VIDEO_STREAM_INFO_VIDEO_STREAM_SPECTRUM_INFRARED:
            return mavsdk::Camera::VideoStreamInfo::VideoStreamSpectrum::Infrared;
    }
    return mavsdk::Camera::VideoStreamInfo::VideoStreamSpectrum::Unknown;
}


static mavsdk::Camera::VideoStreamInfo
translate_video_stream_info_from_c(const mavsdk_camera_video_stream_info_t& c_struct) {
    mavsdk::Camera::VideoStreamInfo cpp_struct{};
    cpp_struct.stream_id = c_struct.stream_id;
    cpp_struct.settings = translate_video_stream_settings_from_c(c_struct.settings);
    cpp_struct.status = translate_video_stream_info_video_stream_status_from_c(c_struct.status);
    cpp_struct.spectrum = translate_video_stream_info_video_stream_spectrum_from_c(c_struct.spectrum);
    return cpp_struct;
}


static mavsdk_camera_video_stream_info_video_stream_status_t
translate_video_stream_info_video_stream_status_to_c(mavsdk::Camera::VideoStreamInfo::VideoStreamStatus cpp_enum) {
    switch(cpp_enum) {
        case mavsdk::Camera::VideoStreamInfo::VideoStreamStatus::NotRunning:
            return MAVSDK_CAMERA_VIDEO_STREAM_INFO_VIDEO_STREAM_STATUS_NOT_RUNNING;
        case mavsdk::Camera::VideoStreamInfo::VideoStreamStatus::InProgress:
            return MAVSDK_CAMERA_VIDEO_STREAM_INFO_VIDEO_STREAM_STATUS_IN_PROGRESS;
    }
    return MAVSDK_CAMERA_VIDEO_STREAM_INFO_VIDEO_STREAM_STATUS_NOT_RUNNING;
}


static mavsdk_camera_video_stream_info_video_stream_spectrum_t
translate_video_stream_info_video_stream_spectrum_to_c(mavsdk::Camera::VideoStreamInfo::VideoStreamSpectrum cpp_enum) {
    switch(cpp_enum) {
        case mavsdk::Camera::VideoStreamInfo::VideoStreamSpectrum::Unknown:
            return MAVSDK_CAMERA_VIDEO_STREAM_INFO_VIDEO_STREAM_SPECTRUM_UNKNOWN;
        case mavsdk::Camera::VideoStreamInfo::VideoStreamSpectrum::VisibleLight:
            return MAVSDK_CAMERA_VIDEO_STREAM_INFO_VIDEO_STREAM_SPECTRUM_VISIBLE_LIGHT;
        case mavsdk::Camera::VideoStreamInfo::VideoStreamSpectrum::Infrared:
            return MAVSDK_CAMERA_VIDEO_STREAM_INFO_VIDEO_STREAM_SPECTRUM_INFRARED;
    }
    return MAVSDK_CAMERA_VIDEO_STREAM_INFO_VIDEO_STREAM_SPECTRUM_UNKNOWN;
}

static mavsdk_camera_video_stream_info_t
translate_video_stream_info_to_c(const mavsdk::Camera::VideoStreamInfo& cpp_struct) {
    mavsdk_camera_video_stream_info_t c_struct{};
    c_struct.stream_id = cpp_struct.stream_id;
    c_struct.settings = translate_video_stream_settings_to_c(cpp_struct.settings);
    c_struct.status = translate_video_stream_info_video_stream_status_to_c(cpp_struct.status);
    c_struct.spectrum = translate_video_stream_info_video_stream_spectrum_to_c(cpp_struct.spectrum);
    return c_struct;
}

void mavsdk_camera_video_stream_info_destroy(
    mavsdk_camera_video_stream_info_t* target) {
    if (!target) return;
}

void mavsdk_camera_video_stream_info_array_destroy(
    mavsdk_camera_video_stream_info_t** array,
    size_t size) {
    if (!array || !*array) return;

    for (size_t i = 0; i < size; i++) {
        mavsdk_camera_video_stream_info_destroy(&(*array)[i]);
    }

    delete[] *array;
    *array = nullptr;
}


static mavsdk::Camera::ModeUpdate
translate_mode_update_from_c(const mavsdk_camera_mode_update_t& c_struct) {
    mavsdk::Camera::ModeUpdate cpp_struct{};
    cpp_struct.component_id = c_struct.component_id;
    cpp_struct.mode = translate_mode_from_c(c_struct.mode);
    return cpp_struct;
}

static mavsdk_camera_mode_update_t
translate_mode_update_to_c(const mavsdk::Camera::ModeUpdate& cpp_struct) {
    mavsdk_camera_mode_update_t c_struct{};
    c_struct.component_id = cpp_struct.component_id;
    c_struct.mode = translate_mode_to_c(cpp_struct.mode);
    return c_struct;
}

void mavsdk_camera_mode_update_destroy(
    mavsdk_camera_mode_update_t* target) {
    if (!target) return;
}

void mavsdk_camera_mode_update_array_destroy(
    mavsdk_camera_mode_update_t** array,
    size_t size) {
    if (!array || !*array) return;

    for (size_t i = 0; i < size; i++) {
        mavsdk_camera_mode_update_destroy(&(*array)[i]);
    }

    delete[] *array;
    *array = nullptr;
}


static mavsdk::Camera::VideoStreamUpdate
translate_video_stream_update_from_c(const mavsdk_camera_video_stream_update_t& c_struct) {
    mavsdk::Camera::VideoStreamUpdate cpp_struct{};
    cpp_struct.component_id = c_struct.component_id;
    cpp_struct.video_stream_info = translate_video_stream_info_from_c(c_struct.video_stream_info);
    return cpp_struct;
}

static mavsdk_camera_video_stream_update_t
translate_video_stream_update_to_c(const mavsdk::Camera::VideoStreamUpdate& cpp_struct) {
    mavsdk_camera_video_stream_update_t c_struct{};
    c_struct.component_id = cpp_struct.component_id;
    c_struct.video_stream_info = translate_video_stream_info_to_c(cpp_struct.video_stream_info);
    return c_struct;
}

void mavsdk_camera_video_stream_update_destroy(
    mavsdk_camera_video_stream_update_t* target) {
    if (!target) return;
}

void mavsdk_camera_video_stream_update_array_destroy(
    mavsdk_camera_video_stream_update_t** array,
    size_t size) {
    if (!array || !*array) return;

    for (size_t i = 0; i < size; i++) {
        mavsdk_camera_video_stream_update_destroy(&(*array)[i]);
    }

    delete[] *array;
    *array = nullptr;
}


static mavsdk::Camera::Storage::StorageStatus
translate_storage_storage_status_from_c(mavsdk_camera_storage_storage_status_t c_enum) {
    switch(c_enum) {
        case MAVSDK_CAMERA_STORAGE_STORAGE_STATUS_NOT_AVAILABLE:
            return mavsdk::Camera::Storage::StorageStatus::NotAvailable;
        case MAVSDK_CAMERA_STORAGE_STORAGE_STATUS_UNFORMATTED:
            return mavsdk::Camera::Storage::StorageStatus::Unformatted;
        case MAVSDK_CAMERA_STORAGE_STORAGE_STATUS_FORMATTED:
            return mavsdk::Camera::Storage::StorageStatus::Formatted;
        case MAVSDK_CAMERA_STORAGE_STORAGE_STATUS_NOT_SUPPORTED:
            return mavsdk::Camera::Storage::StorageStatus::NotSupported;
    }
    return mavsdk::Camera::Storage::StorageStatus::NotAvailable;
}


static mavsdk::Camera::Storage::StorageType
translate_storage_storage_type_from_c(mavsdk_camera_storage_storage_type_t c_enum) {
    switch(c_enum) {
        case MAVSDK_CAMERA_STORAGE_STORAGE_TYPE_UNKNOWN:
            return mavsdk::Camera::Storage::StorageType::Unknown;
        case MAVSDK_CAMERA_STORAGE_STORAGE_TYPE_USB_STICK:
            return mavsdk::Camera::Storage::StorageType::UsbStick;
        case MAVSDK_CAMERA_STORAGE_STORAGE_TYPE_SD:
            return mavsdk::Camera::Storage::StorageType::Sd;
        case MAVSDK_CAMERA_STORAGE_STORAGE_TYPE_MICROSD:
            return mavsdk::Camera::Storage::StorageType::Microsd;
        case MAVSDK_CAMERA_STORAGE_STORAGE_TYPE_HD:
            return mavsdk::Camera::Storage::StorageType::Hd;
        case MAVSDK_CAMERA_STORAGE_STORAGE_TYPE_OTHER:
            return mavsdk::Camera::Storage::StorageType::Other;
    }
    return mavsdk::Camera::Storage::StorageType::Unknown;
}


static mavsdk::Camera::Storage
translate_storage_from_c(const mavsdk_camera_storage_t& c_struct) {
    mavsdk::Camera::Storage cpp_struct{};
    cpp_struct.component_id = c_struct.component_id;
    cpp_struct.video_on = c_struct.video_on;
    cpp_struct.photo_interval_on = c_struct.photo_interval_on;
    cpp_struct.used_storage_mib = c_struct.used_storage_mib;
    cpp_struct.available_storage_mib = c_struct.available_storage_mib;
    cpp_struct.total_storage_mib = c_struct.total_storage_mib;
    cpp_struct.recording_time_s = c_struct.recording_time_s;
    if (c_struct.media_folder_name) {
        cpp_struct.media_folder_name = c_struct.media_folder_name;
    }
    cpp_struct.storage_status = translate_storage_storage_status_from_c(c_struct.storage_status);
    cpp_struct.storage_id = c_struct.storage_id;
    cpp_struct.storage_type = translate_storage_storage_type_from_c(c_struct.storage_type);
    return cpp_struct;
}


static mavsdk_camera_storage_storage_status_t
translate_storage_storage_status_to_c(mavsdk::Camera::Storage::StorageStatus cpp_enum) {
    switch(cpp_enum) {
        case mavsdk::Camera::Storage::StorageStatus::NotAvailable:
            return MAVSDK_CAMERA_STORAGE_STORAGE_STATUS_NOT_AVAILABLE;
        case mavsdk::Camera::Storage::StorageStatus::Unformatted:
            return MAVSDK_CAMERA_STORAGE_STORAGE_STATUS_UNFORMATTED;
        case mavsdk::Camera::Storage::StorageStatus::Formatted:
            return MAVSDK_CAMERA_STORAGE_STORAGE_STATUS_FORMATTED;
        case mavsdk::Camera::Storage::StorageStatus::NotSupported:
            return MAVSDK_CAMERA_STORAGE_STORAGE_STATUS_NOT_SUPPORTED;
    }
    return MAVSDK_CAMERA_STORAGE_STORAGE_STATUS_NOT_AVAILABLE;
}


static mavsdk_camera_storage_storage_type_t
translate_storage_storage_type_to_c(mavsdk::Camera::Storage::StorageType cpp_enum) {
    switch(cpp_enum) {
        case mavsdk::Camera::Storage::StorageType::Unknown:
            return MAVSDK_CAMERA_STORAGE_STORAGE_TYPE_UNKNOWN;
        case mavsdk::Camera::Storage::StorageType::UsbStick:
            return MAVSDK_CAMERA_STORAGE_STORAGE_TYPE_USB_STICK;
        case mavsdk::Camera::Storage::StorageType::Sd:
            return MAVSDK_CAMERA_STORAGE_STORAGE_TYPE_SD;
        case mavsdk::Camera::Storage::StorageType::Microsd:
            return MAVSDK_CAMERA_STORAGE_STORAGE_TYPE_MICROSD;
        case mavsdk::Camera::Storage::StorageType::Hd:
            return MAVSDK_CAMERA_STORAGE_STORAGE_TYPE_HD;
        case mavsdk::Camera::Storage::StorageType::Other:
            return MAVSDK_CAMERA_STORAGE_STORAGE_TYPE_OTHER;
    }
    return MAVSDK_CAMERA_STORAGE_STORAGE_TYPE_UNKNOWN;
}

static mavsdk_camera_storage_t
translate_storage_to_c(const mavsdk::Camera::Storage& cpp_struct) {
    mavsdk_camera_storage_t c_struct{};
    c_struct.component_id = cpp_struct.component_id;
    c_struct.video_on = cpp_struct.video_on;
    c_struct.photo_interval_on = cpp_struct.photo_interval_on;
    c_struct.used_storage_mib = cpp_struct.used_storage_mib;
    c_struct.available_storage_mib = cpp_struct.available_storage_mib;
    c_struct.total_storage_mib = cpp_struct.total_storage_mib;
    c_struct.recording_time_s = cpp_struct.recording_time_s;
    c_struct.media_folder_name = strdup(cpp_struct.media_folder_name.c_str());
    c_struct.storage_status = translate_storage_storage_status_to_c(cpp_struct.storage_status);
    c_struct.storage_id = cpp_struct.storage_id;
    c_struct.storage_type = translate_storage_storage_type_to_c(cpp_struct.storage_type);
    return c_struct;
}

void mavsdk_camera_storage_destroy(
    mavsdk_camera_storage_t* target) {
    if (!target) return;
    if (target->media_folder_name) {
        free((void*)target->media_folder_name);
        target->media_folder_name = nullptr;
    }
}

void mavsdk_camera_storage_array_destroy(
    mavsdk_camera_storage_t** array,
    size_t size) {
    if (!array || !*array) return;

    for (size_t i = 0; i < size; i++) {
        mavsdk_camera_storage_destroy(&(*array)[i]);
    }

    delete[] *array;
    *array = nullptr;
}


static mavsdk::Camera::StorageUpdate
translate_storage_update_from_c(const mavsdk_camera_storage_update_t& c_struct) {
    mavsdk::Camera::StorageUpdate cpp_struct{};
    cpp_struct.component_id = c_struct.component_id;
    cpp_struct.storage = translate_storage_from_c(c_struct.storage);
    return cpp_struct;
}

static mavsdk_camera_storage_update_t
translate_storage_update_to_c(const mavsdk::Camera::StorageUpdate& cpp_struct) {
    mavsdk_camera_storage_update_t c_struct{};
    c_struct.component_id = cpp_struct.component_id;
    c_struct.storage = translate_storage_to_c(cpp_struct.storage);
    return c_struct;
}

void mavsdk_camera_storage_update_destroy(
    mavsdk_camera_storage_update_t* target) {
    if (!target) return;
}

void mavsdk_camera_storage_update_array_destroy(
    mavsdk_camera_storage_update_t** array,
    size_t size) {
    if (!array || !*array) return;

    for (size_t i = 0; i < size; i++) {
        mavsdk_camera_storage_update_destroy(&(*array)[i]);
    }

    delete[] *array;
    *array = nullptr;
}


static mavsdk::Camera::CurrentSettingsUpdate
translate_current_settings_update_from_c(const mavsdk_camera_current_settings_update_t& c_struct) {
    mavsdk::Camera::CurrentSettingsUpdate cpp_struct{};
    cpp_struct.component_id = c_struct.component_id;
    cpp_struct.current_settings.reserve(c_struct.current_settings_size);
    for (size_t i = 0; i < c_struct.current_settings_size; i++) {
        cpp_struct.current_settings.push_back(
            translate_setting_from_c(c_struct.current_settings[i]));
    }
    return cpp_struct;
}

static mavsdk_camera_current_settings_update_t
translate_current_settings_update_to_c(const mavsdk::Camera::CurrentSettingsUpdate& cpp_struct) {
    mavsdk_camera_current_settings_update_t c_struct{};
    c_struct.component_id = cpp_struct.component_id;
    c_struct.current_settings_size = cpp_struct.current_settings.size();
    c_struct.current_settings = new mavsdk_camera_setting_t[c_struct.current_settings_size];
    for (size_t i = 0; i < c_struct.current_settings_size; i++) {
        c_struct.current_settings[i] = translate_setting_to_c(cpp_struct.current_settings[i]);
    }
    return c_struct;
}

void mavsdk_camera_current_settings_update_destroy(
    mavsdk_camera_current_settings_update_t* target) {
    if (!target) return;
    if (target->current_settings) {
        for (size_t i = 0; i < target->current_settings_size; i++) {
            mavsdk_camera_setting_destroy(&target->current_settings[i]);
        }
        delete[] target->current_settings;
        target->current_settings = nullptr;
        target->current_settings_size = 0;
    }
}

void mavsdk_camera_current_settings_update_array_destroy(
    mavsdk_camera_current_settings_update_t** array,
    size_t size) {
    if (!array || !*array) return;

    for (size_t i = 0; i < size; i++) {
        mavsdk_camera_current_settings_update_destroy(&(*array)[i]);
    }

    delete[] *array;
    *array = nullptr;
}


static mavsdk::Camera::PossibleSettingOptionsUpdate
translate_possible_setting_options_update_from_c(const mavsdk_camera_possible_setting_options_update_t& c_struct) {
    mavsdk::Camera::PossibleSettingOptionsUpdate cpp_struct{};
    cpp_struct.component_id = c_struct.component_id;
    cpp_struct.setting_options.reserve(c_struct.setting_options_size);
    for (size_t i = 0; i < c_struct.setting_options_size; i++) {
        cpp_struct.setting_options.push_back(
            translate_setting_options_from_c(c_struct.setting_options[i]));
    }
    return cpp_struct;
}

static mavsdk_camera_possible_setting_options_update_t
translate_possible_setting_options_update_to_c(const mavsdk::Camera::PossibleSettingOptionsUpdate& cpp_struct) {
    mavsdk_camera_possible_setting_options_update_t c_struct{};
    c_struct.component_id = cpp_struct.component_id;
    c_struct.setting_options_size = cpp_struct.setting_options.size();
    c_struct.setting_options = new mavsdk_camera_setting_options_t[c_struct.setting_options_size];
    for (size_t i = 0; i < c_struct.setting_options_size; i++) {
        c_struct.setting_options[i] = translate_setting_options_to_c(cpp_struct.setting_options[i]);
    }
    return c_struct;
}

void mavsdk_camera_possible_setting_options_update_destroy(
    mavsdk_camera_possible_setting_options_update_t* target) {
    if (!target) return;
    if (target->setting_options) {
        for (size_t i = 0; i < target->setting_options_size; i++) {
            mavsdk_camera_setting_options_destroy(&target->setting_options[i]);
        }
        delete[] target->setting_options;
        target->setting_options = nullptr;
        target->setting_options_size = 0;
    }
}

void mavsdk_camera_possible_setting_options_update_array_destroy(
    mavsdk_camera_possible_setting_options_update_t** array,
    size_t size) {
    if (!array || !*array) return;

    for (size_t i = 0; i < size; i++) {
        mavsdk_camera_possible_setting_options_update_destroy(&(*array)[i]);
    }

    delete[] *array;
    *array = nullptr;
}



static mavsdk::Camera::Position
translate_position_from_c(const mavsdk_camera_position_t& c_struct) {
    mavsdk::Camera::Position cpp_struct{};
    cpp_struct.latitude_deg = c_struct.latitude_deg;
    cpp_struct.longitude_deg = c_struct.longitude_deg;
    cpp_struct.absolute_altitude_m = c_struct.absolute_altitude_m;
    cpp_struct.relative_altitude_m = c_struct.relative_altitude_m;
    return cpp_struct;
}

static mavsdk_camera_position_t
translate_position_to_c(const mavsdk::Camera::Position& cpp_struct) {
    mavsdk_camera_position_t c_struct{};
    c_struct.latitude_deg = cpp_struct.latitude_deg;
    c_struct.longitude_deg = cpp_struct.longitude_deg;
    c_struct.absolute_altitude_m = cpp_struct.absolute_altitude_m;
    c_struct.relative_altitude_m = cpp_struct.relative_altitude_m;
    return c_struct;
}

void mavsdk_camera_position_destroy(
    mavsdk_camera_position_t* target) {
    if (!target) return;
}

void mavsdk_camera_position_array_destroy(
    mavsdk_camera_position_t** array,
    size_t size) {
    if (!array || !*array) return;

    for (size_t i = 0; i < size; i++) {
        mavsdk_camera_position_destroy(&(*array)[i]);
    }

    delete[] *array;
    *array = nullptr;
}


static mavsdk::Camera::Quaternion
translate_quaternion_from_c(const mavsdk_camera_quaternion_t& c_struct) {
    mavsdk::Camera::Quaternion cpp_struct{};
    cpp_struct.w = c_struct.w;
    cpp_struct.x = c_struct.x;
    cpp_struct.y = c_struct.y;
    cpp_struct.z = c_struct.z;
    return cpp_struct;
}

static mavsdk_camera_quaternion_t
translate_quaternion_to_c(const mavsdk::Camera::Quaternion& cpp_struct) {
    mavsdk_camera_quaternion_t c_struct{};
    c_struct.w = cpp_struct.w;
    c_struct.x = cpp_struct.x;
    c_struct.y = cpp_struct.y;
    c_struct.z = cpp_struct.z;
    return c_struct;
}

void mavsdk_camera_quaternion_destroy(
    mavsdk_camera_quaternion_t* target) {
    if (!target) return;
}

void mavsdk_camera_quaternion_array_destroy(
    mavsdk_camera_quaternion_t** array,
    size_t size) {
    if (!array || !*array) return;

    for (size_t i = 0; i < size; i++) {
        mavsdk_camera_quaternion_destroy(&(*array)[i]);
    }

    delete[] *array;
    *array = nullptr;
}


static mavsdk::Camera::EulerAngle
translate_euler_angle_from_c(const mavsdk_camera_euler_angle_t& c_struct) {
    mavsdk::Camera::EulerAngle cpp_struct{};
    cpp_struct.roll_deg = c_struct.roll_deg;
    cpp_struct.pitch_deg = c_struct.pitch_deg;
    cpp_struct.yaw_deg = c_struct.yaw_deg;
    return cpp_struct;
}

static mavsdk_camera_euler_angle_t
translate_euler_angle_to_c(const mavsdk::Camera::EulerAngle& cpp_struct) {
    mavsdk_camera_euler_angle_t c_struct{};
    c_struct.roll_deg = cpp_struct.roll_deg;
    c_struct.pitch_deg = cpp_struct.pitch_deg;
    c_struct.yaw_deg = cpp_struct.yaw_deg;
    return c_struct;
}

void mavsdk_camera_euler_angle_destroy(
    mavsdk_camera_euler_angle_t* target) {
    if (!target) return;
}

void mavsdk_camera_euler_angle_array_destroy(
    mavsdk_camera_euler_angle_t** array,
    size_t size) {
    if (!array || !*array) return;

    for (size_t i = 0; i < size; i++) {
        mavsdk_camera_euler_angle_destroy(&(*array)[i]);
    }

    delete[] *array;
    *array = nullptr;
}


static mavsdk::Camera::CaptureInfo
translate_capture_info_from_c(const mavsdk_camera_capture_info_t& c_struct) {
    mavsdk::Camera::CaptureInfo cpp_struct{};
    cpp_struct.component_id = c_struct.component_id;
    cpp_struct.position = translate_position_from_c(c_struct.position);
    cpp_struct.attitude_quaternion = translate_quaternion_from_c(c_struct.attitude_quaternion);
    cpp_struct.attitude_euler_angle = translate_euler_angle_from_c(c_struct.attitude_euler_angle);
    cpp_struct.time_utc_us = c_struct.time_utc_us;
    cpp_struct.is_success = c_struct.is_success;
    cpp_struct.index = c_struct.index;
    if (c_struct.file_url) {
        cpp_struct.file_url = c_struct.file_url;
    }
    return cpp_struct;
}

static mavsdk_camera_capture_info_t
translate_capture_info_to_c(const mavsdk::Camera::CaptureInfo& cpp_struct) {
    mavsdk_camera_capture_info_t c_struct{};
    c_struct.component_id = cpp_struct.component_id;
    c_struct.position = translate_position_to_c(cpp_struct.position);
    c_struct.attitude_quaternion = translate_quaternion_to_c(cpp_struct.attitude_quaternion);
    c_struct.attitude_euler_angle = translate_euler_angle_to_c(cpp_struct.attitude_euler_angle);
    c_struct.time_utc_us = cpp_struct.time_utc_us;
    c_struct.is_success = cpp_struct.is_success;
    c_struct.index = cpp_struct.index;
    c_struct.file_url = strdup(cpp_struct.file_url.c_str());
    return c_struct;
}

void mavsdk_camera_capture_info_destroy(
    mavsdk_camera_capture_info_t* target) {
    if (!target) return;
    if (target->file_url) {
        free((void*)target->file_url);
        target->file_url = nullptr;
    }
}

void mavsdk_camera_capture_info_array_destroy(
    mavsdk_camera_capture_info_t** array,
    size_t size) {
    if (!array || !*array) return;

    for (size_t i = 0; i < size; i++) {
        mavsdk_camera_capture_info_destroy(&(*array)[i]);
    }

    delete[] *array;
    *array = nullptr;
}


static mavsdk::Camera::Information
translate_information_from_c(const mavsdk_camera_information_t& c_struct) {
    mavsdk::Camera::Information cpp_struct{};
    cpp_struct.component_id = c_struct.component_id;
    if (c_struct.vendor_name) {
        cpp_struct.vendor_name = c_struct.vendor_name;
    }
    if (c_struct.model_name) {
        cpp_struct.model_name = c_struct.model_name;
    }
    cpp_struct.focal_length_mm = c_struct.focal_length_mm;
    cpp_struct.horizontal_sensor_size_mm = c_struct.horizontal_sensor_size_mm;
    cpp_struct.vertical_sensor_size_mm = c_struct.vertical_sensor_size_mm;
    cpp_struct.horizontal_resolution_px = c_struct.horizontal_resolution_px;
    cpp_struct.vertical_resolution_px = c_struct.vertical_resolution_px;
    return cpp_struct;
}

static mavsdk_camera_information_t
translate_information_to_c(const mavsdk::Camera::Information& cpp_struct) {
    mavsdk_camera_information_t c_struct{};
    c_struct.component_id = cpp_struct.component_id;
    c_struct.vendor_name = strdup(cpp_struct.vendor_name.c_str());
    c_struct.model_name = strdup(cpp_struct.model_name.c_str());
    c_struct.focal_length_mm = cpp_struct.focal_length_mm;
    c_struct.horizontal_sensor_size_mm = cpp_struct.horizontal_sensor_size_mm;
    c_struct.vertical_sensor_size_mm = cpp_struct.vertical_sensor_size_mm;
    c_struct.horizontal_resolution_px = cpp_struct.horizontal_resolution_px;
    c_struct.vertical_resolution_px = cpp_struct.vertical_resolution_px;
    return c_struct;
}

void mavsdk_camera_information_destroy(
    mavsdk_camera_information_t* target) {
    if (!target) return;
    if (target->vendor_name) {
        free((void*)target->vendor_name);
        target->vendor_name = nullptr;
    }
    if (target->model_name) {
        free((void*)target->model_name);
        target->model_name = nullptr;
    }
}

void mavsdk_camera_information_array_destroy(
    mavsdk_camera_information_t** array,
    size_t size) {
    if (!array || !*array) return;

    for (size_t i = 0; i < size; i++) {
        mavsdk_camera_information_destroy(&(*array)[i]);
    }

    delete[] *array;
    *array = nullptr;
}


static mavsdk::Camera::CameraList
translate_camera_list_from_c(const mavsdk_camera_camera_list_t& c_struct) {
    mavsdk::Camera::CameraList cpp_struct{};
    cpp_struct.cameras.reserve(c_struct.cameras_size);
    for (size_t i = 0; i < c_struct.cameras_size; i++) {
        cpp_struct.cameras.push_back(
            translate_information_from_c(c_struct.cameras[i]));
    }
    return cpp_struct;
}

static mavsdk_camera_camera_list_t
translate_camera_list_to_c(const mavsdk::Camera::CameraList& cpp_struct) {
    mavsdk_camera_camera_list_t c_struct{};
    c_struct.cameras_size = cpp_struct.cameras.size();
    c_struct.cameras = new mavsdk_camera_information_t[c_struct.cameras_size];
    for (size_t i = 0; i < c_struct.cameras_size; i++) {
        c_struct.cameras[i] = translate_information_to_c(cpp_struct.cameras[i]);
    }
    return c_struct;
}

void mavsdk_camera_camera_list_destroy(
    mavsdk_camera_camera_list_t* target) {
    if (!target) return;
    if (target->cameras) {
        for (size_t i = 0; i < target->cameras_size; i++) {
            mavsdk_camera_information_destroy(&target->cameras[i]);
        }
        delete[] target->cameras;
        target->cameras = nullptr;
        target->cameras_size = 0;
    }
}

void mavsdk_camera_camera_list_array_destroy(
    mavsdk_camera_camera_list_t** array,
    size_t size) {
    if (!array || !*array) return;

    for (size_t i = 0; i < size; i++) {
        mavsdk_camera_camera_list_destroy(&(*array)[i]);
    }

    delete[] *array;
    *array = nullptr;
}


// ===== Primitive Array Destroy Functions =====
void mavsdk_camera_float_array_destroy(float** array) {
    if (!array || !*array) return;
    delete[] *array;
    *array = nullptr;
}

void mavsdk_camera_double_array_destroy(double** array) {
    if (!array || !*array) return;
    delete[] *array;
    *array = nullptr;
}

void mavsdk_camera_int32t_array_destroy(int32_t** array) {
    if (!array || !*array) return;
    delete[] *array;
    *array = nullptr;
}

void mavsdk_camera_uint32t_array_destroy(uint32_t** array) {
    if (!array || !*array) return;
    delete[] *array;
    *array = nullptr;
}

void mavsdk_camera_int64t_array_destroy(int64_t** array) {
    if (!array || !*array) return;
    delete[] *array;
    *array = nullptr;
}

void mavsdk_camera_uint64t_array_destroy(uint64_t** array) {
    if (!array || !*array) return;
    delete[] *array;
    *array = nullptr;
}

void mavsdk_camera_bool_array_destroy(bool** array) {
    if (!array || !*array) return;
    delete[] *array;
    *array = nullptr;
}


void mavsdk_camera_string_destroy(char** str) {
    if (!str || !*str) return;
    free(*str);
    *str = nullptr;
}

void mavsdk_camera_byte_buffer_destroy(uint8_t** buffer) {
    if (!buffer || !*buffer) return;
    delete[] *buffer;
    *buffer = nullptr;
}

// ===== Camera Wrapper =====

struct mavsdk_camera_wrapper {
    std::shared_ptr<mavsdk::Camera> cpp_plugin;
    std::mutex handles_mutex;
    std::vector<mavsdk::Camera::CameraListHandle*> camera_list_handles;
    std::vector<mavsdk::Camera::ModeHandle*> mode_handles;
    std::vector<mavsdk::Camera::VideoStreamInfoHandle*> video_stream_info_handles;
    std::vector<mavsdk::Camera::CaptureInfoHandle*> capture_info_handles;
    std::vector<mavsdk::Camera::StorageHandle*> storage_handles;
    std::vector<mavsdk::Camera::CurrentSettingsHandle*> current_settings_handles;
    std::vector<mavsdk::Camera::PossibleSettingOptionsHandle*> possible_setting_options_handles;
};

mavsdk_camera_t
mavsdk_camera_create(mavsdk_system_t system) {
    if (system == nullptr) {
        return nullptr;
    }

    auto wrapper = new mavsdk_camera_wrapper();
    auto system_ptr = reinterpret_cast<std::shared_ptr<mavsdk::System>*>(system);
    wrapper->cpp_plugin = std::make_shared<mavsdk::Camera>(*system_ptr);

    return reinterpret_cast<mavsdk_camera_t>(wrapper);
}

void mavsdk_camera_destroy(mavsdk_camera_t camera) {
    if (camera == nullptr) {
        return;
    }

    auto wrapper = reinterpret_cast<mavsdk_camera_wrapper*>(camera);

    // Unsubscribe all active streams before destroying to prevent
    // callbacks firing into a destroyed object
    {
        std::lock_guard<std::mutex> lock(wrapper->handles_mutex);
        for (auto* h : wrapper->camera_list_handles) {
            wrapper->cpp_plugin->unsubscribe_camera_list(std::move(*h));
            delete h;
        }
        wrapper->camera_list_handles.clear();
        for (auto* h : wrapper->mode_handles) {
            wrapper->cpp_plugin->unsubscribe_mode(std::move(*h));
            delete h;
        }
        wrapper->mode_handles.clear();
        for (auto* h : wrapper->video_stream_info_handles) {
            wrapper->cpp_plugin->unsubscribe_video_stream_info(std::move(*h));
            delete h;
        }
        wrapper->video_stream_info_handles.clear();
        for (auto* h : wrapper->capture_info_handles) {
            wrapper->cpp_plugin->unsubscribe_capture_info(std::move(*h));
            delete h;
        }
        wrapper->capture_info_handles.clear();
        for (auto* h : wrapper->storage_handles) {
            wrapper->cpp_plugin->unsubscribe_storage(std::move(*h));
            delete h;
        }
        wrapper->storage_handles.clear();
        for (auto* h : wrapper->current_settings_handles) {
            wrapper->cpp_plugin->unsubscribe_current_settings(std::move(*h));
            delete h;
        }
        wrapper->current_settings_handles.clear();
        for (auto* h : wrapper->possible_setting_options_handles) {
            wrapper->cpp_plugin->unsubscribe_possible_setting_options(std::move(*h));
            delete h;
        }
        wrapper->possible_setting_options_handles.clear();
    }

    delete wrapper;
}

// ===== Method Implementations =====

// TakePhoto async
void mavsdk_camera_take_photo_async(
    mavsdk_camera_t camera,
    int32_t component_id,
    mavsdk_camera_take_photo_callback_t callback,
    void* user_data)
{
    auto wrapper = reinterpret_cast<mavsdk_camera_wrapper*>(camera);

    wrapper->cpp_plugin->take_photo_async(
        component_id,
        [callback, user_data](
            mavsdk::Camera::Result result) {
                if (callback) {
                    callback(
                        translate_result(result),
                        user_data);
                }
        });
}


// TakePhoto sync
mavsdk_camera_result_t
mavsdk_camera_take_photo(
    mavsdk_camera_t camera,
    int32_t component_id)
{
    auto wrapper = reinterpret_cast<mavsdk_camera_wrapper*>(camera);

    auto ret_value = wrapper->cpp_plugin->take_photo(        component_id);

    return translate_result(ret_value);
}

// StartPhotoInterval async
void mavsdk_camera_start_photo_interval_async(
    mavsdk_camera_t camera,
    int32_t component_id,
    float interval_s,
    mavsdk_camera_start_photo_interval_callback_t callback,
    void* user_data)
{
    auto wrapper = reinterpret_cast<mavsdk_camera_wrapper*>(camera);

    wrapper->cpp_plugin->start_photo_interval_async(
        component_id,
        interval_s,
        [callback, user_data](
            mavsdk::Camera::Result result) {
                if (callback) {
                    callback(
                        translate_result(result),
                        user_data);
                }
        });
}


// StartPhotoInterval sync
mavsdk_camera_result_t
mavsdk_camera_start_photo_interval(
    mavsdk_camera_t camera,
    int32_t component_id,
    float interval_s)
{
    auto wrapper = reinterpret_cast<mavsdk_camera_wrapper*>(camera);

    auto ret_value = wrapper->cpp_plugin->start_photo_interval(        component_id,        interval_s);

    return translate_result(ret_value);
}

// StopPhotoInterval async
void mavsdk_camera_stop_photo_interval_async(
    mavsdk_camera_t camera,
    int32_t component_id,
    mavsdk_camera_stop_photo_interval_callback_t callback,
    void* user_data)
{
    auto wrapper = reinterpret_cast<mavsdk_camera_wrapper*>(camera);

    wrapper->cpp_plugin->stop_photo_interval_async(
        component_id,
        [callback, user_data](
            mavsdk::Camera::Result result) {
                if (callback) {
                    callback(
                        translate_result(result),
                        user_data);
                }
        });
}


// StopPhotoInterval sync
mavsdk_camera_result_t
mavsdk_camera_stop_photo_interval(
    mavsdk_camera_t camera,
    int32_t component_id)
{
    auto wrapper = reinterpret_cast<mavsdk_camera_wrapper*>(camera);

    auto ret_value = wrapper->cpp_plugin->stop_photo_interval(        component_id);

    return translate_result(ret_value);
}

// StartVideo async
void mavsdk_camera_start_video_async(
    mavsdk_camera_t camera,
    int32_t component_id,
    mavsdk_camera_start_video_callback_t callback,
    void* user_data)
{
    auto wrapper = reinterpret_cast<mavsdk_camera_wrapper*>(camera);

    wrapper->cpp_plugin->start_video_async(
        component_id,
        [callback, user_data](
            mavsdk::Camera::Result result) {
                if (callback) {
                    callback(
                        translate_result(result),
                        user_data);
                }
        });
}


// StartVideo sync
mavsdk_camera_result_t
mavsdk_camera_start_video(
    mavsdk_camera_t camera,
    int32_t component_id)
{
    auto wrapper = reinterpret_cast<mavsdk_camera_wrapper*>(camera);

    auto ret_value = wrapper->cpp_plugin->start_video(        component_id);

    return translate_result(ret_value);
}

// StopVideo async
void mavsdk_camera_stop_video_async(
    mavsdk_camera_t camera,
    int32_t component_id,
    mavsdk_camera_stop_video_callback_t callback,
    void* user_data)
{
    auto wrapper = reinterpret_cast<mavsdk_camera_wrapper*>(camera);

    wrapper->cpp_plugin->stop_video_async(
        component_id,
        [callback, user_data](
            mavsdk::Camera::Result result) {
                if (callback) {
                    callback(
                        translate_result(result),
                        user_data);
                }
        });
}


// StopVideo sync
mavsdk_camera_result_t
mavsdk_camera_stop_video(
    mavsdk_camera_t camera,
    int32_t component_id)
{
    auto wrapper = reinterpret_cast<mavsdk_camera_wrapper*>(camera);

    auto ret_value = wrapper->cpp_plugin->stop_video(        component_id);

    return translate_result(ret_value);
}


// StartVideoStreaming sync
mavsdk_camera_result_t
mavsdk_camera_start_video_streaming(
    mavsdk_camera_t camera,
    int32_t component_id,
    int32_t stream_id)
{
    auto wrapper = reinterpret_cast<mavsdk_camera_wrapper*>(camera);

    auto ret_value = wrapper->cpp_plugin->start_video_streaming(        component_id,        stream_id);

    return translate_result(ret_value);
}


// StopVideoStreaming sync
mavsdk_camera_result_t
mavsdk_camera_stop_video_streaming(
    mavsdk_camera_t camera,
    int32_t component_id,
    int32_t stream_id)
{
    auto wrapper = reinterpret_cast<mavsdk_camera_wrapper*>(camera);

    auto ret_value = wrapper->cpp_plugin->stop_video_streaming(        component_id,        stream_id);

    return translate_result(ret_value);
}

// SetMode async
void mavsdk_camera_set_mode_async(
    mavsdk_camera_t camera,
    int32_t component_id,
    mavsdk_camera_mode_t mode,
    mavsdk_camera_set_mode_callback_t callback,
    void* user_data)
{
    auto wrapper = reinterpret_cast<mavsdk_camera_wrapper*>(camera);

    wrapper->cpp_plugin->set_mode_async(
        component_id,
        translate_mode_from_c(mode),
        [callback, user_data](
            mavsdk::Camera::Result result) {
                if (callback) {
                    callback(
                        translate_result(result),
                        user_data);
                }
        });
}


// SetMode sync
mavsdk_camera_result_t
mavsdk_camera_set_mode(
    mavsdk_camera_t camera,
    int32_t component_id,
    mavsdk_camera_mode_t mode)
{
    auto wrapper = reinterpret_cast<mavsdk_camera_wrapper*>(camera);

    auto ret_value = wrapper->cpp_plugin->set_mode(        component_id,        translate_mode_from_c(mode));

    return translate_result(ret_value);
}

// ListPhotos async
void mavsdk_camera_list_photos_async(
    mavsdk_camera_t camera,
    int32_t component_id,
    mavsdk_camera_photos_range_t photos_range,
    mavsdk_camera_list_photos_callback_t callback,
    void* user_data)
{
    auto wrapper = reinterpret_cast<mavsdk_camera_wrapper*>(camera);

    wrapper->cpp_plugin->list_photos_async(
        component_id,
        translate_photos_range_from_c(photos_range),
        [callback, user_data](
            mavsdk::Camera::Result result,
            std::vector<mavsdk::Camera::CaptureInfo> value) {
                if (callback) {
                    size_t count = value.size();
                    mavsdk_camera_capture_info_t* capture_infos = nullptr;

                    if (count > 0) {
                        capture_infos = new mavsdk_camera_capture_info_t[count];
                        for (size_t i = 0; i < count; i++) {
                            capture_infos[i] = translate_capture_info_to_c(value[i]);
                        }
                    }

                    callback(
                        translate_result(result),
                        capture_infos,
                        count,
                        user_data);
                }
        });
}


// ListPhotos sync
mavsdk_camera_result_t
mavsdk_camera_list_photos(
    mavsdk_camera_t camera,
    int32_t component_id,
    mavsdk_camera_photos_range_t photos_range,
    mavsdk_camera_capture_info_t** capture_infos_out,
    size_t* capture_infos_size_out)
{
    auto wrapper = reinterpret_cast<mavsdk_camera_wrapper*>(camera);

    auto result_pair = wrapper->cpp_plugin->list_photos(
        component_id,
        translate_photos_range_from_c(photos_range));

    if (capture_infos_out != nullptr) {
        size_t count = result_pair.second.size();

        *capture_infos_out = new mavsdk_camera_capture_info_t[count];

        for (size_t i = 0; i < count; i++) {
            (*capture_infos_out)[i] = translate_capture_info_to_c(result_pair.second[i]);
        }

        if (capture_infos_size_out != nullptr) {
            *capture_infos_size_out = count;
        }
    }

    return translate_result(result_pair.first);
}

// CameraList async
mavsdk_camera_camera_list_handle_t mavsdk_camera_subscribe_camera_list(
    mavsdk_camera_t camera,
    mavsdk_camera_camera_list_callback_t callback,
    void* user_data)
{
    auto wrapper = reinterpret_cast<mavsdk_camera_wrapper*>(camera);

    auto cpp_handle =    wrapper->cpp_plugin->subscribe_camera_list(
        [callback, user_data](
            mavsdk::Camera::CameraList value) {
                if (callback) {
                    callback(
                        translate_camera_list_to_c(value),
                        user_data);
                }
        });

    auto cpp_handle_ptr = new mavsdk::Camera::CameraListHandle(std::move(cpp_handle));

    {
        std::lock_guard<std::mutex> lock(wrapper->handles_mutex);
        wrapper->camera_list_handles.push_back(cpp_handle_ptr);
    }

    return reinterpret_cast<mavsdk_camera_camera_list_handle_t>(cpp_handle_ptr);
}

void mavsdk_camera_unsubscribe_camera_list(
    mavsdk_camera_t camera,
    mavsdk_camera_camera_list_handle_t handle)
{
    if (handle) {
        auto wrapper = reinterpret_cast<mavsdk_camera_wrapper*>(camera);
        auto cpp_handle = reinterpret_cast<mavsdk::Camera::CameraListHandle*>(handle);

        {
            std::lock_guard<std::mutex> lock(wrapper->handles_mutex);
            auto& vec = wrapper->camera_list_handles;
            vec.erase(std::remove(vec.begin(), vec.end(), cpp_handle), vec.end());
        }

        wrapper->cpp_plugin->unsubscribe_camera_list(std::move(*cpp_handle));
        delete cpp_handle;
    }
}

// CameraList sync
void
mavsdk_camera_camera_list(
    mavsdk_camera_t camera,
    mavsdk_camera_camera_list_t* camera_list_out)
{
    auto wrapper = reinterpret_cast<mavsdk_camera_wrapper*>(camera);

    auto ret_value = wrapper->cpp_plugin->camera_list();

    if (camera_list_out != nullptr) {
        *camera_list_out = translate_camera_list_to_c(ret_value);
    }
}

// Mode async
mavsdk_camera_mode_handle_t mavsdk_camera_subscribe_mode(
    mavsdk_camera_t camera,
    mavsdk_camera_mode_callback_t callback,
    void* user_data)
{
    auto wrapper = reinterpret_cast<mavsdk_camera_wrapper*>(camera);

    auto cpp_handle =    wrapper->cpp_plugin->subscribe_mode(
        [callback, user_data](
            mavsdk::Camera::ModeUpdate value) {
                if (callback) {
                    callback(
                        translate_mode_update_to_c(value),
                        user_data);
                }
        });

    auto cpp_handle_ptr = new mavsdk::Camera::ModeHandle(std::move(cpp_handle));

    {
        std::lock_guard<std::mutex> lock(wrapper->handles_mutex);
        wrapper->mode_handles.push_back(cpp_handle_ptr);
    }

    return reinterpret_cast<mavsdk_camera_mode_handle_t>(cpp_handle_ptr);
}

void mavsdk_camera_unsubscribe_mode(
    mavsdk_camera_t camera,
    mavsdk_camera_mode_handle_t handle)
{
    if (handle) {
        auto wrapper = reinterpret_cast<mavsdk_camera_wrapper*>(camera);
        auto cpp_handle = reinterpret_cast<mavsdk::Camera::ModeHandle*>(handle);

        {
            std::lock_guard<std::mutex> lock(wrapper->handles_mutex);
            auto& vec = wrapper->mode_handles;
            vec.erase(std::remove(vec.begin(), vec.end(), cpp_handle), vec.end());
        }

        wrapper->cpp_plugin->unsubscribe_mode(std::move(*cpp_handle));
        delete cpp_handle;
    }
}



// GetMode sync
mavsdk_camera_result_t
mavsdk_camera_get_mode(
    mavsdk_camera_t camera,
    int32_t component_id,
    mavsdk_camera_mode_t* mode_out)
{
    auto wrapper = reinterpret_cast<mavsdk_camera_wrapper*>(camera);

    auto result_pair = wrapper->cpp_plugin->get_mode(
        component_id);

    if (mode_out != nullptr) {
        *mode_out = translate_mode_to_c(result_pair.second);
    }

    return translate_result(result_pair.first);
}

// VideoStreamInfo async
mavsdk_camera_video_stream_info_handle_t mavsdk_camera_subscribe_video_stream_info(
    mavsdk_camera_t camera,
    mavsdk_camera_video_stream_info_callback_t callback,
    void* user_data)
{
    auto wrapper = reinterpret_cast<mavsdk_camera_wrapper*>(camera);

    auto cpp_handle =    wrapper->cpp_plugin->subscribe_video_stream_info(
        [callback, user_data](
            mavsdk::Camera::VideoStreamUpdate value) {
                if (callback) {
                    callback(
                        translate_video_stream_update_to_c(value),
                        user_data);
                }
        });

    auto cpp_handle_ptr = new mavsdk::Camera::VideoStreamInfoHandle(std::move(cpp_handle));

    {
        std::lock_guard<std::mutex> lock(wrapper->handles_mutex);
        wrapper->video_stream_info_handles.push_back(cpp_handle_ptr);
    }

    return reinterpret_cast<mavsdk_camera_video_stream_info_handle_t>(cpp_handle_ptr);
}

void mavsdk_camera_unsubscribe_video_stream_info(
    mavsdk_camera_t camera,
    mavsdk_camera_video_stream_info_handle_t handle)
{
    if (handle) {
        auto wrapper = reinterpret_cast<mavsdk_camera_wrapper*>(camera);
        auto cpp_handle = reinterpret_cast<mavsdk::Camera::VideoStreamInfoHandle*>(handle);

        {
            std::lock_guard<std::mutex> lock(wrapper->handles_mutex);
            auto& vec = wrapper->video_stream_info_handles;
            vec.erase(std::remove(vec.begin(), vec.end(), cpp_handle), vec.end());
        }

        wrapper->cpp_plugin->unsubscribe_video_stream_info(std::move(*cpp_handle));
        delete cpp_handle;
    }
}



// GetVideoStreamInfo sync
mavsdk_camera_result_t
mavsdk_camera_get_video_stream_info(
    mavsdk_camera_t camera,
    int32_t component_id,
    mavsdk_camera_video_stream_info_t* video_stream_info_out)
{
    auto wrapper = reinterpret_cast<mavsdk_camera_wrapper*>(camera);

    auto result_pair = wrapper->cpp_plugin->get_video_stream_info(
        component_id);

    if (video_stream_info_out != nullptr) {
        *video_stream_info_out = translate_video_stream_info_to_c(result_pair.second);
    }

    return translate_result(result_pair.first);
}

// CaptureInfo async
mavsdk_camera_capture_info_handle_t mavsdk_camera_subscribe_capture_info(
    mavsdk_camera_t camera,
    mavsdk_camera_capture_info_callback_t callback,
    void* user_data)
{
    auto wrapper = reinterpret_cast<mavsdk_camera_wrapper*>(camera);

    auto cpp_handle =    wrapper->cpp_plugin->subscribe_capture_info(
        [callback, user_data](
            mavsdk::Camera::CaptureInfo value) {
                if (callback) {
                    callback(
                        translate_capture_info_to_c(value),
                        user_data);
                }
        });

    auto cpp_handle_ptr = new mavsdk::Camera::CaptureInfoHandle(std::move(cpp_handle));

    {
        std::lock_guard<std::mutex> lock(wrapper->handles_mutex);
        wrapper->capture_info_handles.push_back(cpp_handle_ptr);
    }

    return reinterpret_cast<mavsdk_camera_capture_info_handle_t>(cpp_handle_ptr);
}

void mavsdk_camera_unsubscribe_capture_info(
    mavsdk_camera_t camera,
    mavsdk_camera_capture_info_handle_t handle)
{
    if (handle) {
        auto wrapper = reinterpret_cast<mavsdk_camera_wrapper*>(camera);
        auto cpp_handle = reinterpret_cast<mavsdk::Camera::CaptureInfoHandle*>(handle);

        {
            std::lock_guard<std::mutex> lock(wrapper->handles_mutex);
            auto& vec = wrapper->capture_info_handles;
            vec.erase(std::remove(vec.begin(), vec.end(), cpp_handle), vec.end());
        }

        wrapper->cpp_plugin->unsubscribe_capture_info(std::move(*cpp_handle));
        delete cpp_handle;
    }
}


// Storage async
mavsdk_camera_storage_handle_t mavsdk_camera_subscribe_storage(
    mavsdk_camera_t camera,
    mavsdk_camera_storage_callback_t callback,
    void* user_data)
{
    auto wrapper = reinterpret_cast<mavsdk_camera_wrapper*>(camera);

    auto cpp_handle =    wrapper->cpp_plugin->subscribe_storage(
        [callback, user_data](
            mavsdk::Camera::StorageUpdate value) {
                if (callback) {
                    callback(
                        translate_storage_update_to_c(value),
                        user_data);
                }
        });

    auto cpp_handle_ptr = new mavsdk::Camera::StorageHandle(std::move(cpp_handle));

    {
        std::lock_guard<std::mutex> lock(wrapper->handles_mutex);
        wrapper->storage_handles.push_back(cpp_handle_ptr);
    }

    return reinterpret_cast<mavsdk_camera_storage_handle_t>(cpp_handle_ptr);
}

void mavsdk_camera_unsubscribe_storage(
    mavsdk_camera_t camera,
    mavsdk_camera_storage_handle_t handle)
{
    if (handle) {
        auto wrapper = reinterpret_cast<mavsdk_camera_wrapper*>(camera);
        auto cpp_handle = reinterpret_cast<mavsdk::Camera::StorageHandle*>(handle);

        {
            std::lock_guard<std::mutex> lock(wrapper->handles_mutex);
            auto& vec = wrapper->storage_handles;
            vec.erase(std::remove(vec.begin(), vec.end(), cpp_handle), vec.end());
        }

        wrapper->cpp_plugin->unsubscribe_storage(std::move(*cpp_handle));
        delete cpp_handle;
    }
}



// GetStorage sync
mavsdk_camera_result_t
mavsdk_camera_get_storage(
    mavsdk_camera_t camera,
    int32_t component_id,
    mavsdk_camera_storage_t* storage_out)
{
    auto wrapper = reinterpret_cast<mavsdk_camera_wrapper*>(camera);

    auto result_pair = wrapper->cpp_plugin->get_storage(
        component_id);

    if (storage_out != nullptr) {
        *storage_out = translate_storage_to_c(result_pair.second);
    }

    return translate_result(result_pair.first);
}

// CurrentSettings async
mavsdk_camera_current_settings_handle_t mavsdk_camera_subscribe_current_settings(
    mavsdk_camera_t camera,
    mavsdk_camera_current_settings_callback_t callback,
    void* user_data)
{
    auto wrapper = reinterpret_cast<mavsdk_camera_wrapper*>(camera);

    auto cpp_handle =    wrapper->cpp_plugin->subscribe_current_settings(
        [callback, user_data](
            mavsdk::Camera::CurrentSettingsUpdate value) {
                if (callback) {
                    callback(
                        translate_current_settings_update_to_c(value),
                        user_data);
                }
        });

    auto cpp_handle_ptr = new mavsdk::Camera::CurrentSettingsHandle(std::move(cpp_handle));

    {
        std::lock_guard<std::mutex> lock(wrapper->handles_mutex);
        wrapper->current_settings_handles.push_back(cpp_handle_ptr);
    }

    return reinterpret_cast<mavsdk_camera_current_settings_handle_t>(cpp_handle_ptr);
}

void mavsdk_camera_unsubscribe_current_settings(
    mavsdk_camera_t camera,
    mavsdk_camera_current_settings_handle_t handle)
{
    if (handle) {
        auto wrapper = reinterpret_cast<mavsdk_camera_wrapper*>(camera);
        auto cpp_handle = reinterpret_cast<mavsdk::Camera::CurrentSettingsHandle*>(handle);

        {
            std::lock_guard<std::mutex> lock(wrapper->handles_mutex);
            auto& vec = wrapper->current_settings_handles;
            vec.erase(std::remove(vec.begin(), vec.end(), cpp_handle), vec.end());
        }

        wrapper->cpp_plugin->unsubscribe_current_settings(std::move(*cpp_handle));
        delete cpp_handle;
    }
}



// GetCurrentSettings sync
mavsdk_camera_result_t
mavsdk_camera_get_current_settings(
    mavsdk_camera_t camera,
    int32_t component_id,
    mavsdk_camera_setting_t** current_settings_out,
    size_t* current_settings_size_out)
{
    auto wrapper = reinterpret_cast<mavsdk_camera_wrapper*>(camera);

    auto result_pair = wrapper->cpp_plugin->get_current_settings(
        component_id);

    if (current_settings_out != nullptr) {
        size_t count = result_pair.second.size();

        *current_settings_out = new mavsdk_camera_setting_t[count];

        for (size_t i = 0; i < count; i++) {
            (*current_settings_out)[i] = translate_setting_to_c(result_pair.second[i]);
        }

        if (current_settings_size_out != nullptr) {
            *current_settings_size_out = count;
        }
    }

    return translate_result(result_pair.first);
}

// PossibleSettingOptions async
mavsdk_camera_possible_setting_options_handle_t mavsdk_camera_subscribe_possible_setting_options(
    mavsdk_camera_t camera,
    mavsdk_camera_possible_setting_options_callback_t callback,
    void* user_data)
{
    auto wrapper = reinterpret_cast<mavsdk_camera_wrapper*>(camera);

    auto cpp_handle =    wrapper->cpp_plugin->subscribe_possible_setting_options(
        [callback, user_data](
            mavsdk::Camera::PossibleSettingOptionsUpdate value) {
                if (callback) {
                    callback(
                        translate_possible_setting_options_update_to_c(value),
                        user_data);
                }
        });

    auto cpp_handle_ptr = new mavsdk::Camera::PossibleSettingOptionsHandle(std::move(cpp_handle));

    {
        std::lock_guard<std::mutex> lock(wrapper->handles_mutex);
        wrapper->possible_setting_options_handles.push_back(cpp_handle_ptr);
    }

    return reinterpret_cast<mavsdk_camera_possible_setting_options_handle_t>(cpp_handle_ptr);
}

void mavsdk_camera_unsubscribe_possible_setting_options(
    mavsdk_camera_t camera,
    mavsdk_camera_possible_setting_options_handle_t handle)
{
    if (handle) {
        auto wrapper = reinterpret_cast<mavsdk_camera_wrapper*>(camera);
        auto cpp_handle = reinterpret_cast<mavsdk::Camera::PossibleSettingOptionsHandle*>(handle);

        {
            std::lock_guard<std::mutex> lock(wrapper->handles_mutex);
            auto& vec = wrapper->possible_setting_options_handles;
            vec.erase(std::remove(vec.begin(), vec.end(), cpp_handle), vec.end());
        }

        wrapper->cpp_plugin->unsubscribe_possible_setting_options(std::move(*cpp_handle));
        delete cpp_handle;
    }
}



// GetPossibleSettingOptions sync
mavsdk_camera_result_t
mavsdk_camera_get_possible_setting_options(
    mavsdk_camera_t camera,
    int32_t component_id,
    mavsdk_camera_setting_options_t** setting_options_out,
    size_t* setting_options_size_out)
{
    auto wrapper = reinterpret_cast<mavsdk_camera_wrapper*>(camera);

    auto result_pair = wrapper->cpp_plugin->get_possible_setting_options(
        component_id);

    if (setting_options_out != nullptr) {
        size_t count = result_pair.second.size();

        *setting_options_out = new mavsdk_camera_setting_options_t[count];

        for (size_t i = 0; i < count; i++) {
            (*setting_options_out)[i] = translate_setting_options_to_c(result_pair.second[i]);
        }

        if (setting_options_size_out != nullptr) {
            *setting_options_size_out = count;
        }
    }

    return translate_result(result_pair.first);
}

// SetSetting async
void mavsdk_camera_set_setting_async(
    mavsdk_camera_t camera,
    int32_t component_id,
    mavsdk_camera_setting_t setting,
    mavsdk_camera_set_setting_callback_t callback,
    void* user_data)
{
    auto wrapper = reinterpret_cast<mavsdk_camera_wrapper*>(camera);

    wrapper->cpp_plugin->set_setting_async(
        component_id,
        translate_setting_from_c(setting),
        [callback, user_data](
            mavsdk::Camera::Result result) {
                if (callback) {
                    callback(
                        translate_result(result),
                        user_data);
                }
        });
}


// SetSetting sync
mavsdk_camera_result_t
mavsdk_camera_set_setting(
    mavsdk_camera_t camera,
    int32_t component_id,
    mavsdk_camera_setting_t setting)
{
    auto wrapper = reinterpret_cast<mavsdk_camera_wrapper*>(camera);

    auto ret_value = wrapper->cpp_plugin->set_setting(        component_id,        translate_setting_from_c(setting));

    return translate_result(ret_value);
}

// GetSetting async
void mavsdk_camera_get_setting_async(
    mavsdk_camera_t camera,
    int32_t component_id,
    mavsdk_camera_setting_t setting,
    mavsdk_camera_get_setting_callback_t callback,
    void* user_data)
{
    auto wrapper = reinterpret_cast<mavsdk_camera_wrapper*>(camera);

    wrapper->cpp_plugin->get_setting_async(
        component_id,
        translate_setting_from_c(setting),
        [callback, user_data](
            mavsdk::Camera::Result result,
            mavsdk::Camera::Setting value) {
                if (callback) {
                    callback(
                        translate_result(result),
                        translate_setting_to_c(value),
                        user_data);
                }
        });
}


// GetSetting sync
mavsdk_camera_result_t
mavsdk_camera_get_setting(
    mavsdk_camera_t camera,
    int32_t component_id,
    mavsdk_camera_setting_t setting,
    mavsdk_camera_setting_t* setting_out)
{
    auto wrapper = reinterpret_cast<mavsdk_camera_wrapper*>(camera);

    auto result_pair = wrapper->cpp_plugin->get_setting(
        component_id,
        translate_setting_from_c(setting));

    if (setting_out != nullptr) {
        *setting_out = translate_setting_to_c(result_pair.second);
    }

    return translate_result(result_pair.first);
}

// FormatStorage async
void mavsdk_camera_format_storage_async(
    mavsdk_camera_t camera,
    int32_t component_id,
    int32_t storage_id,
    mavsdk_camera_format_storage_callback_t callback,
    void* user_data)
{
    auto wrapper = reinterpret_cast<mavsdk_camera_wrapper*>(camera);

    wrapper->cpp_plugin->format_storage_async(
        component_id,
        storage_id,
        [callback, user_data](
            mavsdk::Camera::Result result) {
                if (callback) {
                    callback(
                        translate_result(result),
                        user_data);
                }
        });
}


// FormatStorage sync
mavsdk_camera_result_t
mavsdk_camera_format_storage(
    mavsdk_camera_t camera,
    int32_t component_id,
    int32_t storage_id)
{
    auto wrapper = reinterpret_cast<mavsdk_camera_wrapper*>(camera);

    auto ret_value = wrapper->cpp_plugin->format_storage(        component_id,        storage_id);

    return translate_result(ret_value);
}

// ResetSettings async
void mavsdk_camera_reset_settings_async(
    mavsdk_camera_t camera,
    int32_t component_id,
    mavsdk_camera_reset_settings_callback_t callback,
    void* user_data)
{
    auto wrapper = reinterpret_cast<mavsdk_camera_wrapper*>(camera);

    wrapper->cpp_plugin->reset_settings_async(
        component_id,
        [callback, user_data](
            mavsdk::Camera::Result result) {
                if (callback) {
                    callback(
                        translate_result(result),
                        user_data);
                }
        });
}


// ResetSettings sync
mavsdk_camera_result_t
mavsdk_camera_reset_settings(
    mavsdk_camera_t camera,
    int32_t component_id)
{
    auto wrapper = reinterpret_cast<mavsdk_camera_wrapper*>(camera);

    auto ret_value = wrapper->cpp_plugin->reset_settings(        component_id);

    return translate_result(ret_value);
}

// ZoomInStart async
void mavsdk_camera_zoom_in_start_async(
    mavsdk_camera_t camera,
    int32_t component_id,
    mavsdk_camera_zoom_in_start_callback_t callback,
    void* user_data)
{
    auto wrapper = reinterpret_cast<mavsdk_camera_wrapper*>(camera);

    wrapper->cpp_plugin->zoom_in_start_async(
        component_id,
        [callback, user_data](
            mavsdk::Camera::Result result) {
                if (callback) {
                    callback(
                        translate_result(result),
                        user_data);
                }
        });
}


// ZoomInStart sync
mavsdk_camera_result_t
mavsdk_camera_zoom_in_start(
    mavsdk_camera_t camera,
    int32_t component_id)
{
    auto wrapper = reinterpret_cast<mavsdk_camera_wrapper*>(camera);

    auto ret_value = wrapper->cpp_plugin->zoom_in_start(        component_id);

    return translate_result(ret_value);
}

// ZoomOutStart async
void mavsdk_camera_zoom_out_start_async(
    mavsdk_camera_t camera,
    int32_t component_id,
    mavsdk_camera_zoom_out_start_callback_t callback,
    void* user_data)
{
    auto wrapper = reinterpret_cast<mavsdk_camera_wrapper*>(camera);

    wrapper->cpp_plugin->zoom_out_start_async(
        component_id,
        [callback, user_data](
            mavsdk::Camera::Result result) {
                if (callback) {
                    callback(
                        translate_result(result),
                        user_data);
                }
        });
}


// ZoomOutStart sync
mavsdk_camera_result_t
mavsdk_camera_zoom_out_start(
    mavsdk_camera_t camera,
    int32_t component_id)
{
    auto wrapper = reinterpret_cast<mavsdk_camera_wrapper*>(camera);

    auto ret_value = wrapper->cpp_plugin->zoom_out_start(        component_id);

    return translate_result(ret_value);
}

// ZoomStop async
void mavsdk_camera_zoom_stop_async(
    mavsdk_camera_t camera,
    int32_t component_id,
    mavsdk_camera_zoom_stop_callback_t callback,
    void* user_data)
{
    auto wrapper = reinterpret_cast<mavsdk_camera_wrapper*>(camera);

    wrapper->cpp_plugin->zoom_stop_async(
        component_id,
        [callback, user_data](
            mavsdk::Camera::Result result) {
                if (callback) {
                    callback(
                        translate_result(result),
                        user_data);
                }
        });
}


// ZoomStop sync
mavsdk_camera_result_t
mavsdk_camera_zoom_stop(
    mavsdk_camera_t camera,
    int32_t component_id)
{
    auto wrapper = reinterpret_cast<mavsdk_camera_wrapper*>(camera);

    auto ret_value = wrapper->cpp_plugin->zoom_stop(        component_id);

    return translate_result(ret_value);
}

// ZoomRange async
void mavsdk_camera_zoom_range_async(
    mavsdk_camera_t camera,
    int32_t component_id,
    float range,
    mavsdk_camera_zoom_range_callback_t callback,
    void* user_data)
{
    auto wrapper = reinterpret_cast<mavsdk_camera_wrapper*>(camera);

    wrapper->cpp_plugin->zoom_range_async(
        component_id,
        range,
        [callback, user_data](
            mavsdk::Camera::Result result) {
                if (callback) {
                    callback(
                        translate_result(result),
                        user_data);
                }
        });
}


// ZoomRange sync
mavsdk_camera_result_t
mavsdk_camera_zoom_range(
    mavsdk_camera_t camera,
    int32_t component_id,
    float range)
{
    auto wrapper = reinterpret_cast<mavsdk_camera_wrapper*>(camera);

    auto ret_value = wrapper->cpp_plugin->zoom_range(        component_id,        range);

    return translate_result(ret_value);
}

// TrackPoint async
void mavsdk_camera_track_point_async(
    mavsdk_camera_t camera,
    int32_t component_id,
    float point_x,
    float point_y,
    float radius,
    mavsdk_camera_track_point_callback_t callback,
    void* user_data)
{
    auto wrapper = reinterpret_cast<mavsdk_camera_wrapper*>(camera);

    wrapper->cpp_plugin->track_point_async(
        component_id,
        point_x,
        point_y,
        radius,
        [callback, user_data](
            mavsdk::Camera::Result result) {
                if (callback) {
                    callback(
                        translate_result(result),
                        user_data);
                }
        });
}


// TrackPoint sync
mavsdk_camera_result_t
mavsdk_camera_track_point(
    mavsdk_camera_t camera,
    int32_t component_id,
    float point_x,
    float point_y,
    float radius)
{
    auto wrapper = reinterpret_cast<mavsdk_camera_wrapper*>(camera);

    auto ret_value = wrapper->cpp_plugin->track_point(        component_id,        point_x,        point_y,        radius);

    return translate_result(ret_value);
}

// TrackRectangle async
void mavsdk_camera_track_rectangle_async(
    mavsdk_camera_t camera,
    int32_t component_id,
    float top_left_x,
    float top_left_y,
    float bottom_right_x,
    float bottom_right_y,
    mavsdk_camera_track_rectangle_callback_t callback,
    void* user_data)
{
    auto wrapper = reinterpret_cast<mavsdk_camera_wrapper*>(camera);

    wrapper->cpp_plugin->track_rectangle_async(
        component_id,
        top_left_x,
        top_left_y,
        bottom_right_x,
        bottom_right_y,
        [callback, user_data](
            mavsdk::Camera::Result result) {
                if (callback) {
                    callback(
                        translate_result(result),
                        user_data);
                }
        });
}


// TrackRectangle sync
mavsdk_camera_result_t
mavsdk_camera_track_rectangle(
    mavsdk_camera_t camera,
    int32_t component_id,
    float top_left_x,
    float top_left_y,
    float bottom_right_x,
    float bottom_right_y)
{
    auto wrapper = reinterpret_cast<mavsdk_camera_wrapper*>(camera);

    auto ret_value = wrapper->cpp_plugin->track_rectangle(        component_id,        top_left_x,        top_left_y,        bottom_right_x,        bottom_right_y);

    return translate_result(ret_value);
}

// TrackStop async
void mavsdk_camera_track_stop_async(
    mavsdk_camera_t camera,
    int32_t component_id,
    mavsdk_camera_track_stop_callback_t callback,
    void* user_data)
{
    auto wrapper = reinterpret_cast<mavsdk_camera_wrapper*>(camera);

    wrapper->cpp_plugin->track_stop_async(
        component_id,
        [callback, user_data](
            mavsdk::Camera::Result result) {
                if (callback) {
                    callback(
                        translate_result(result),
                        user_data);
                }
        });
}


// TrackStop sync
mavsdk_camera_result_t
mavsdk_camera_track_stop(
    mavsdk_camera_t camera,
    int32_t component_id)
{
    auto wrapper = reinterpret_cast<mavsdk_camera_wrapper*>(camera);

    auto ret_value = wrapper->cpp_plugin->track_stop(        component_id);

    return translate_result(ret_value);
}

// FocusInStart async
void mavsdk_camera_focus_in_start_async(
    mavsdk_camera_t camera,
    int32_t component_id,
    mavsdk_camera_focus_in_start_callback_t callback,
    void* user_data)
{
    auto wrapper = reinterpret_cast<mavsdk_camera_wrapper*>(camera);

    wrapper->cpp_plugin->focus_in_start_async(
        component_id,
        [callback, user_data](
            mavsdk::Camera::Result result) {
                if (callback) {
                    callback(
                        translate_result(result),
                        user_data);
                }
        });
}


// FocusInStart sync
mavsdk_camera_result_t
mavsdk_camera_focus_in_start(
    mavsdk_camera_t camera,
    int32_t component_id)
{
    auto wrapper = reinterpret_cast<mavsdk_camera_wrapper*>(camera);

    auto ret_value = wrapper->cpp_plugin->focus_in_start(        component_id);

    return translate_result(ret_value);
}

// FocusOutStart async
void mavsdk_camera_focus_out_start_async(
    mavsdk_camera_t camera,
    int32_t component_id,
    mavsdk_camera_focus_out_start_callback_t callback,
    void* user_data)
{
    auto wrapper = reinterpret_cast<mavsdk_camera_wrapper*>(camera);

    wrapper->cpp_plugin->focus_out_start_async(
        component_id,
        [callback, user_data](
            mavsdk::Camera::Result result) {
                if (callback) {
                    callback(
                        translate_result(result),
                        user_data);
                }
        });
}


// FocusOutStart sync
mavsdk_camera_result_t
mavsdk_camera_focus_out_start(
    mavsdk_camera_t camera,
    int32_t component_id)
{
    auto wrapper = reinterpret_cast<mavsdk_camera_wrapper*>(camera);

    auto ret_value = wrapper->cpp_plugin->focus_out_start(        component_id);

    return translate_result(ret_value);
}

// FocusStop async
void mavsdk_camera_focus_stop_async(
    mavsdk_camera_t camera,
    int32_t component_id,
    mavsdk_camera_focus_stop_callback_t callback,
    void* user_data)
{
    auto wrapper = reinterpret_cast<mavsdk_camera_wrapper*>(camera);

    wrapper->cpp_plugin->focus_stop_async(
        component_id,
        [callback, user_data](
            mavsdk::Camera::Result result) {
                if (callback) {
                    callback(
                        translate_result(result),
                        user_data);
                }
        });
}


// FocusStop sync
mavsdk_camera_result_t
mavsdk_camera_focus_stop(
    mavsdk_camera_t camera,
    int32_t component_id)
{
    auto wrapper = reinterpret_cast<mavsdk_camera_wrapper*>(camera);

    auto ret_value = wrapper->cpp_plugin->focus_stop(        component_id);

    return translate_result(ret_value);
}

// FocusRange async
void mavsdk_camera_focus_range_async(
    mavsdk_camera_t camera,
    int32_t component_id,
    float range,
    mavsdk_camera_focus_range_callback_t callback,
    void* user_data)
{
    auto wrapper = reinterpret_cast<mavsdk_camera_wrapper*>(camera);

    wrapper->cpp_plugin->focus_range_async(
        component_id,
        range,
        [callback, user_data](
            mavsdk::Camera::Result result) {
                if (callback) {
                    callback(
                        translate_result(result),
                        user_data);
                }
        });
}


// FocusRange sync
mavsdk_camera_result_t
mavsdk_camera_focus_range(
    mavsdk_camera_t camera,
    int32_t component_id,
    float range)
{
    auto wrapper = reinterpret_cast<mavsdk_camera_wrapper*>(camera);

    auto ret_value = wrapper->cpp_plugin->focus_range(        component_id,        range);

    return translate_result(ret_value);
}
