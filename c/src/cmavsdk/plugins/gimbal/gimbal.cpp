// WARNING: THIS FILE IS AUTOGENERATED! As such, it should not be edited.
// Edits need to be made to the proto files
// (see https://github.com/mavlink/MAVSDK-Proto/blob/main/protos/gimbal/gimbal.proto)

#include "gimbal.h"

#include <mavsdk/plugins/gimbal/gimbal.h>
#include <algorithm>
#include <cstring>
#include <mutex>
#include <vector>

// ===== C++ to C Type Conversions =====

static mavsdk_gimbal_result_t
translate_result(mavsdk::Gimbal::Result cpp_result) {
    switch(cpp_result) {
        case mavsdk::Gimbal::Result::Unknown:
            return MAVSDK_GIMBAL_RESULT_UNKNOWN;
        case mavsdk::Gimbal::Result::Success:
            return MAVSDK_GIMBAL_RESULT_SUCCESS;
        case mavsdk::Gimbal::Result::Error:
            return MAVSDK_GIMBAL_RESULT_ERROR;
        case mavsdk::Gimbal::Result::Timeout:
            return MAVSDK_GIMBAL_RESULT_TIMEOUT;
        case mavsdk::Gimbal::Result::Unsupported:
            return MAVSDK_GIMBAL_RESULT_UNSUPPORTED;
        case mavsdk::Gimbal::Result::NoSystem:
            return MAVSDK_GIMBAL_RESULT_NO_SYSTEM;
        case mavsdk::Gimbal::Result::InvalidArgument:
            return MAVSDK_GIMBAL_RESULT_INVALID_ARGUMENT;
    }
}

static mavsdk::Gimbal::GimbalMode
translate_gimbal_mode_from_c(mavsdk_gimbal_gimbal_mode_t c_enum) {
    switch(c_enum) {
        case MAVSDK_GIMBAL_GIMBAL_MODE_YAW_FOLLOW:
            return mavsdk::Gimbal::GimbalMode::YawFollow;
        case MAVSDK_GIMBAL_GIMBAL_MODE_YAW_LOCK:
            return mavsdk::Gimbal::GimbalMode::YawLock;
    }
    return mavsdk::Gimbal::GimbalMode::YawFollow;
}

static mavsdk_gimbal_gimbal_mode_t
translate_gimbal_mode_to_c(mavsdk::Gimbal::GimbalMode cpp_enum) {
    switch(cpp_enum) {
        case mavsdk::Gimbal::GimbalMode::YawFollow:
            return MAVSDK_GIMBAL_GIMBAL_MODE_YAW_FOLLOW;
        case mavsdk::Gimbal::GimbalMode::YawLock:
            return MAVSDK_GIMBAL_GIMBAL_MODE_YAW_LOCK;
    }
    return MAVSDK_GIMBAL_GIMBAL_MODE_YAW_FOLLOW;
}

static mavsdk::Gimbal::ControlMode
translate_control_mode_from_c(mavsdk_gimbal_control_mode_t c_enum) {
    switch(c_enum) {
        case MAVSDK_GIMBAL_CONTROL_MODE_NONE:
            return mavsdk::Gimbal::ControlMode::None;
        case MAVSDK_GIMBAL_CONTROL_MODE_PRIMARY:
            return mavsdk::Gimbal::ControlMode::Primary;
        case MAVSDK_GIMBAL_CONTROL_MODE_SECONDARY:
            return mavsdk::Gimbal::ControlMode::Secondary;
    }
    return mavsdk::Gimbal::ControlMode::None;
}

static mavsdk_gimbal_control_mode_t
translate_control_mode_to_c(mavsdk::Gimbal::ControlMode cpp_enum) {
    switch(cpp_enum) {
        case mavsdk::Gimbal::ControlMode::None:
            return MAVSDK_GIMBAL_CONTROL_MODE_NONE;
        case mavsdk::Gimbal::ControlMode::Primary:
            return MAVSDK_GIMBAL_CONTROL_MODE_PRIMARY;
        case mavsdk::Gimbal::ControlMode::Secondary:
            return MAVSDK_GIMBAL_CONTROL_MODE_SECONDARY;
    }
    return MAVSDK_GIMBAL_CONTROL_MODE_NONE;
}

static mavsdk::Gimbal::SendMode
translate_send_mode_from_c(mavsdk_gimbal_send_mode_t c_enum) {
    switch(c_enum) {
        case MAVSDK_GIMBAL_SEND_MODE_ONCE:
            return mavsdk::Gimbal::SendMode::Once;
        case MAVSDK_GIMBAL_SEND_MODE_STREAM:
            return mavsdk::Gimbal::SendMode::Stream;
    }
    return mavsdk::Gimbal::SendMode::Once;
}

static mavsdk_gimbal_send_mode_t
translate_send_mode_to_c(mavsdk::Gimbal::SendMode cpp_enum) {
    switch(cpp_enum) {
        case mavsdk::Gimbal::SendMode::Once:
            return MAVSDK_GIMBAL_SEND_MODE_ONCE;
        case mavsdk::Gimbal::SendMode::Stream:
            return MAVSDK_GIMBAL_SEND_MODE_STREAM;
    }
    return MAVSDK_GIMBAL_SEND_MODE_ONCE;
}



static mavsdk::Gimbal::Quaternion
translate_quaternion_from_c(const mavsdk_gimbal_quaternion_t& c_struct) {
    mavsdk::Gimbal::Quaternion cpp_struct{};
    cpp_struct.w = c_struct.w;
    cpp_struct.x = c_struct.x;
    cpp_struct.y = c_struct.y;
    cpp_struct.z = c_struct.z;
    return cpp_struct;
}

static mavsdk_gimbal_quaternion_t
translate_quaternion_to_c(const mavsdk::Gimbal::Quaternion& cpp_struct) {
    mavsdk_gimbal_quaternion_t c_struct{};
    c_struct.w = cpp_struct.w;
    c_struct.x = cpp_struct.x;
    c_struct.y = cpp_struct.y;
    c_struct.z = cpp_struct.z;
    return c_struct;
}

void mavsdk_gimbal_quaternion_destroy(
    mavsdk_gimbal_quaternion_t* target) {
    if (!target) return;
}

void mavsdk_gimbal_quaternion_array_destroy(
    mavsdk_gimbal_quaternion_t** array,
    size_t size) {
    if (!array || !*array) return;

    for (size_t i = 0; i < size; i++) {
        mavsdk_gimbal_quaternion_destroy(&(*array)[i]);
    }

    delete[] *array;
    *array = nullptr;
}


static mavsdk::Gimbal::EulerAngle
translate_euler_angle_from_c(const mavsdk_gimbal_euler_angle_t& c_struct) {
    mavsdk::Gimbal::EulerAngle cpp_struct{};
    cpp_struct.roll_deg = c_struct.roll_deg;
    cpp_struct.pitch_deg = c_struct.pitch_deg;
    cpp_struct.yaw_deg = c_struct.yaw_deg;
    return cpp_struct;
}

static mavsdk_gimbal_euler_angle_t
translate_euler_angle_to_c(const mavsdk::Gimbal::EulerAngle& cpp_struct) {
    mavsdk_gimbal_euler_angle_t c_struct{};
    c_struct.roll_deg = cpp_struct.roll_deg;
    c_struct.pitch_deg = cpp_struct.pitch_deg;
    c_struct.yaw_deg = cpp_struct.yaw_deg;
    return c_struct;
}

void mavsdk_gimbal_euler_angle_destroy(
    mavsdk_gimbal_euler_angle_t* target) {
    if (!target) return;
}

void mavsdk_gimbal_euler_angle_array_destroy(
    mavsdk_gimbal_euler_angle_t** array,
    size_t size) {
    if (!array || !*array) return;

    for (size_t i = 0; i < size; i++) {
        mavsdk_gimbal_euler_angle_destroy(&(*array)[i]);
    }

    delete[] *array;
    *array = nullptr;
}


static mavsdk::Gimbal::AngularVelocityBody
translate_angular_velocity_body_from_c(const mavsdk_gimbal_angular_velocity_body_t& c_struct) {
    mavsdk::Gimbal::AngularVelocityBody cpp_struct{};
    cpp_struct.roll_rad_s = c_struct.roll_rad_s;
    cpp_struct.pitch_rad_s = c_struct.pitch_rad_s;
    cpp_struct.yaw_rad_s = c_struct.yaw_rad_s;
    return cpp_struct;
}

static mavsdk_gimbal_angular_velocity_body_t
translate_angular_velocity_body_to_c(const mavsdk::Gimbal::AngularVelocityBody& cpp_struct) {
    mavsdk_gimbal_angular_velocity_body_t c_struct{};
    c_struct.roll_rad_s = cpp_struct.roll_rad_s;
    c_struct.pitch_rad_s = cpp_struct.pitch_rad_s;
    c_struct.yaw_rad_s = cpp_struct.yaw_rad_s;
    return c_struct;
}

void mavsdk_gimbal_angular_velocity_body_destroy(
    mavsdk_gimbal_angular_velocity_body_t* target) {
    if (!target) return;
}

void mavsdk_gimbal_angular_velocity_body_array_destroy(
    mavsdk_gimbal_angular_velocity_body_t** array,
    size_t size) {
    if (!array || !*array) return;

    for (size_t i = 0; i < size; i++) {
        mavsdk_gimbal_angular_velocity_body_destroy(&(*array)[i]);
    }

    delete[] *array;
    *array = nullptr;
}


static mavsdk::Gimbal::Attitude
translate_attitude_from_c(const mavsdk_gimbal_attitude_t& c_struct) {
    mavsdk::Gimbal::Attitude cpp_struct{};
    cpp_struct.gimbal_id = c_struct.gimbal_id;
    cpp_struct.euler_angle_forward = translate_euler_angle_from_c(c_struct.euler_angle_forward);
    cpp_struct.quaternion_forward = translate_quaternion_from_c(c_struct.quaternion_forward);
    cpp_struct.euler_angle_north = translate_euler_angle_from_c(c_struct.euler_angle_north);
    cpp_struct.quaternion_north = translate_quaternion_from_c(c_struct.quaternion_north);
    cpp_struct.angular_velocity = translate_angular_velocity_body_from_c(c_struct.angular_velocity);
    cpp_struct.timestamp_us = c_struct.timestamp_us;
    return cpp_struct;
}

static mavsdk_gimbal_attitude_t
translate_attitude_to_c(const mavsdk::Gimbal::Attitude& cpp_struct) {
    mavsdk_gimbal_attitude_t c_struct{};
    c_struct.gimbal_id = cpp_struct.gimbal_id;
    c_struct.euler_angle_forward = translate_euler_angle_to_c(cpp_struct.euler_angle_forward);
    c_struct.quaternion_forward = translate_quaternion_to_c(cpp_struct.quaternion_forward);
    c_struct.euler_angle_north = translate_euler_angle_to_c(cpp_struct.euler_angle_north);
    c_struct.quaternion_north = translate_quaternion_to_c(cpp_struct.quaternion_north);
    c_struct.angular_velocity = translate_angular_velocity_body_to_c(cpp_struct.angular_velocity);
    c_struct.timestamp_us = cpp_struct.timestamp_us;
    return c_struct;
}

void mavsdk_gimbal_attitude_destroy(
    mavsdk_gimbal_attitude_t* target) {
    if (!target) return;
}

void mavsdk_gimbal_attitude_array_destroy(
    mavsdk_gimbal_attitude_t** array,
    size_t size) {
    if (!array || !*array) return;

    for (size_t i = 0; i < size; i++) {
        mavsdk_gimbal_attitude_destroy(&(*array)[i]);
    }

    delete[] *array;
    *array = nullptr;
}


static mavsdk::Gimbal::GimbalItem
translate_gimbal_item_from_c(const mavsdk_gimbal_gimbal_item_t& c_struct) {
    mavsdk::Gimbal::GimbalItem cpp_struct{};
    cpp_struct.gimbal_id = c_struct.gimbal_id;
    if (c_struct.vendor_name) {
        cpp_struct.vendor_name = c_struct.vendor_name;
    }
    if (c_struct.model_name) {
        cpp_struct.model_name = c_struct.model_name;
    }
    if (c_struct.custom_name) {
        cpp_struct.custom_name = c_struct.custom_name;
    }
    cpp_struct.gimbal_manager_component_id = c_struct.gimbal_manager_component_id;
    cpp_struct.gimbal_device_id = c_struct.gimbal_device_id;
    return cpp_struct;
}

static mavsdk_gimbal_gimbal_item_t
translate_gimbal_item_to_c(const mavsdk::Gimbal::GimbalItem& cpp_struct) {
    mavsdk_gimbal_gimbal_item_t c_struct{};
    c_struct.gimbal_id = cpp_struct.gimbal_id;
    c_struct.vendor_name = strdup(cpp_struct.vendor_name.c_str());
    c_struct.model_name = strdup(cpp_struct.model_name.c_str());
    c_struct.custom_name = strdup(cpp_struct.custom_name.c_str());
    c_struct.gimbal_manager_component_id = cpp_struct.gimbal_manager_component_id;
    c_struct.gimbal_device_id = cpp_struct.gimbal_device_id;
    return c_struct;
}

void mavsdk_gimbal_gimbal_item_destroy(
    mavsdk_gimbal_gimbal_item_t* target) {
    if (!target) return;
    if (target->vendor_name) {
        free((void*)target->vendor_name);
        target->vendor_name = nullptr;
    }
    if (target->model_name) {
        free((void*)target->model_name);
        target->model_name = nullptr;
    }
    if (target->custom_name) {
        free((void*)target->custom_name);
        target->custom_name = nullptr;
    }
}

void mavsdk_gimbal_gimbal_item_array_destroy(
    mavsdk_gimbal_gimbal_item_t** array,
    size_t size) {
    if (!array || !*array) return;

    for (size_t i = 0; i < size; i++) {
        mavsdk_gimbal_gimbal_item_destroy(&(*array)[i]);
    }

    delete[] *array;
    *array = nullptr;
}


static mavsdk::Gimbal::GimbalList
translate_gimbal_list_from_c(const mavsdk_gimbal_gimbal_list_t& c_struct) {
    mavsdk::Gimbal::GimbalList cpp_struct{};
    cpp_struct.gimbals.reserve(c_struct.gimbals_size);
    for (size_t i = 0; i < c_struct.gimbals_size; i++) {
        cpp_struct.gimbals.push_back(
            translate_gimbal_item_from_c(c_struct.gimbals[i]));
    }
    return cpp_struct;
}

static mavsdk_gimbal_gimbal_list_t
translate_gimbal_list_to_c(const mavsdk::Gimbal::GimbalList& cpp_struct) {
    mavsdk_gimbal_gimbal_list_t c_struct{};
    c_struct.gimbals_size = cpp_struct.gimbals.size();
    c_struct.gimbals = new mavsdk_gimbal_gimbal_item_t[c_struct.gimbals_size];
    for (size_t i = 0; i < c_struct.gimbals_size; i++) {
        c_struct.gimbals[i] = translate_gimbal_item_to_c(cpp_struct.gimbals[i]);
    }
    return c_struct;
}

void mavsdk_gimbal_gimbal_list_destroy(
    mavsdk_gimbal_gimbal_list_t* target) {
    if (!target) return;
    if (target->gimbals) {
        for (size_t i = 0; i < target->gimbals_size; i++) {
            mavsdk_gimbal_gimbal_item_destroy(&target->gimbals[i]);
        }
        delete[] target->gimbals;
        target->gimbals = nullptr;
        target->gimbals_size = 0;
    }
}

void mavsdk_gimbal_gimbal_list_array_destroy(
    mavsdk_gimbal_gimbal_list_t** array,
    size_t size) {
    if (!array || !*array) return;

    for (size_t i = 0; i < size; i++) {
        mavsdk_gimbal_gimbal_list_destroy(&(*array)[i]);
    }

    delete[] *array;
    *array = nullptr;
}


static mavsdk::Gimbal::ControlStatus
translate_control_status_from_c(const mavsdk_gimbal_control_status_t& c_struct) {
    mavsdk::Gimbal::ControlStatus cpp_struct{};
    cpp_struct.gimbal_id = c_struct.gimbal_id;
    cpp_struct.control_mode = translate_control_mode_from_c(c_struct.control_mode);
    cpp_struct.sysid_primary_control = c_struct.sysid_primary_control;
    cpp_struct.compid_primary_control = c_struct.compid_primary_control;
    cpp_struct.sysid_secondary_control = c_struct.sysid_secondary_control;
    cpp_struct.compid_secondary_control = c_struct.compid_secondary_control;
    return cpp_struct;
}

static mavsdk_gimbal_control_status_t
translate_control_status_to_c(const mavsdk::Gimbal::ControlStatus& cpp_struct) {
    mavsdk_gimbal_control_status_t c_struct{};
    c_struct.gimbal_id = cpp_struct.gimbal_id;
    c_struct.control_mode = translate_control_mode_to_c(cpp_struct.control_mode);
    c_struct.sysid_primary_control = cpp_struct.sysid_primary_control;
    c_struct.compid_primary_control = cpp_struct.compid_primary_control;
    c_struct.sysid_secondary_control = cpp_struct.sysid_secondary_control;
    c_struct.compid_secondary_control = cpp_struct.compid_secondary_control;
    return c_struct;
}

void mavsdk_gimbal_control_status_destroy(
    mavsdk_gimbal_control_status_t* target) {
    if (!target) return;
}

void mavsdk_gimbal_control_status_array_destroy(
    mavsdk_gimbal_control_status_t** array,
    size_t size) {
    if (!array || !*array) return;

    for (size_t i = 0; i < size; i++) {
        mavsdk_gimbal_control_status_destroy(&(*array)[i]);
    }

    delete[] *array;
    *array = nullptr;
}



// ===== Primitive Array Destroy Functions =====
void mavsdk_gimbal_float_array_destroy(float** array) {
    if (!array || !*array) return;
    delete[] *array;
    *array = nullptr;
}

void mavsdk_gimbal_double_array_destroy(double** array) {
    if (!array || !*array) return;
    delete[] *array;
    *array = nullptr;
}

void mavsdk_gimbal_int32t_array_destroy(int32_t** array) {
    if (!array || !*array) return;
    delete[] *array;
    *array = nullptr;
}

void mavsdk_gimbal_uint32t_array_destroy(uint32_t** array) {
    if (!array || !*array) return;
    delete[] *array;
    *array = nullptr;
}

void mavsdk_gimbal_int64t_array_destroy(int64_t** array) {
    if (!array || !*array) return;
    delete[] *array;
    *array = nullptr;
}

void mavsdk_gimbal_uint64t_array_destroy(uint64_t** array) {
    if (!array || !*array) return;
    delete[] *array;
    *array = nullptr;
}

void mavsdk_gimbal_bool_array_destroy(bool** array) {
    if (!array || !*array) return;
    delete[] *array;
    *array = nullptr;
}


void mavsdk_gimbal_string_destroy(char** str) {
    if (!str || !*str) return;
    free(*str);
    *str = nullptr;
}

void mavsdk_gimbal_byte_buffer_destroy(uint8_t** buffer) {
    if (!buffer || !*buffer) return;
    delete[] *buffer;
    *buffer = nullptr;
}

// ===== Gimbal Wrapper =====

struct mavsdk_gimbal_wrapper {
    std::shared_ptr<mavsdk::Gimbal> cpp_plugin;
    std::mutex handles_mutex;
    std::vector<mavsdk::Gimbal::GimbalListHandle*> gimbal_list_handles;
    std::vector<mavsdk::Gimbal::ControlStatusHandle*> control_status_handles;
    std::vector<mavsdk::Gimbal::AttitudeHandle*> attitude_handles;
};

mavsdk_gimbal_t
mavsdk_gimbal_create(mavsdk_system_t system) {
    if (system == nullptr) {
        return nullptr;
    }

    auto wrapper = new mavsdk_gimbal_wrapper();
    auto system_ptr = reinterpret_cast<std::shared_ptr<mavsdk::System>*>(system);
    wrapper->cpp_plugin = std::make_shared<mavsdk::Gimbal>(*system_ptr);

    return reinterpret_cast<mavsdk_gimbal_t>(wrapper);
}

void mavsdk_gimbal_destroy(mavsdk_gimbal_t gimbal) {
    if (gimbal == nullptr) {
        return;
    }

    auto wrapper = reinterpret_cast<mavsdk_gimbal_wrapper*>(gimbal);

    // Unsubscribe all active streams before destroying to prevent
    // callbacks firing into a destroyed object
    {
        std::lock_guard<std::mutex> lock(wrapper->handles_mutex);
        for (auto* h : wrapper->gimbal_list_handles) {
            wrapper->cpp_plugin->unsubscribe_gimbal_list(std::move(*h));
            delete h;
        }
        wrapper->gimbal_list_handles.clear();
        for (auto* h : wrapper->control_status_handles) {
            wrapper->cpp_plugin->unsubscribe_control_status(std::move(*h));
            delete h;
        }
        wrapper->control_status_handles.clear();
        for (auto* h : wrapper->attitude_handles) {
            wrapper->cpp_plugin->unsubscribe_attitude(std::move(*h));
            delete h;
        }
        wrapper->attitude_handles.clear();
    }

    delete wrapper;
}

// ===== Method Implementations =====

// SetAngles async
void mavsdk_gimbal_set_angles_async(
    mavsdk_gimbal_t gimbal,
    int32_t gimbal_id,
    float roll_deg,
    float pitch_deg,
    float yaw_deg,
    mavsdk_gimbal_gimbal_mode_t gimbal_mode,
    mavsdk_gimbal_send_mode_t send_mode,
    mavsdk_gimbal_set_angles_callback_t callback,
    void* user_data)
{
    auto wrapper = reinterpret_cast<mavsdk_gimbal_wrapper*>(gimbal);

    wrapper->cpp_plugin->set_angles_async(
        gimbal_id,
        roll_deg,
        pitch_deg,
        yaw_deg,
        translate_gimbal_mode_from_c(gimbal_mode),        translate_send_mode_from_c(send_mode),
        [callback, user_data](
            mavsdk::Gimbal::Result result) {
                if (callback) {
                    callback(
                        translate_result(result),
                        user_data);
                }
        });
}


// SetAngles sync
mavsdk_gimbal_result_t
mavsdk_gimbal_set_angles(
    mavsdk_gimbal_t gimbal,
    int32_t gimbal_id,
    float roll_deg,
    float pitch_deg,
    float yaw_deg,
    mavsdk_gimbal_gimbal_mode_t gimbal_mode,
    mavsdk_gimbal_send_mode_t send_mode)
{
    auto wrapper = reinterpret_cast<mavsdk_gimbal_wrapper*>(gimbal);

    auto ret_value = wrapper->cpp_plugin->set_angles(        gimbal_id,        roll_deg,        pitch_deg,        yaw_deg,        translate_gimbal_mode_from_c(gimbal_mode),        translate_send_mode_from_c(send_mode));

    return translate_result(ret_value);
}

// SetAngularRates async
void mavsdk_gimbal_set_angular_rates_async(
    mavsdk_gimbal_t gimbal,
    int32_t gimbal_id,
    float roll_rate_deg_s,
    float pitch_rate_deg_s,
    float yaw_rate_deg_s,
    mavsdk_gimbal_gimbal_mode_t gimbal_mode,
    mavsdk_gimbal_send_mode_t send_mode,
    mavsdk_gimbal_set_angular_rates_callback_t callback,
    void* user_data)
{
    auto wrapper = reinterpret_cast<mavsdk_gimbal_wrapper*>(gimbal);

    wrapper->cpp_plugin->set_angular_rates_async(
        gimbal_id,
        roll_rate_deg_s,
        pitch_rate_deg_s,
        yaw_rate_deg_s,
        translate_gimbal_mode_from_c(gimbal_mode),        translate_send_mode_from_c(send_mode),
        [callback, user_data](
            mavsdk::Gimbal::Result result) {
                if (callback) {
                    callback(
                        translate_result(result),
                        user_data);
                }
        });
}


// SetAngularRates sync
mavsdk_gimbal_result_t
mavsdk_gimbal_set_angular_rates(
    mavsdk_gimbal_t gimbal,
    int32_t gimbal_id,
    float roll_rate_deg_s,
    float pitch_rate_deg_s,
    float yaw_rate_deg_s,
    mavsdk_gimbal_gimbal_mode_t gimbal_mode,
    mavsdk_gimbal_send_mode_t send_mode)
{
    auto wrapper = reinterpret_cast<mavsdk_gimbal_wrapper*>(gimbal);

    auto ret_value = wrapper->cpp_plugin->set_angular_rates(        gimbal_id,        roll_rate_deg_s,        pitch_rate_deg_s,        yaw_rate_deg_s,        translate_gimbal_mode_from_c(gimbal_mode),        translate_send_mode_from_c(send_mode));

    return translate_result(ret_value);
}

// SetRoiLocation async
void mavsdk_gimbal_set_roi_location_async(
    mavsdk_gimbal_t gimbal,
    int32_t gimbal_id,
    double latitude_deg,
    double longitude_deg,
    float altitude_m,
    mavsdk_gimbal_set_roi_location_callback_t callback,
    void* user_data)
{
    auto wrapper = reinterpret_cast<mavsdk_gimbal_wrapper*>(gimbal);

    wrapper->cpp_plugin->set_roi_location_async(
        gimbal_id,
        latitude_deg,
        longitude_deg,
        altitude_m,
        [callback, user_data](
            mavsdk::Gimbal::Result result) {
                if (callback) {
                    callback(
                        translate_result(result),
                        user_data);
                }
        });
}


// SetRoiLocation sync
mavsdk_gimbal_result_t
mavsdk_gimbal_set_roi_location(
    mavsdk_gimbal_t gimbal,
    int32_t gimbal_id,
    double latitude_deg,
    double longitude_deg,
    float altitude_m)
{
    auto wrapper = reinterpret_cast<mavsdk_gimbal_wrapper*>(gimbal);

    auto ret_value = wrapper->cpp_plugin->set_roi_location(        gimbal_id,        latitude_deg,        longitude_deg,        altitude_m);

    return translate_result(ret_value);
}

// TakeControl async
void mavsdk_gimbal_take_control_async(
    mavsdk_gimbal_t gimbal,
    int32_t gimbal_id,
    mavsdk_gimbal_control_mode_t control_mode,
    mavsdk_gimbal_take_control_callback_t callback,
    void* user_data)
{
    auto wrapper = reinterpret_cast<mavsdk_gimbal_wrapper*>(gimbal);

    wrapper->cpp_plugin->take_control_async(
        gimbal_id,
        translate_control_mode_from_c(control_mode),
        [callback, user_data](
            mavsdk::Gimbal::Result result) {
                if (callback) {
                    callback(
                        translate_result(result),
                        user_data);
                }
        });
}


// TakeControl sync
mavsdk_gimbal_result_t
mavsdk_gimbal_take_control(
    mavsdk_gimbal_t gimbal,
    int32_t gimbal_id,
    mavsdk_gimbal_control_mode_t control_mode)
{
    auto wrapper = reinterpret_cast<mavsdk_gimbal_wrapper*>(gimbal);

    auto ret_value = wrapper->cpp_plugin->take_control(        gimbal_id,        translate_control_mode_from_c(control_mode));

    return translate_result(ret_value);
}

// ReleaseControl async
void mavsdk_gimbal_release_control_async(
    mavsdk_gimbal_t gimbal,
    int32_t gimbal_id,
    mavsdk_gimbal_release_control_callback_t callback,
    void* user_data)
{
    auto wrapper = reinterpret_cast<mavsdk_gimbal_wrapper*>(gimbal);

    wrapper->cpp_plugin->release_control_async(
        gimbal_id,
        [callback, user_data](
            mavsdk::Gimbal::Result result) {
                if (callback) {
                    callback(
                        translate_result(result),
                        user_data);
                }
        });
}


// ReleaseControl sync
mavsdk_gimbal_result_t
mavsdk_gimbal_release_control(
    mavsdk_gimbal_t gimbal,
    int32_t gimbal_id)
{
    auto wrapper = reinterpret_cast<mavsdk_gimbal_wrapper*>(gimbal);

    auto ret_value = wrapper->cpp_plugin->release_control(        gimbal_id);

    return translate_result(ret_value);
}

// GimbalList async
mavsdk_gimbal_gimbal_list_handle_t mavsdk_gimbal_subscribe_gimbal_list(
    mavsdk_gimbal_t gimbal,
    mavsdk_gimbal_gimbal_list_callback_t callback,
    void* user_data)
{
    auto wrapper = reinterpret_cast<mavsdk_gimbal_wrapper*>(gimbal);

    auto cpp_handle =    wrapper->cpp_plugin->subscribe_gimbal_list(
        [callback, user_data](
            mavsdk::Gimbal::GimbalList value) {
                if (callback) {
                    callback(
                        translate_gimbal_list_to_c(value),
                        user_data);
                }
        });

    auto cpp_handle_ptr = new mavsdk::Gimbal::GimbalListHandle(std::move(cpp_handle));

    {
        std::lock_guard<std::mutex> lock(wrapper->handles_mutex);
        wrapper->gimbal_list_handles.push_back(cpp_handle_ptr);
    }

    return reinterpret_cast<mavsdk_gimbal_gimbal_list_handle_t>(cpp_handle_ptr);
}

void mavsdk_gimbal_unsubscribe_gimbal_list(
    mavsdk_gimbal_t gimbal,
    mavsdk_gimbal_gimbal_list_handle_t handle)
{
    if (handle) {
        auto wrapper = reinterpret_cast<mavsdk_gimbal_wrapper*>(gimbal);
        auto cpp_handle = reinterpret_cast<mavsdk::Gimbal::GimbalListHandle*>(handle);

        {
            std::lock_guard<std::mutex> lock(wrapper->handles_mutex);
            auto& vec = wrapper->gimbal_list_handles;
            vec.erase(std::remove(vec.begin(), vec.end(), cpp_handle), vec.end());
        }

        wrapper->cpp_plugin->unsubscribe_gimbal_list(std::move(*cpp_handle));
        delete cpp_handle;
    }
}

// GimbalList sync
void
mavsdk_gimbal_gimbal_list(
    mavsdk_gimbal_t gimbal,
    mavsdk_gimbal_gimbal_list_t* gimbal_list_out)
{
    auto wrapper = reinterpret_cast<mavsdk_gimbal_wrapper*>(gimbal);

    auto ret_value = wrapper->cpp_plugin->gimbal_list();

    if (gimbal_list_out != nullptr) {
        *gimbal_list_out = translate_gimbal_list_to_c(ret_value);
    }
}

// ControlStatus async
mavsdk_gimbal_control_status_handle_t mavsdk_gimbal_subscribe_control_status(
    mavsdk_gimbal_t gimbal,
    mavsdk_gimbal_control_status_callback_t callback,
    void* user_data)
{
    auto wrapper = reinterpret_cast<mavsdk_gimbal_wrapper*>(gimbal);

    auto cpp_handle =    wrapper->cpp_plugin->subscribe_control_status(
        [callback, user_data](
            mavsdk::Gimbal::ControlStatus value) {
                if (callback) {
                    callback(
                        translate_control_status_to_c(value),
                        user_data);
                }
        });

    auto cpp_handle_ptr = new mavsdk::Gimbal::ControlStatusHandle(std::move(cpp_handle));

    {
        std::lock_guard<std::mutex> lock(wrapper->handles_mutex);
        wrapper->control_status_handles.push_back(cpp_handle_ptr);
    }

    return reinterpret_cast<mavsdk_gimbal_control_status_handle_t>(cpp_handle_ptr);
}

void mavsdk_gimbal_unsubscribe_control_status(
    mavsdk_gimbal_t gimbal,
    mavsdk_gimbal_control_status_handle_t handle)
{
    if (handle) {
        auto wrapper = reinterpret_cast<mavsdk_gimbal_wrapper*>(gimbal);
        auto cpp_handle = reinterpret_cast<mavsdk::Gimbal::ControlStatusHandle*>(handle);

        {
            std::lock_guard<std::mutex> lock(wrapper->handles_mutex);
            auto& vec = wrapper->control_status_handles;
            vec.erase(std::remove(vec.begin(), vec.end(), cpp_handle), vec.end());
        }

        wrapper->cpp_plugin->unsubscribe_control_status(std::move(*cpp_handle));
        delete cpp_handle;
    }
}



// GetControlStatus sync
mavsdk_gimbal_result_t
mavsdk_gimbal_get_control_status(
    mavsdk_gimbal_t gimbal,
    int32_t gimbal_id,
    mavsdk_gimbal_control_status_t* control_status_out)
{
    auto wrapper = reinterpret_cast<mavsdk_gimbal_wrapper*>(gimbal);

    auto result_pair = wrapper->cpp_plugin->get_control_status(
        gimbal_id);

    if (control_status_out != nullptr) {
        *control_status_out = translate_control_status_to_c(result_pair.second);
    }

    return translate_result(result_pair.first);
}

// Attitude async
mavsdk_gimbal_attitude_handle_t mavsdk_gimbal_subscribe_attitude(
    mavsdk_gimbal_t gimbal,
    mavsdk_gimbal_attitude_callback_t callback,
    void* user_data)
{
    auto wrapper = reinterpret_cast<mavsdk_gimbal_wrapper*>(gimbal);

    auto cpp_handle =    wrapper->cpp_plugin->subscribe_attitude(
        [callback, user_data](
            mavsdk::Gimbal::Attitude value) {
                if (callback) {
                    callback(
                        translate_attitude_to_c(value),
                        user_data);
                }
        });

    auto cpp_handle_ptr = new mavsdk::Gimbal::AttitudeHandle(std::move(cpp_handle));

    {
        std::lock_guard<std::mutex> lock(wrapper->handles_mutex);
        wrapper->attitude_handles.push_back(cpp_handle_ptr);
    }

    return reinterpret_cast<mavsdk_gimbal_attitude_handle_t>(cpp_handle_ptr);
}

void mavsdk_gimbal_unsubscribe_attitude(
    mavsdk_gimbal_t gimbal,
    mavsdk_gimbal_attitude_handle_t handle)
{
    if (handle) {
        auto wrapper = reinterpret_cast<mavsdk_gimbal_wrapper*>(gimbal);
        auto cpp_handle = reinterpret_cast<mavsdk::Gimbal::AttitudeHandle*>(handle);

        {
            std::lock_guard<std::mutex> lock(wrapper->handles_mutex);
            auto& vec = wrapper->attitude_handles;
            vec.erase(std::remove(vec.begin(), vec.end(), cpp_handle), vec.end());
        }

        wrapper->cpp_plugin->unsubscribe_attitude(std::move(*cpp_handle));
        delete cpp_handle;
    }
}



// GetAttitude sync
mavsdk_gimbal_result_t
mavsdk_gimbal_get_attitude(
    mavsdk_gimbal_t gimbal,
    int32_t gimbal_id,
    mavsdk_gimbal_attitude_t* attitude_out)
{
    auto wrapper = reinterpret_cast<mavsdk_gimbal_wrapper*>(gimbal);

    auto result_pair = wrapper->cpp_plugin->get_attitude(
        gimbal_id);

    if (attitude_out != nullptr) {
        *attitude_out = translate_attitude_to_c(result_pair.second);
    }

    return translate_result(result_pair.first);
}
