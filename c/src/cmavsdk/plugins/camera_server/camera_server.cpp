// WARNING: THIS FILE IS AUTOGENERATED! As such, it should not be edited.
// Edits need to be made to the proto files
// (see https://github.com/mavlink/MAVSDK-Proto/blob/main/protos/camera_server/camera_server.proto)

#include "camera_server.h"

#include <mavsdk/plugins/camera_server/camera_server.h>
#include <cstring>
#include <vector>

// ===== C++ to C Type Conversions =====

static mavsdk_camera_server_result_t
translate_result(mavsdk::CameraServer::Result cpp_result) {
    switch(cpp_result) {
        case mavsdk::CameraServer::Result::Unknown:
            return MAVSDK_CAMERA_SERVER_RESULT_UNKNOWN;
        case mavsdk::CameraServer::Result::Success:
            return MAVSDK_CAMERA_SERVER_RESULT_SUCCESS;
        case mavsdk::CameraServer::Result::InProgress:
            return MAVSDK_CAMERA_SERVER_RESULT_IN_PROGRESS;
        case mavsdk::CameraServer::Result::Busy:
            return MAVSDK_CAMERA_SERVER_RESULT_BUSY;
        case mavsdk::CameraServer::Result::Denied:
            return MAVSDK_CAMERA_SERVER_RESULT_DENIED;
        case mavsdk::CameraServer::Result::Error:
            return MAVSDK_CAMERA_SERVER_RESULT_ERROR;
        case mavsdk::CameraServer::Result::Timeout:
            return MAVSDK_CAMERA_SERVER_RESULT_TIMEOUT;
        case mavsdk::CameraServer::Result::WrongArgument:
            return MAVSDK_CAMERA_SERVER_RESULT_WRONG_ARGUMENT;
        case mavsdk::CameraServer::Result::NoSystem:
            return MAVSDK_CAMERA_SERVER_RESULT_NO_SYSTEM;
    }
}

static mavsdk::CameraServer::CameraFeedback
translate_camera_feedback_from_c(mavsdk_camera_server_camera_feedback_t c_enum) {
    switch(c_enum) {
        case MAVSDK_CAMERA_SERVER_CAMERA_FEEDBACK_UNKNOWN:
            return mavsdk::CameraServer::CameraFeedback::Unknown;
        case MAVSDK_CAMERA_SERVER_CAMERA_FEEDBACK_OK:
            return mavsdk::CameraServer::CameraFeedback::Ok;
        case MAVSDK_CAMERA_SERVER_CAMERA_FEEDBACK_BUSY:
            return mavsdk::CameraServer::CameraFeedback::Busy;
        case MAVSDK_CAMERA_SERVER_CAMERA_FEEDBACK_FAILED:
            return mavsdk::CameraServer::CameraFeedback::Failed;
    }
    return mavsdk::CameraServer::CameraFeedback::Unknown;
}

static mavsdk_camera_server_camera_feedback_t
translate_camera_feedback_to_c(mavsdk::CameraServer::CameraFeedback cpp_enum) {
    switch(cpp_enum) {
        case mavsdk::CameraServer::CameraFeedback::Unknown:
            return MAVSDK_CAMERA_SERVER_CAMERA_FEEDBACK_UNKNOWN;
        case mavsdk::CameraServer::CameraFeedback::Ok:
            return MAVSDK_CAMERA_SERVER_CAMERA_FEEDBACK_OK;
        case mavsdk::CameraServer::CameraFeedback::Busy:
            return MAVSDK_CAMERA_SERVER_CAMERA_FEEDBACK_BUSY;
        case mavsdk::CameraServer::CameraFeedback::Failed:
            return MAVSDK_CAMERA_SERVER_CAMERA_FEEDBACK_FAILED;
    }
    return MAVSDK_CAMERA_SERVER_CAMERA_FEEDBACK_UNKNOWN;
}

static mavsdk::CameraServer::Mode
translate_mode_from_c(mavsdk_camera_server_mode_t c_enum) {
    switch(c_enum) {
        case MAVSDK_CAMERA_SERVER_MODE_UNKNOWN:
            return mavsdk::CameraServer::Mode::Unknown;
        case MAVSDK_CAMERA_SERVER_MODE_PHOTO:
            return mavsdk::CameraServer::Mode::Photo;
        case MAVSDK_CAMERA_SERVER_MODE_VIDEO:
            return mavsdk::CameraServer::Mode::Video;
    }
    return mavsdk::CameraServer::Mode::Unknown;
}

static mavsdk_camera_server_mode_t
translate_mode_to_c(mavsdk::CameraServer::Mode cpp_enum) {
    switch(cpp_enum) {
        case mavsdk::CameraServer::Mode::Unknown:
            return MAVSDK_CAMERA_SERVER_MODE_UNKNOWN;
        case mavsdk::CameraServer::Mode::Photo:
            return MAVSDK_CAMERA_SERVER_MODE_PHOTO;
        case mavsdk::CameraServer::Mode::Video:
            return MAVSDK_CAMERA_SERVER_MODE_VIDEO;
    }
    return MAVSDK_CAMERA_SERVER_MODE_UNKNOWN;
}



static mavsdk::CameraServer::Information
translate_information_from_c(const mavsdk_camera_server_information_t& c_struct) {
    mavsdk::CameraServer::Information cpp_struct{};
    if (c_struct.vendor_name) {
        cpp_struct.vendor_name = c_struct.vendor_name;
    }
    if (c_struct.model_name) {
        cpp_struct.model_name = c_struct.model_name;
    }
    if (c_struct.firmware_version) {
        cpp_struct.firmware_version = c_struct.firmware_version;
    }
    cpp_struct.focal_length_mm = c_struct.focal_length_mm;
    cpp_struct.horizontal_sensor_size_mm = c_struct.horizontal_sensor_size_mm;
    cpp_struct.vertical_sensor_size_mm = c_struct.vertical_sensor_size_mm;
    cpp_struct.horizontal_resolution_px = c_struct.horizontal_resolution_px;
    cpp_struct.vertical_resolution_px = c_struct.vertical_resolution_px;
    cpp_struct.lens_id = c_struct.lens_id;
    cpp_struct.definition_file_version = c_struct.definition_file_version;
    if (c_struct.definition_file_uri) {
        cpp_struct.definition_file_uri = c_struct.definition_file_uri;
    }
    cpp_struct.image_in_video_mode_supported = c_struct.image_in_video_mode_supported;
    cpp_struct.video_in_image_mode_supported = c_struct.video_in_image_mode_supported;
    return cpp_struct;
}

static mavsdk_camera_server_information_t
translate_information_to_c(const mavsdk::CameraServer::Information& cpp_struct) {
    mavsdk_camera_server_information_t c_struct{};
    c_struct.vendor_name = strdup(cpp_struct.vendor_name.c_str());
    c_struct.model_name = strdup(cpp_struct.model_name.c_str());
    c_struct.firmware_version = strdup(cpp_struct.firmware_version.c_str());
    c_struct.focal_length_mm = cpp_struct.focal_length_mm;
    c_struct.horizontal_sensor_size_mm = cpp_struct.horizontal_sensor_size_mm;
    c_struct.vertical_sensor_size_mm = cpp_struct.vertical_sensor_size_mm;
    c_struct.horizontal_resolution_px = cpp_struct.horizontal_resolution_px;
    c_struct.vertical_resolution_px = cpp_struct.vertical_resolution_px;
    c_struct.lens_id = cpp_struct.lens_id;
    c_struct.definition_file_version = cpp_struct.definition_file_version;
    c_struct.definition_file_uri = strdup(cpp_struct.definition_file_uri.c_str());
    c_struct.image_in_video_mode_supported = cpp_struct.image_in_video_mode_supported;
    c_struct.video_in_image_mode_supported = cpp_struct.video_in_image_mode_supported;
    return c_struct;
}

void mavsdk_camera_server_information_destroy(
    mavsdk_camera_server_information_t* target) {
    if (!target) return;
    if (target->vendor_name) {
        free((void*)target->vendor_name);
        target->vendor_name = nullptr;
    }
    if (target->model_name) {
        free((void*)target->model_name);
        target->model_name = nullptr;
    }
    if (target->firmware_version) {
        free((void*)target->firmware_version);
        target->firmware_version = nullptr;
    }
    if (target->definition_file_uri) {
        free((void*)target->definition_file_uri);
        target->definition_file_uri = nullptr;
    }
}

void mavsdk_camera_server_information_array_destroy(
    mavsdk_camera_server_information_t** array,
    size_t size) {
    if (!array || !*array) return;

    for (size_t i = 0; i < size; i++) {
        mavsdk_camera_server_information_destroy(&(*array)[i]);
    }

    delete[] *array;
    *array = nullptr;
}


static mavsdk::CameraServer::VideoStreaming
translate_video_streaming_from_c(const mavsdk_camera_server_video_streaming_t& c_struct) {
    mavsdk::CameraServer::VideoStreaming cpp_struct{};
    cpp_struct.has_rtsp_server = c_struct.has_rtsp_server;
    if (c_struct.rtsp_uri) {
        cpp_struct.rtsp_uri = c_struct.rtsp_uri;
    }
    return cpp_struct;
}

static mavsdk_camera_server_video_streaming_t
translate_video_streaming_to_c(const mavsdk::CameraServer::VideoStreaming& cpp_struct) {
    mavsdk_camera_server_video_streaming_t c_struct{};
    c_struct.has_rtsp_server = cpp_struct.has_rtsp_server;
    c_struct.rtsp_uri = strdup(cpp_struct.rtsp_uri.c_str());
    return c_struct;
}

void mavsdk_camera_server_video_streaming_destroy(
    mavsdk_camera_server_video_streaming_t* target) {
    if (!target) return;
    if (target->rtsp_uri) {
        free((void*)target->rtsp_uri);
        target->rtsp_uri = nullptr;
    }
}

void mavsdk_camera_server_video_streaming_array_destroy(
    mavsdk_camera_server_video_streaming_t** array,
    size_t size) {
    if (!array || !*array) return;

    for (size_t i = 0; i < size; i++) {
        mavsdk_camera_server_video_streaming_destroy(&(*array)[i]);
    }

    delete[] *array;
    *array = nullptr;
}


static mavsdk::CameraServer::Position
translate_position_from_c(const mavsdk_camera_server_position_t& c_struct) {
    mavsdk::CameraServer::Position cpp_struct{};
    cpp_struct.latitude_deg = c_struct.latitude_deg;
    cpp_struct.longitude_deg = c_struct.longitude_deg;
    cpp_struct.absolute_altitude_m = c_struct.absolute_altitude_m;
    cpp_struct.relative_altitude_m = c_struct.relative_altitude_m;
    return cpp_struct;
}

static mavsdk_camera_server_position_t
translate_position_to_c(const mavsdk::CameraServer::Position& cpp_struct) {
    mavsdk_camera_server_position_t c_struct{};
    c_struct.latitude_deg = cpp_struct.latitude_deg;
    c_struct.longitude_deg = cpp_struct.longitude_deg;
    c_struct.absolute_altitude_m = cpp_struct.absolute_altitude_m;
    c_struct.relative_altitude_m = cpp_struct.relative_altitude_m;
    return c_struct;
}

void mavsdk_camera_server_position_destroy(
    mavsdk_camera_server_position_t* target) {
    if (!target) return;
}

void mavsdk_camera_server_position_array_destroy(
    mavsdk_camera_server_position_t** array,
    size_t size) {
    if (!array || !*array) return;

    for (size_t i = 0; i < size; i++) {
        mavsdk_camera_server_position_destroy(&(*array)[i]);
    }

    delete[] *array;
    *array = nullptr;
}


static mavsdk::CameraServer::Quaternion
translate_quaternion_from_c(const mavsdk_camera_server_quaternion_t& c_struct) {
    mavsdk::CameraServer::Quaternion cpp_struct{};
    cpp_struct.w = c_struct.w;
    cpp_struct.x = c_struct.x;
    cpp_struct.y = c_struct.y;
    cpp_struct.z = c_struct.z;
    return cpp_struct;
}

static mavsdk_camera_server_quaternion_t
translate_quaternion_to_c(const mavsdk::CameraServer::Quaternion& cpp_struct) {
    mavsdk_camera_server_quaternion_t c_struct{};
    c_struct.w = cpp_struct.w;
    c_struct.x = cpp_struct.x;
    c_struct.y = cpp_struct.y;
    c_struct.z = cpp_struct.z;
    return c_struct;
}

void mavsdk_camera_server_quaternion_destroy(
    mavsdk_camera_server_quaternion_t* target) {
    if (!target) return;
}

void mavsdk_camera_server_quaternion_array_destroy(
    mavsdk_camera_server_quaternion_t** array,
    size_t size) {
    if (!array || !*array) return;

    for (size_t i = 0; i < size; i++) {
        mavsdk_camera_server_quaternion_destroy(&(*array)[i]);
    }

    delete[] *array;
    *array = nullptr;
}


static mavsdk::CameraServer::CaptureInfo
translate_capture_info_from_c(const mavsdk_camera_server_capture_info_t& c_struct) {
    mavsdk::CameraServer::CaptureInfo cpp_struct{};
    cpp_struct.position = translate_position_from_c(c_struct.position);
    cpp_struct.attitude_quaternion = translate_quaternion_from_c(c_struct.attitude_quaternion);
    cpp_struct.time_utc_us = c_struct.time_utc_us;
    cpp_struct.is_success = c_struct.is_success;
    cpp_struct.index = c_struct.index;
    if (c_struct.file_url) {
        cpp_struct.file_url = c_struct.file_url;
    }
    return cpp_struct;
}

static mavsdk_camera_server_capture_info_t
translate_capture_info_to_c(const mavsdk::CameraServer::CaptureInfo& cpp_struct) {
    mavsdk_camera_server_capture_info_t c_struct{};
    c_struct.position = translate_position_to_c(cpp_struct.position);
    c_struct.attitude_quaternion = translate_quaternion_to_c(cpp_struct.attitude_quaternion);
    c_struct.time_utc_us = cpp_struct.time_utc_us;
    c_struct.is_success = cpp_struct.is_success;
    c_struct.index = cpp_struct.index;
    c_struct.file_url = strdup(cpp_struct.file_url.c_str());
    return c_struct;
}

void mavsdk_camera_server_capture_info_destroy(
    mavsdk_camera_server_capture_info_t* target) {
    if (!target) return;
    if (target->file_url) {
        free((void*)target->file_url);
        target->file_url = nullptr;
    }
}

void mavsdk_camera_server_capture_info_array_destroy(
    mavsdk_camera_server_capture_info_t** array,
    size_t size) {
    if (!array || !*array) return;

    for (size_t i = 0; i < size; i++) {
        mavsdk_camera_server_capture_info_destroy(&(*array)[i]);
    }

    delete[] *array;
    *array = nullptr;
}



static mavsdk::CameraServer::StorageInformation::StorageStatus
translate_storage_information_storage_status_from_c(mavsdk_camera_server_storage_information_storage_status_t c_enum) {
    switch(c_enum) {
        case MAVSDK_CAMERA_SERVER_STORAGE_INFORMATION_STORAGE_STATUS_NOT_AVAILABLE:
            return mavsdk::CameraServer::StorageInformation::StorageStatus::NotAvailable;
        case MAVSDK_CAMERA_SERVER_STORAGE_INFORMATION_STORAGE_STATUS_UNFORMATTED:
            return mavsdk::CameraServer::StorageInformation::StorageStatus::Unformatted;
        case MAVSDK_CAMERA_SERVER_STORAGE_INFORMATION_STORAGE_STATUS_FORMATTED:
            return mavsdk::CameraServer::StorageInformation::StorageStatus::Formatted;
        case MAVSDK_CAMERA_SERVER_STORAGE_INFORMATION_STORAGE_STATUS_NOT_SUPPORTED:
            return mavsdk::CameraServer::StorageInformation::StorageStatus::NotSupported;
    }
    return mavsdk::CameraServer::StorageInformation::StorageStatus::NotAvailable;
}


static mavsdk::CameraServer::StorageInformation::StorageType
translate_storage_information_storage_type_from_c(mavsdk_camera_server_storage_information_storage_type_t c_enum) {
    switch(c_enum) {
        case MAVSDK_CAMERA_SERVER_STORAGE_INFORMATION_STORAGE_TYPE_UNKNOWN:
            return mavsdk::CameraServer::StorageInformation::StorageType::Unknown;
        case MAVSDK_CAMERA_SERVER_STORAGE_INFORMATION_STORAGE_TYPE_USB_STICK:
            return mavsdk::CameraServer::StorageInformation::StorageType::UsbStick;
        case MAVSDK_CAMERA_SERVER_STORAGE_INFORMATION_STORAGE_TYPE_SD:
            return mavsdk::CameraServer::StorageInformation::StorageType::Sd;
        case MAVSDK_CAMERA_SERVER_STORAGE_INFORMATION_STORAGE_TYPE_MICROSD:
            return mavsdk::CameraServer::StorageInformation::StorageType::Microsd;
        case MAVSDK_CAMERA_SERVER_STORAGE_INFORMATION_STORAGE_TYPE_HD:
            return mavsdk::CameraServer::StorageInformation::StorageType::Hd;
        case MAVSDK_CAMERA_SERVER_STORAGE_INFORMATION_STORAGE_TYPE_OTHER:
            return mavsdk::CameraServer::StorageInformation::StorageType::Other;
    }
    return mavsdk::CameraServer::StorageInformation::StorageType::Unknown;
}


static mavsdk::CameraServer::StorageInformation
translate_storage_information_from_c(const mavsdk_camera_server_storage_information_t& c_struct) {
    mavsdk::CameraServer::StorageInformation cpp_struct{};
    cpp_struct.used_storage_mib = c_struct.used_storage_mib;
    cpp_struct.available_storage_mib = c_struct.available_storage_mib;
    cpp_struct.total_storage_mib = c_struct.total_storage_mib;
    cpp_struct.storage_status = translate_storage_information_storage_status_from_c(c_struct.storage_status);
    cpp_struct.storage_id = c_struct.storage_id;
    cpp_struct.storage_type = translate_storage_information_storage_type_from_c(c_struct.storage_type);
    cpp_struct.read_speed_mib_s = c_struct.read_speed_mib_s;
    cpp_struct.write_speed_mib_s = c_struct.write_speed_mib_s;
    return cpp_struct;
}


static mavsdk_camera_server_storage_information_storage_status_t
translate_storage_information_storage_status_to_c(mavsdk::CameraServer::StorageInformation::StorageStatus cpp_enum) {
    switch(cpp_enum) {
        case mavsdk::CameraServer::StorageInformation::StorageStatus::NotAvailable:
            return MAVSDK_CAMERA_SERVER_STORAGE_INFORMATION_STORAGE_STATUS_NOT_AVAILABLE;
        case mavsdk::CameraServer::StorageInformation::StorageStatus::Unformatted:
            return MAVSDK_CAMERA_SERVER_STORAGE_INFORMATION_STORAGE_STATUS_UNFORMATTED;
        case mavsdk::CameraServer::StorageInformation::StorageStatus::Formatted:
            return MAVSDK_CAMERA_SERVER_STORAGE_INFORMATION_STORAGE_STATUS_FORMATTED;
        case mavsdk::CameraServer::StorageInformation::StorageStatus::NotSupported:
            return MAVSDK_CAMERA_SERVER_STORAGE_INFORMATION_STORAGE_STATUS_NOT_SUPPORTED;
    }
    return MAVSDK_CAMERA_SERVER_STORAGE_INFORMATION_STORAGE_STATUS_NOT_AVAILABLE;
}


static mavsdk_camera_server_storage_information_storage_type_t
translate_storage_information_storage_type_to_c(mavsdk::CameraServer::StorageInformation::StorageType cpp_enum) {
    switch(cpp_enum) {
        case mavsdk::CameraServer::StorageInformation::StorageType::Unknown:
            return MAVSDK_CAMERA_SERVER_STORAGE_INFORMATION_STORAGE_TYPE_UNKNOWN;
        case mavsdk::CameraServer::StorageInformation::StorageType::UsbStick:
            return MAVSDK_CAMERA_SERVER_STORAGE_INFORMATION_STORAGE_TYPE_USB_STICK;
        case mavsdk::CameraServer::StorageInformation::StorageType::Sd:
            return MAVSDK_CAMERA_SERVER_STORAGE_INFORMATION_STORAGE_TYPE_SD;
        case mavsdk::CameraServer::StorageInformation::StorageType::Microsd:
            return MAVSDK_CAMERA_SERVER_STORAGE_INFORMATION_STORAGE_TYPE_MICROSD;
        case mavsdk::CameraServer::StorageInformation::StorageType::Hd:
            return MAVSDK_CAMERA_SERVER_STORAGE_INFORMATION_STORAGE_TYPE_HD;
        case mavsdk::CameraServer::StorageInformation::StorageType::Other:
            return MAVSDK_CAMERA_SERVER_STORAGE_INFORMATION_STORAGE_TYPE_OTHER;
    }
    return MAVSDK_CAMERA_SERVER_STORAGE_INFORMATION_STORAGE_TYPE_UNKNOWN;
}

static mavsdk_camera_server_storage_information_t
translate_storage_information_to_c(const mavsdk::CameraServer::StorageInformation& cpp_struct) {
    mavsdk_camera_server_storage_information_t c_struct{};
    c_struct.used_storage_mib = cpp_struct.used_storage_mib;
    c_struct.available_storage_mib = cpp_struct.available_storage_mib;
    c_struct.total_storage_mib = cpp_struct.total_storage_mib;
    c_struct.storage_status = translate_storage_information_storage_status_to_c(cpp_struct.storage_status);
    c_struct.storage_id = cpp_struct.storage_id;
    c_struct.storage_type = translate_storage_information_storage_type_to_c(cpp_struct.storage_type);
    c_struct.read_speed_mib_s = cpp_struct.read_speed_mib_s;
    c_struct.write_speed_mib_s = cpp_struct.write_speed_mib_s;
    return c_struct;
}

void mavsdk_camera_server_storage_information_destroy(
    mavsdk_camera_server_storage_information_t* target) {
    if (!target) return;
}

void mavsdk_camera_server_storage_information_array_destroy(
    mavsdk_camera_server_storage_information_t** array,
    size_t size) {
    if (!array || !*array) return;

    for (size_t i = 0; i < size; i++) {
        mavsdk_camera_server_storage_information_destroy(&(*array)[i]);
    }

    delete[] *array;
    *array = nullptr;
}


static mavsdk::CameraServer::CaptureStatus::ImageStatus
translate_capture_status_image_status_from_c(mavsdk_camera_server_capture_status_image_status_t c_enum) {
    switch(c_enum) {
        case MAVSDK_CAMERA_SERVER_CAPTURE_STATUS_IMAGE_STATUS_IDLE:
            return mavsdk::CameraServer::CaptureStatus::ImageStatus::Idle;
        case MAVSDK_CAMERA_SERVER_CAPTURE_STATUS_IMAGE_STATUS_CAPTURE_IN_PROGRESS:
            return mavsdk::CameraServer::CaptureStatus::ImageStatus::CaptureInProgress;
        case MAVSDK_CAMERA_SERVER_CAPTURE_STATUS_IMAGE_STATUS_INTERVAL_IDLE:
            return mavsdk::CameraServer::CaptureStatus::ImageStatus::IntervalIdle;
        case MAVSDK_CAMERA_SERVER_CAPTURE_STATUS_IMAGE_STATUS_INTERVAL_IN_PROGRESS:
            return mavsdk::CameraServer::CaptureStatus::ImageStatus::IntervalInProgress;
    }
    return mavsdk::CameraServer::CaptureStatus::ImageStatus::Idle;
}


static mavsdk::CameraServer::CaptureStatus::VideoStatus
translate_capture_status_video_status_from_c(mavsdk_camera_server_capture_status_video_status_t c_enum) {
    switch(c_enum) {
        case MAVSDK_CAMERA_SERVER_CAPTURE_STATUS_VIDEO_STATUS_IDLE:
            return mavsdk::CameraServer::CaptureStatus::VideoStatus::Idle;
        case MAVSDK_CAMERA_SERVER_CAPTURE_STATUS_VIDEO_STATUS_CAPTURE_IN_PROGRESS:
            return mavsdk::CameraServer::CaptureStatus::VideoStatus::CaptureInProgress;
    }
    return mavsdk::CameraServer::CaptureStatus::VideoStatus::Idle;
}


static mavsdk::CameraServer::CaptureStatus
translate_capture_status_from_c(const mavsdk_camera_server_capture_status_t& c_struct) {
    mavsdk::CameraServer::CaptureStatus cpp_struct{};
    cpp_struct.image_interval_s = c_struct.image_interval_s;
    cpp_struct.recording_time_s = c_struct.recording_time_s;
    cpp_struct.available_capacity_mib = c_struct.available_capacity_mib;
    cpp_struct.image_status = translate_capture_status_image_status_from_c(c_struct.image_status);
    cpp_struct.video_status = translate_capture_status_video_status_from_c(c_struct.video_status);
    cpp_struct.image_count = c_struct.image_count;
    return cpp_struct;
}


static mavsdk_camera_server_capture_status_image_status_t
translate_capture_status_image_status_to_c(mavsdk::CameraServer::CaptureStatus::ImageStatus cpp_enum) {
    switch(cpp_enum) {
        case mavsdk::CameraServer::CaptureStatus::ImageStatus::Idle:
            return MAVSDK_CAMERA_SERVER_CAPTURE_STATUS_IMAGE_STATUS_IDLE;
        case mavsdk::CameraServer::CaptureStatus::ImageStatus::CaptureInProgress:
            return MAVSDK_CAMERA_SERVER_CAPTURE_STATUS_IMAGE_STATUS_CAPTURE_IN_PROGRESS;
        case mavsdk::CameraServer::CaptureStatus::ImageStatus::IntervalIdle:
            return MAVSDK_CAMERA_SERVER_CAPTURE_STATUS_IMAGE_STATUS_INTERVAL_IDLE;
        case mavsdk::CameraServer::CaptureStatus::ImageStatus::IntervalInProgress:
            return MAVSDK_CAMERA_SERVER_CAPTURE_STATUS_IMAGE_STATUS_INTERVAL_IN_PROGRESS;
    }
    return MAVSDK_CAMERA_SERVER_CAPTURE_STATUS_IMAGE_STATUS_IDLE;
}


static mavsdk_camera_server_capture_status_video_status_t
translate_capture_status_video_status_to_c(mavsdk::CameraServer::CaptureStatus::VideoStatus cpp_enum) {
    switch(cpp_enum) {
        case mavsdk::CameraServer::CaptureStatus::VideoStatus::Idle:
            return MAVSDK_CAMERA_SERVER_CAPTURE_STATUS_VIDEO_STATUS_IDLE;
        case mavsdk::CameraServer::CaptureStatus::VideoStatus::CaptureInProgress:
            return MAVSDK_CAMERA_SERVER_CAPTURE_STATUS_VIDEO_STATUS_CAPTURE_IN_PROGRESS;
    }
    return MAVSDK_CAMERA_SERVER_CAPTURE_STATUS_VIDEO_STATUS_IDLE;
}

static mavsdk_camera_server_capture_status_t
translate_capture_status_to_c(const mavsdk::CameraServer::CaptureStatus& cpp_struct) {
    mavsdk_camera_server_capture_status_t c_struct{};
    c_struct.image_interval_s = cpp_struct.image_interval_s;
    c_struct.recording_time_s = cpp_struct.recording_time_s;
    c_struct.available_capacity_mib = cpp_struct.available_capacity_mib;
    c_struct.image_status = translate_capture_status_image_status_to_c(cpp_struct.image_status);
    c_struct.video_status = translate_capture_status_video_status_to_c(cpp_struct.video_status);
    c_struct.image_count = cpp_struct.image_count;
    return c_struct;
}

void mavsdk_camera_server_capture_status_destroy(
    mavsdk_camera_server_capture_status_t* target) {
    if (!target) return;
}

void mavsdk_camera_server_capture_status_array_destroy(
    mavsdk_camera_server_capture_status_t** array,
    size_t size) {
    if (!array || !*array) return;

    for (size_t i = 0; i < size; i++) {
        mavsdk_camera_server_capture_status_destroy(&(*array)[i]);
    }

    delete[] *array;
    *array = nullptr;
}


static mavsdk::CameraServer::TrackPoint
translate_track_point_from_c(const mavsdk_camera_server_track_point_t& c_struct) {
    mavsdk::CameraServer::TrackPoint cpp_struct{};
    cpp_struct.point_x = c_struct.point_x;
    cpp_struct.point_y = c_struct.point_y;
    cpp_struct.radius = c_struct.radius;
    return cpp_struct;
}

static mavsdk_camera_server_track_point_t
translate_track_point_to_c(const mavsdk::CameraServer::TrackPoint& cpp_struct) {
    mavsdk_camera_server_track_point_t c_struct{};
    c_struct.point_x = cpp_struct.point_x;
    c_struct.point_y = cpp_struct.point_y;
    c_struct.radius = cpp_struct.radius;
    return c_struct;
}

void mavsdk_camera_server_track_point_destroy(
    mavsdk_camera_server_track_point_t* target) {
    if (!target) return;
}

void mavsdk_camera_server_track_point_array_destroy(
    mavsdk_camera_server_track_point_t** array,
    size_t size) {
    if (!array || !*array) return;

    for (size_t i = 0; i < size; i++) {
        mavsdk_camera_server_track_point_destroy(&(*array)[i]);
    }

    delete[] *array;
    *array = nullptr;
}


static mavsdk::CameraServer::TrackRectangle
translate_track_rectangle_from_c(const mavsdk_camera_server_track_rectangle_t& c_struct) {
    mavsdk::CameraServer::TrackRectangle cpp_struct{};
    cpp_struct.top_left_corner_x = c_struct.top_left_corner_x;
    cpp_struct.top_left_corner_y = c_struct.top_left_corner_y;
    cpp_struct.bottom_right_corner_x = c_struct.bottom_right_corner_x;
    cpp_struct.bottom_right_corner_y = c_struct.bottom_right_corner_y;
    return cpp_struct;
}

static mavsdk_camera_server_track_rectangle_t
translate_track_rectangle_to_c(const mavsdk::CameraServer::TrackRectangle& cpp_struct) {
    mavsdk_camera_server_track_rectangle_t c_struct{};
    c_struct.top_left_corner_x = cpp_struct.top_left_corner_x;
    c_struct.top_left_corner_y = cpp_struct.top_left_corner_y;
    c_struct.bottom_right_corner_x = cpp_struct.bottom_right_corner_x;
    c_struct.bottom_right_corner_y = cpp_struct.bottom_right_corner_y;
    return c_struct;
}

void mavsdk_camera_server_track_rectangle_destroy(
    mavsdk_camera_server_track_rectangle_t* target) {
    if (!target) return;
}

void mavsdk_camera_server_track_rectangle_array_destroy(
    mavsdk_camera_server_track_rectangle_t** array,
    size_t size) {
    if (!array || !*array) return;

    for (size_t i = 0; i < size; i++) {
        mavsdk_camera_server_track_rectangle_destroy(&(*array)[i]);
    }

    delete[] *array;
    *array = nullptr;
}


// ===== Primitive Array Destroy Functions =====
void mavsdk_camera_server_float_array_destroy(float** array) {
    if (!array || !*array) return;
    delete[] *array;
    *array = nullptr;
}

void mavsdk_camera_server_double_array_destroy(double** array) {
    if (!array || !*array) return;
    delete[] *array;
    *array = nullptr;
}

void mavsdk_camera_server_int32t_array_destroy(int32_t** array) {
    if (!array || !*array) return;
    delete[] *array;
    *array = nullptr;
}

void mavsdk_camera_server_uint32t_array_destroy(uint32_t** array) {
    if (!array || !*array) return;
    delete[] *array;
    *array = nullptr;
}

void mavsdk_camera_server_int64t_array_destroy(int64_t** array) {
    if (!array || !*array) return;
    delete[] *array;
    *array = nullptr;
}

void mavsdk_camera_server_uint64t_array_destroy(uint64_t** array) {
    if (!array || !*array) return;
    delete[] *array;
    *array = nullptr;
}

void mavsdk_camera_server_bool_array_destroy(bool** array) {
    if (!array || !*array) return;
    delete[] *array;
    *array = nullptr;
}


void mavsdk_camera_server_string_destroy(char** str) {
    if (!str || !*str) return;
    free(*str);
    *str = nullptr;
}

void mavsdk_camera_server_byte_buffer_destroy(uint8_t** buffer) {
    if (!buffer || !*buffer) return;
    delete[] *buffer;
    *buffer = nullptr;
}

// ===== CameraServer Wrapper =====

struct mavsdk_camera_server_wrapper {
    std::shared_ptr<mavsdk::CameraServer> cpp_plugin;
};

mavsdk_camera_server_t
mavsdk_camera_server_create(mavsdk_server_component_t server_component) {
    if (server_component == nullptr) {
        return nullptr;
    }

    auto wrapper = new mavsdk_camera_server_wrapper();
    auto server_component_ptr = static_cast<std::shared_ptr<mavsdk::ServerComponent>*>(server_component);
    wrapper->cpp_plugin = std::make_shared<mavsdk::CameraServer>(*server_component_ptr);

    return wrapper;
}

void mavsdk_camera_server_destroy(mavsdk_camera_server_t camera_server) {
    if (camera_server == nullptr) {
        return;
    }

    auto wrapper = static_cast<mavsdk_camera_server_wrapper*>(camera_server);
    delete wrapper;
}

// ===== Method Implementations =====


// SetInformation sync
mavsdk_camera_server_result_t
mavsdk_camera_server_set_information(
    mavsdk_camera_server_t camera_server,
    mavsdk_camera_server_information_t information)
{
    auto wrapper = static_cast<mavsdk_camera_server_wrapper*>(camera_server);

    auto ret_value = wrapper->cpp_plugin->set_information(        translate_information_from_c(information));

    return translate_result(ret_value);
}


// SetVideoStreaming sync
mavsdk_camera_server_result_t
mavsdk_camera_server_set_video_streaming(
    mavsdk_camera_server_t camera_server,
    mavsdk_camera_server_video_streaming_t video_streaming)
{
    auto wrapper = static_cast<mavsdk_camera_server_wrapper*>(camera_server);

    auto ret_value = wrapper->cpp_plugin->set_video_streaming(        translate_video_streaming_from_c(video_streaming));

    return translate_result(ret_value);
}


// SetInProgress sync
mavsdk_camera_server_result_t
mavsdk_camera_server_set_in_progress(
    mavsdk_camera_server_t camera_server,
    bool in_progress)
{
    auto wrapper = static_cast<mavsdk_camera_server_wrapper*>(camera_server);

    auto ret_value = wrapper->cpp_plugin->set_in_progress(        in_progress);

    return translate_result(ret_value);
}

// TakePhoto async
mavsdk_camera_server_take_photo_handle_t mavsdk_camera_server_subscribe_take_photo(
    mavsdk_camera_server_t camera_server,
    mavsdk_camera_server_take_photo_callback_t callback,
    void* user_data)
{
    auto wrapper = static_cast<mavsdk_camera_server_wrapper*>(camera_server);

    auto cpp_handle =    wrapper->cpp_plugin->subscribe_take_photo(
        [callback, user_data](
            int32_t value) {
                if (callback) {
                    callback(
                        value,
                        user_data);
                }
        });

    auto handle_wrapper = new mavsdk::CameraServer::TakePhotoHandle(std::move(cpp_handle));
    return static_cast<mavsdk_camera_server_take_photo_handle_t>(handle_wrapper);
}

void mavsdk_camera_server_unsubscribe_take_photo(
    mavsdk_camera_server_t camera_server,
    mavsdk_camera_server_take_photo_handle_t handle)
{
    if (handle) {
        auto wrapper = static_cast<mavsdk_camera_server_wrapper*>(camera_server);
        auto cpp_handle = static_cast<mavsdk::CameraServer::TakePhotoHandle*>(handle);
        wrapper->cpp_plugin->unsubscribe_take_photo(std::move(*cpp_handle));
        delete cpp_handle;
    }
}



// RespondTakePhoto sync
mavsdk_camera_server_result_t
mavsdk_camera_server_respond_take_photo(
    mavsdk_camera_server_t camera_server,
    mavsdk_camera_server_camera_feedback_t take_photo_feedback,
    mavsdk_camera_server_capture_info_t capture_info)
{
    auto wrapper = static_cast<mavsdk_camera_server_wrapper*>(camera_server);

    auto ret_value = wrapper->cpp_plugin->respond_take_photo(        translate_camera_feedback_from_c(take_photo_feedback),        translate_capture_info_from_c(capture_info));

    return translate_result(ret_value);
}

// StartVideo async
mavsdk_camera_server_start_video_handle_t mavsdk_camera_server_subscribe_start_video(
    mavsdk_camera_server_t camera_server,
    mavsdk_camera_server_start_video_callback_t callback,
    void* user_data)
{
    auto wrapper = static_cast<mavsdk_camera_server_wrapper*>(camera_server);

    auto cpp_handle =    wrapper->cpp_plugin->subscribe_start_video(
        [callback, user_data](
            int32_t value) {
                if (callback) {
                    callback(
                        value,
                        user_data);
                }
        });

    auto handle_wrapper = new mavsdk::CameraServer::StartVideoHandle(std::move(cpp_handle));
    return static_cast<mavsdk_camera_server_start_video_handle_t>(handle_wrapper);
}

void mavsdk_camera_server_unsubscribe_start_video(
    mavsdk_camera_server_t camera_server,
    mavsdk_camera_server_start_video_handle_t handle)
{
    if (handle) {
        auto wrapper = static_cast<mavsdk_camera_server_wrapper*>(camera_server);
        auto cpp_handle = static_cast<mavsdk::CameraServer::StartVideoHandle*>(handle);
        wrapper->cpp_plugin->unsubscribe_start_video(std::move(*cpp_handle));
        delete cpp_handle;
    }
}



// RespondStartVideo sync
mavsdk_camera_server_result_t
mavsdk_camera_server_respond_start_video(
    mavsdk_camera_server_t camera_server,
    mavsdk_camera_server_camera_feedback_t start_video_feedback)
{
    auto wrapper = static_cast<mavsdk_camera_server_wrapper*>(camera_server);

    auto ret_value = wrapper->cpp_plugin->respond_start_video(        translate_camera_feedback_from_c(start_video_feedback));

    return translate_result(ret_value);
}

// StopVideo async
mavsdk_camera_server_stop_video_handle_t mavsdk_camera_server_subscribe_stop_video(
    mavsdk_camera_server_t camera_server,
    mavsdk_camera_server_stop_video_callback_t callback,
    void* user_data)
{
    auto wrapper = static_cast<mavsdk_camera_server_wrapper*>(camera_server);

    auto cpp_handle =    wrapper->cpp_plugin->subscribe_stop_video(
        [callback, user_data](
            int32_t value) {
                if (callback) {
                    callback(
                        value,
                        user_data);
                }
        });

    auto handle_wrapper = new mavsdk::CameraServer::StopVideoHandle(std::move(cpp_handle));
    return static_cast<mavsdk_camera_server_stop_video_handle_t>(handle_wrapper);
}

void mavsdk_camera_server_unsubscribe_stop_video(
    mavsdk_camera_server_t camera_server,
    mavsdk_camera_server_stop_video_handle_t handle)
{
    if (handle) {
        auto wrapper = static_cast<mavsdk_camera_server_wrapper*>(camera_server);
        auto cpp_handle = static_cast<mavsdk::CameraServer::StopVideoHandle*>(handle);
        wrapper->cpp_plugin->unsubscribe_stop_video(std::move(*cpp_handle));
        delete cpp_handle;
    }
}



// RespondStopVideo sync
mavsdk_camera_server_result_t
mavsdk_camera_server_respond_stop_video(
    mavsdk_camera_server_t camera_server,
    mavsdk_camera_server_camera_feedback_t stop_video_feedback)
{
    auto wrapper = static_cast<mavsdk_camera_server_wrapper*>(camera_server);

    auto ret_value = wrapper->cpp_plugin->respond_stop_video(        translate_camera_feedback_from_c(stop_video_feedback));

    return translate_result(ret_value);
}

// StartVideoStreaming async
mavsdk_camera_server_start_video_streaming_handle_t mavsdk_camera_server_subscribe_start_video_streaming(
    mavsdk_camera_server_t camera_server,
    mavsdk_camera_server_start_video_streaming_callback_t callback,
    void* user_data)
{
    auto wrapper = static_cast<mavsdk_camera_server_wrapper*>(camera_server);

    auto cpp_handle =    wrapper->cpp_plugin->subscribe_start_video_streaming(
        [callback, user_data](
            int32_t value) {
                if (callback) {
                    callback(
                        value,
                        user_data);
                }
        });

    auto handle_wrapper = new mavsdk::CameraServer::StartVideoStreamingHandle(std::move(cpp_handle));
    return static_cast<mavsdk_camera_server_start_video_streaming_handle_t>(handle_wrapper);
}

void mavsdk_camera_server_unsubscribe_start_video_streaming(
    mavsdk_camera_server_t camera_server,
    mavsdk_camera_server_start_video_streaming_handle_t handle)
{
    if (handle) {
        auto wrapper = static_cast<mavsdk_camera_server_wrapper*>(camera_server);
        auto cpp_handle = static_cast<mavsdk::CameraServer::StartVideoStreamingHandle*>(handle);
        wrapper->cpp_plugin->unsubscribe_start_video_streaming(std::move(*cpp_handle));
        delete cpp_handle;
    }
}



// RespondStartVideoStreaming sync
mavsdk_camera_server_result_t
mavsdk_camera_server_respond_start_video_streaming(
    mavsdk_camera_server_t camera_server,
    mavsdk_camera_server_camera_feedback_t start_video_streaming_feedback)
{
    auto wrapper = static_cast<mavsdk_camera_server_wrapper*>(camera_server);

    auto ret_value = wrapper->cpp_plugin->respond_start_video_streaming(        translate_camera_feedback_from_c(start_video_streaming_feedback));

    return translate_result(ret_value);
}

// StopVideoStreaming async
mavsdk_camera_server_stop_video_streaming_handle_t mavsdk_camera_server_subscribe_stop_video_streaming(
    mavsdk_camera_server_t camera_server,
    mavsdk_camera_server_stop_video_streaming_callback_t callback,
    void* user_data)
{
    auto wrapper = static_cast<mavsdk_camera_server_wrapper*>(camera_server);

    auto cpp_handle =    wrapper->cpp_plugin->subscribe_stop_video_streaming(
        [callback, user_data](
            int32_t value) {
                if (callback) {
                    callback(
                        value,
                        user_data);
                }
        });

    auto handle_wrapper = new mavsdk::CameraServer::StopVideoStreamingHandle(std::move(cpp_handle));
    return static_cast<mavsdk_camera_server_stop_video_streaming_handle_t>(handle_wrapper);
}

void mavsdk_camera_server_unsubscribe_stop_video_streaming(
    mavsdk_camera_server_t camera_server,
    mavsdk_camera_server_stop_video_streaming_handle_t handle)
{
    if (handle) {
        auto wrapper = static_cast<mavsdk_camera_server_wrapper*>(camera_server);
        auto cpp_handle = static_cast<mavsdk::CameraServer::StopVideoStreamingHandle*>(handle);
        wrapper->cpp_plugin->unsubscribe_stop_video_streaming(std::move(*cpp_handle));
        delete cpp_handle;
    }
}



// RespondStopVideoStreaming sync
mavsdk_camera_server_result_t
mavsdk_camera_server_respond_stop_video_streaming(
    mavsdk_camera_server_t camera_server,
    mavsdk_camera_server_camera_feedback_t stop_video_streaming_feedback)
{
    auto wrapper = static_cast<mavsdk_camera_server_wrapper*>(camera_server);

    auto ret_value = wrapper->cpp_plugin->respond_stop_video_streaming(        translate_camera_feedback_from_c(stop_video_streaming_feedback));

    return translate_result(ret_value);
}

// SetMode async
mavsdk_camera_server_set_mode_handle_t mavsdk_camera_server_subscribe_set_mode(
    mavsdk_camera_server_t camera_server,
    mavsdk_camera_server_set_mode_callback_t callback,
    void* user_data)
{
    auto wrapper = static_cast<mavsdk_camera_server_wrapper*>(camera_server);

    auto cpp_handle =    wrapper->cpp_plugin->subscribe_set_mode(
        [callback, user_data](
            mavsdk::CameraServer::Mode value) {
                if (callback) {
                    callback(
                        translate_mode_to_c(value),
                        user_data);
                }
        });

    auto handle_wrapper = new mavsdk::CameraServer::SetModeHandle(std::move(cpp_handle));
    return static_cast<mavsdk_camera_server_set_mode_handle_t>(handle_wrapper);
}

void mavsdk_camera_server_unsubscribe_set_mode(
    mavsdk_camera_server_t camera_server,
    mavsdk_camera_server_set_mode_handle_t handle)
{
    if (handle) {
        auto wrapper = static_cast<mavsdk_camera_server_wrapper*>(camera_server);
        auto cpp_handle = static_cast<mavsdk::CameraServer::SetModeHandle*>(handle);
        wrapper->cpp_plugin->unsubscribe_set_mode(std::move(*cpp_handle));
        delete cpp_handle;
    }
}



// RespondSetMode sync
mavsdk_camera_server_result_t
mavsdk_camera_server_respond_set_mode(
    mavsdk_camera_server_t camera_server,
    mavsdk_camera_server_camera_feedback_t set_mode_feedback)
{
    auto wrapper = static_cast<mavsdk_camera_server_wrapper*>(camera_server);

    auto ret_value = wrapper->cpp_plugin->respond_set_mode(        translate_camera_feedback_from_c(set_mode_feedback));

    return translate_result(ret_value);
}

// StorageInformation async
mavsdk_camera_server_storage_information_handle_t mavsdk_camera_server_subscribe_storage_information(
    mavsdk_camera_server_t camera_server,
    mavsdk_camera_server_storage_information_callback_t callback,
    void* user_data)
{
    auto wrapper = static_cast<mavsdk_camera_server_wrapper*>(camera_server);

    auto cpp_handle =    wrapper->cpp_plugin->subscribe_storage_information(
        [callback, user_data](
            int32_t value) {
                if (callback) {
                    callback(
                        value,
                        user_data);
                }
        });

    auto handle_wrapper = new mavsdk::CameraServer::StorageInformationHandle(std::move(cpp_handle));
    return static_cast<mavsdk_camera_server_storage_information_handle_t>(handle_wrapper);
}

void mavsdk_camera_server_unsubscribe_storage_information(
    mavsdk_camera_server_t camera_server,
    mavsdk_camera_server_storage_information_handle_t handle)
{
    if (handle) {
        auto wrapper = static_cast<mavsdk_camera_server_wrapper*>(camera_server);
        auto cpp_handle = static_cast<mavsdk::CameraServer::StorageInformationHandle*>(handle);
        wrapper->cpp_plugin->unsubscribe_storage_information(std::move(*cpp_handle));
        delete cpp_handle;
    }
}



// RespondStorageInformation sync
mavsdk_camera_server_result_t
mavsdk_camera_server_respond_storage_information(
    mavsdk_camera_server_t camera_server,
    mavsdk_camera_server_camera_feedback_t storage_information_feedback,
    mavsdk_camera_server_storage_information_t storage_information)
{
    auto wrapper = static_cast<mavsdk_camera_server_wrapper*>(camera_server);

    auto ret_value = wrapper->cpp_plugin->respond_storage_information(        translate_camera_feedback_from_c(storage_information_feedback),        translate_storage_information_from_c(storage_information));

    return translate_result(ret_value);
}

// CaptureStatus async
mavsdk_camera_server_capture_status_handle_t mavsdk_camera_server_subscribe_capture_status(
    mavsdk_camera_server_t camera_server,
    mavsdk_camera_server_capture_status_callback_t callback,
    void* user_data)
{
    auto wrapper = static_cast<mavsdk_camera_server_wrapper*>(camera_server);

    auto cpp_handle =    wrapper->cpp_plugin->subscribe_capture_status(
        [callback, user_data](
            int32_t value) {
                if (callback) {
                    callback(
                        value,
                        user_data);
                }
        });

    auto handle_wrapper = new mavsdk::CameraServer::CaptureStatusHandle(std::move(cpp_handle));
    return static_cast<mavsdk_camera_server_capture_status_handle_t>(handle_wrapper);
}

void mavsdk_camera_server_unsubscribe_capture_status(
    mavsdk_camera_server_t camera_server,
    mavsdk_camera_server_capture_status_handle_t handle)
{
    if (handle) {
        auto wrapper = static_cast<mavsdk_camera_server_wrapper*>(camera_server);
        auto cpp_handle = static_cast<mavsdk::CameraServer::CaptureStatusHandle*>(handle);
        wrapper->cpp_plugin->unsubscribe_capture_status(std::move(*cpp_handle));
        delete cpp_handle;
    }
}



// RespondCaptureStatus sync
mavsdk_camera_server_result_t
mavsdk_camera_server_respond_capture_status(
    mavsdk_camera_server_t camera_server,
    mavsdk_camera_server_camera_feedback_t capture_status_feedback,
    mavsdk_camera_server_capture_status_t capture_status)
{
    auto wrapper = static_cast<mavsdk_camera_server_wrapper*>(camera_server);

    auto ret_value = wrapper->cpp_plugin->respond_capture_status(        translate_camera_feedback_from_c(capture_status_feedback),        translate_capture_status_from_c(capture_status));

    return translate_result(ret_value);
}

// FormatStorage async
mavsdk_camera_server_format_storage_handle_t mavsdk_camera_server_subscribe_format_storage(
    mavsdk_camera_server_t camera_server,
    mavsdk_camera_server_format_storage_callback_t callback,
    void* user_data)
{
    auto wrapper = static_cast<mavsdk_camera_server_wrapper*>(camera_server);

    auto cpp_handle =    wrapper->cpp_plugin->subscribe_format_storage(
        [callback, user_data](
            int32_t value) {
                if (callback) {
                    callback(
                        value,
                        user_data);
                }
        });

    auto handle_wrapper = new mavsdk::CameraServer::FormatStorageHandle(std::move(cpp_handle));
    return static_cast<mavsdk_camera_server_format_storage_handle_t>(handle_wrapper);
}

void mavsdk_camera_server_unsubscribe_format_storage(
    mavsdk_camera_server_t camera_server,
    mavsdk_camera_server_format_storage_handle_t handle)
{
    if (handle) {
        auto wrapper = static_cast<mavsdk_camera_server_wrapper*>(camera_server);
        auto cpp_handle = static_cast<mavsdk::CameraServer::FormatStorageHandle*>(handle);
        wrapper->cpp_plugin->unsubscribe_format_storage(std::move(*cpp_handle));
        delete cpp_handle;
    }
}



// RespondFormatStorage sync
mavsdk_camera_server_result_t
mavsdk_camera_server_respond_format_storage(
    mavsdk_camera_server_t camera_server,
    mavsdk_camera_server_camera_feedback_t format_storage_feedback)
{
    auto wrapper = static_cast<mavsdk_camera_server_wrapper*>(camera_server);

    auto ret_value = wrapper->cpp_plugin->respond_format_storage(        translate_camera_feedback_from_c(format_storage_feedback));

    return translate_result(ret_value);
}

// ResetSettings async
mavsdk_camera_server_reset_settings_handle_t mavsdk_camera_server_subscribe_reset_settings(
    mavsdk_camera_server_t camera_server,
    mavsdk_camera_server_reset_settings_callback_t callback,
    void* user_data)
{
    auto wrapper = static_cast<mavsdk_camera_server_wrapper*>(camera_server);

    auto cpp_handle =    wrapper->cpp_plugin->subscribe_reset_settings(
        [callback, user_data](
            int32_t value) {
                if (callback) {
                    callback(
                        value,
                        user_data);
                }
        });

    auto handle_wrapper = new mavsdk::CameraServer::ResetSettingsHandle(std::move(cpp_handle));
    return static_cast<mavsdk_camera_server_reset_settings_handle_t>(handle_wrapper);
}

void mavsdk_camera_server_unsubscribe_reset_settings(
    mavsdk_camera_server_t camera_server,
    mavsdk_camera_server_reset_settings_handle_t handle)
{
    if (handle) {
        auto wrapper = static_cast<mavsdk_camera_server_wrapper*>(camera_server);
        auto cpp_handle = static_cast<mavsdk::CameraServer::ResetSettingsHandle*>(handle);
        wrapper->cpp_plugin->unsubscribe_reset_settings(std::move(*cpp_handle));
        delete cpp_handle;
    }
}



// RespondResetSettings sync
mavsdk_camera_server_result_t
mavsdk_camera_server_respond_reset_settings(
    mavsdk_camera_server_t camera_server,
    mavsdk_camera_server_camera_feedback_t reset_settings_feedback)
{
    auto wrapper = static_cast<mavsdk_camera_server_wrapper*>(camera_server);

    auto ret_value = wrapper->cpp_plugin->respond_reset_settings(        translate_camera_feedback_from_c(reset_settings_feedback));

    return translate_result(ret_value);
}

// ZoomInStart async
mavsdk_camera_server_zoom_in_start_handle_t mavsdk_camera_server_subscribe_zoom_in_start(
    mavsdk_camera_server_t camera_server,
    mavsdk_camera_server_zoom_in_start_callback_t callback,
    void* user_data)
{
    auto wrapper = static_cast<mavsdk_camera_server_wrapper*>(camera_server);

    auto cpp_handle =    wrapper->cpp_plugin->subscribe_zoom_in_start(
        [callback, user_data](
            int32_t value) {
                if (callback) {
                    callback(
                        value,
                        user_data);
                }
        });

    auto handle_wrapper = new mavsdk::CameraServer::ZoomInStartHandle(std::move(cpp_handle));
    return static_cast<mavsdk_camera_server_zoom_in_start_handle_t>(handle_wrapper);
}

void mavsdk_camera_server_unsubscribe_zoom_in_start(
    mavsdk_camera_server_t camera_server,
    mavsdk_camera_server_zoom_in_start_handle_t handle)
{
    if (handle) {
        auto wrapper = static_cast<mavsdk_camera_server_wrapper*>(camera_server);
        auto cpp_handle = static_cast<mavsdk::CameraServer::ZoomInStartHandle*>(handle);
        wrapper->cpp_plugin->unsubscribe_zoom_in_start(std::move(*cpp_handle));
        delete cpp_handle;
    }
}



// RespondZoomInStart sync
mavsdk_camera_server_result_t
mavsdk_camera_server_respond_zoom_in_start(
    mavsdk_camera_server_t camera_server,
    mavsdk_camera_server_camera_feedback_t zoom_in_start_feedback)
{
    auto wrapper = static_cast<mavsdk_camera_server_wrapper*>(camera_server);

    auto ret_value = wrapper->cpp_plugin->respond_zoom_in_start(        translate_camera_feedback_from_c(zoom_in_start_feedback));

    return translate_result(ret_value);
}

// ZoomOutStart async
mavsdk_camera_server_zoom_out_start_handle_t mavsdk_camera_server_subscribe_zoom_out_start(
    mavsdk_camera_server_t camera_server,
    mavsdk_camera_server_zoom_out_start_callback_t callback,
    void* user_data)
{
    auto wrapper = static_cast<mavsdk_camera_server_wrapper*>(camera_server);

    auto cpp_handle =    wrapper->cpp_plugin->subscribe_zoom_out_start(
        [callback, user_data](
            int32_t value) {
                if (callback) {
                    callback(
                        value,
                        user_data);
                }
        });

    auto handle_wrapper = new mavsdk::CameraServer::ZoomOutStartHandle(std::move(cpp_handle));
    return static_cast<mavsdk_camera_server_zoom_out_start_handle_t>(handle_wrapper);
}

void mavsdk_camera_server_unsubscribe_zoom_out_start(
    mavsdk_camera_server_t camera_server,
    mavsdk_camera_server_zoom_out_start_handle_t handle)
{
    if (handle) {
        auto wrapper = static_cast<mavsdk_camera_server_wrapper*>(camera_server);
        auto cpp_handle = static_cast<mavsdk::CameraServer::ZoomOutStartHandle*>(handle);
        wrapper->cpp_plugin->unsubscribe_zoom_out_start(std::move(*cpp_handle));
        delete cpp_handle;
    }
}



// RespondZoomOutStart sync
mavsdk_camera_server_result_t
mavsdk_camera_server_respond_zoom_out_start(
    mavsdk_camera_server_t camera_server,
    mavsdk_camera_server_camera_feedback_t zoom_out_start_feedback)
{
    auto wrapper = static_cast<mavsdk_camera_server_wrapper*>(camera_server);

    auto ret_value = wrapper->cpp_plugin->respond_zoom_out_start(        translate_camera_feedback_from_c(zoom_out_start_feedback));

    return translate_result(ret_value);
}

// ZoomStop async
mavsdk_camera_server_zoom_stop_handle_t mavsdk_camera_server_subscribe_zoom_stop(
    mavsdk_camera_server_t camera_server,
    mavsdk_camera_server_zoom_stop_callback_t callback,
    void* user_data)
{
    auto wrapper = static_cast<mavsdk_camera_server_wrapper*>(camera_server);

    auto cpp_handle =    wrapper->cpp_plugin->subscribe_zoom_stop(
        [callback, user_data](
            int32_t value) {
                if (callback) {
                    callback(
                        value,
                        user_data);
                }
        });

    auto handle_wrapper = new mavsdk::CameraServer::ZoomStopHandle(std::move(cpp_handle));
    return static_cast<mavsdk_camera_server_zoom_stop_handle_t>(handle_wrapper);
}

void mavsdk_camera_server_unsubscribe_zoom_stop(
    mavsdk_camera_server_t camera_server,
    mavsdk_camera_server_zoom_stop_handle_t handle)
{
    if (handle) {
        auto wrapper = static_cast<mavsdk_camera_server_wrapper*>(camera_server);
        auto cpp_handle = static_cast<mavsdk::CameraServer::ZoomStopHandle*>(handle);
        wrapper->cpp_plugin->unsubscribe_zoom_stop(std::move(*cpp_handle));
        delete cpp_handle;
    }
}



// RespondZoomStop sync
mavsdk_camera_server_result_t
mavsdk_camera_server_respond_zoom_stop(
    mavsdk_camera_server_t camera_server,
    mavsdk_camera_server_camera_feedback_t zoom_stop_feedback)
{
    auto wrapper = static_cast<mavsdk_camera_server_wrapper*>(camera_server);

    auto ret_value = wrapper->cpp_plugin->respond_zoom_stop(        translate_camera_feedback_from_c(zoom_stop_feedback));

    return translate_result(ret_value);
}

// ZoomRange async
mavsdk_camera_server_zoom_range_handle_t mavsdk_camera_server_subscribe_zoom_range(
    mavsdk_camera_server_t camera_server,
    mavsdk_camera_server_zoom_range_callback_t callback,
    void* user_data)
{
    auto wrapper = static_cast<mavsdk_camera_server_wrapper*>(camera_server);

    auto cpp_handle =    wrapper->cpp_plugin->subscribe_zoom_range(
        [callback, user_data](
            float value) {
                if (callback) {
                    callback(
                        value,
                        user_data);
                }
        });

    auto handle_wrapper = new mavsdk::CameraServer::ZoomRangeHandle(std::move(cpp_handle));
    return static_cast<mavsdk_camera_server_zoom_range_handle_t>(handle_wrapper);
}

void mavsdk_camera_server_unsubscribe_zoom_range(
    mavsdk_camera_server_t camera_server,
    mavsdk_camera_server_zoom_range_handle_t handle)
{
    if (handle) {
        auto wrapper = static_cast<mavsdk_camera_server_wrapper*>(camera_server);
        auto cpp_handle = static_cast<mavsdk::CameraServer::ZoomRangeHandle*>(handle);
        wrapper->cpp_plugin->unsubscribe_zoom_range(std::move(*cpp_handle));
        delete cpp_handle;
    }
}



// RespondZoomRange sync
mavsdk_camera_server_result_t
mavsdk_camera_server_respond_zoom_range(
    mavsdk_camera_server_t camera_server,
    mavsdk_camera_server_camera_feedback_t zoom_range_feedback)
{
    auto wrapper = static_cast<mavsdk_camera_server_wrapper*>(camera_server);

    auto ret_value = wrapper->cpp_plugin->respond_zoom_range(        translate_camera_feedback_from_c(zoom_range_feedback));

    return translate_result(ret_value);
}


// SetTrackingRectangleStatus sync
void
mavsdk_camera_server_set_tracking_rectangle_status(
    mavsdk_camera_server_t camera_server,
    mavsdk_camera_server_track_rectangle_t tracked_rectangle)
{
    auto wrapper = static_cast<mavsdk_camera_server_wrapper*>(camera_server);

wrapper->cpp_plugin->set_tracking_rectangle_status(        translate_track_rectangle_from_c(tracked_rectangle));

}


// SetTrackingOffStatus sync
void
mavsdk_camera_server_set_tracking_off_status(
    mavsdk_camera_server_t camera_server)
{
    auto wrapper = static_cast<mavsdk_camera_server_wrapper*>(camera_server);

wrapper->cpp_plugin->set_tracking_off_status();

}

// TrackingPointCommand async
mavsdk_camera_server_tracking_point_command_handle_t mavsdk_camera_server_subscribe_tracking_point_command(
    mavsdk_camera_server_t camera_server,
    mavsdk_camera_server_tracking_point_command_callback_t callback,
    void* user_data)
{
    auto wrapper = static_cast<mavsdk_camera_server_wrapper*>(camera_server);

    auto cpp_handle =    wrapper->cpp_plugin->subscribe_tracking_point_command(
        [callback, user_data](
            mavsdk::CameraServer::TrackPoint value) {
                if (callback) {
                    callback(
                        translate_track_point_to_c(value),
                        user_data);
                }
        });

    auto handle_wrapper = new mavsdk::CameraServer::TrackingPointCommandHandle(std::move(cpp_handle));
    return static_cast<mavsdk_camera_server_tracking_point_command_handle_t>(handle_wrapper);
}

void mavsdk_camera_server_unsubscribe_tracking_point_command(
    mavsdk_camera_server_t camera_server,
    mavsdk_camera_server_tracking_point_command_handle_t handle)
{
    if (handle) {
        auto wrapper = static_cast<mavsdk_camera_server_wrapper*>(camera_server);
        auto cpp_handle = static_cast<mavsdk::CameraServer::TrackingPointCommandHandle*>(handle);
        wrapper->cpp_plugin->unsubscribe_tracking_point_command(std::move(*cpp_handle));
        delete cpp_handle;
    }
}


// TrackingRectangleCommand async
mavsdk_camera_server_tracking_rectangle_command_handle_t mavsdk_camera_server_subscribe_tracking_rectangle_command(
    mavsdk_camera_server_t camera_server,
    mavsdk_camera_server_tracking_rectangle_command_callback_t callback,
    void* user_data)
{
    auto wrapper = static_cast<mavsdk_camera_server_wrapper*>(camera_server);

    auto cpp_handle =    wrapper->cpp_plugin->subscribe_tracking_rectangle_command(
        [callback, user_data](
            mavsdk::CameraServer::TrackRectangle value) {
                if (callback) {
                    callback(
                        translate_track_rectangle_to_c(value),
                        user_data);
                }
        });

    auto handle_wrapper = new mavsdk::CameraServer::TrackingRectangleCommandHandle(std::move(cpp_handle));
    return static_cast<mavsdk_camera_server_tracking_rectangle_command_handle_t>(handle_wrapper);
}

void mavsdk_camera_server_unsubscribe_tracking_rectangle_command(
    mavsdk_camera_server_t camera_server,
    mavsdk_camera_server_tracking_rectangle_command_handle_t handle)
{
    if (handle) {
        auto wrapper = static_cast<mavsdk_camera_server_wrapper*>(camera_server);
        auto cpp_handle = static_cast<mavsdk::CameraServer::TrackingRectangleCommandHandle*>(handle);
        wrapper->cpp_plugin->unsubscribe_tracking_rectangle_command(std::move(*cpp_handle));
        delete cpp_handle;
    }
}


// TrackingOffCommand async
mavsdk_camera_server_tracking_off_command_handle_t mavsdk_camera_server_subscribe_tracking_off_command(
    mavsdk_camera_server_t camera_server,
    mavsdk_camera_server_tracking_off_command_callback_t callback,
    void* user_data)
{
    auto wrapper = static_cast<mavsdk_camera_server_wrapper*>(camera_server);

    auto cpp_handle =    wrapper->cpp_plugin->subscribe_tracking_off_command(
        [callback, user_data](
            int32_t value) {
                if (callback) {
                    callback(
                        value,
                        user_data);
                }
        });

    auto handle_wrapper = new mavsdk::CameraServer::TrackingOffCommandHandle(std::move(cpp_handle));
    return static_cast<mavsdk_camera_server_tracking_off_command_handle_t>(handle_wrapper);
}

void mavsdk_camera_server_unsubscribe_tracking_off_command(
    mavsdk_camera_server_t camera_server,
    mavsdk_camera_server_tracking_off_command_handle_t handle)
{
    if (handle) {
        auto wrapper = static_cast<mavsdk_camera_server_wrapper*>(camera_server);
        auto cpp_handle = static_cast<mavsdk::CameraServer::TrackingOffCommandHandle*>(handle);
        wrapper->cpp_plugin->unsubscribe_tracking_off_command(std::move(*cpp_handle));
        delete cpp_handle;
    }
}



// RespondTrackingPointCommand sync
mavsdk_camera_server_result_t
mavsdk_camera_server_respond_tracking_point_command(
    mavsdk_camera_server_t camera_server,
    mavsdk_camera_server_camera_feedback_t stop_video_feedback)
{
    auto wrapper = static_cast<mavsdk_camera_server_wrapper*>(camera_server);

    auto ret_value = wrapper->cpp_plugin->respond_tracking_point_command(        translate_camera_feedback_from_c(stop_video_feedback));

    return translate_result(ret_value);
}


// RespondTrackingRectangleCommand sync
mavsdk_camera_server_result_t
mavsdk_camera_server_respond_tracking_rectangle_command(
    mavsdk_camera_server_t camera_server,
    mavsdk_camera_server_camera_feedback_t stop_video_feedback)
{
    auto wrapper = static_cast<mavsdk_camera_server_wrapper*>(camera_server);

    auto ret_value = wrapper->cpp_plugin->respond_tracking_rectangle_command(        translate_camera_feedback_from_c(stop_video_feedback));

    return translate_result(ret_value);
}


// RespondTrackingOffCommand sync
mavsdk_camera_server_result_t
mavsdk_camera_server_respond_tracking_off_command(
    mavsdk_camera_server_t camera_server,
    mavsdk_camera_server_camera_feedback_t stop_video_feedback)
{
    auto wrapper = static_cast<mavsdk_camera_server_wrapper*>(camera_server);

    auto ret_value = wrapper->cpp_plugin->respond_tracking_off_command(        translate_camera_feedback_from_c(stop_video_feedback));

    return translate_result(ret_value);
}
