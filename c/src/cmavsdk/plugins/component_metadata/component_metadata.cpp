// WARNING: THIS FILE IS AUTOGENERATED! As such, it should not be edited.
// Edits need to be made to the proto files
// (see https://github.com/mavlink/MAVSDK-Proto/blob/main/protos/component_metadata/component_metadata.proto)

#include "component_metadata.h"

#include <mavsdk/plugins/component_metadata/component_metadata.h>
#include <algorithm>
#include <cstring>
#include <mutex>
#include <vector>

// ===== C++ to C Type Conversions =====

static mavsdk_component_metadata_result_t
translate_result(mavsdk::ComponentMetadata::Result cpp_result) {
    switch(cpp_result) {
        case mavsdk::ComponentMetadata::Result::Success:
            return MAVSDK_COMPONENT_METADATA_RESULT_SUCCESS;
        case mavsdk::ComponentMetadata::Result::NotAvailable:
            return MAVSDK_COMPONENT_METADATA_RESULT_NOT_AVAILABLE;
        case mavsdk::ComponentMetadata::Result::ConnectionError:
            return MAVSDK_COMPONENT_METADATA_RESULT_CONNECTION_ERROR;
        case mavsdk::ComponentMetadata::Result::Unsupported:
            return MAVSDK_COMPONENT_METADATA_RESULT_UNSUPPORTED;
        case mavsdk::ComponentMetadata::Result::Denied:
            return MAVSDK_COMPONENT_METADATA_RESULT_DENIED;
        case mavsdk::ComponentMetadata::Result::Failed:
            return MAVSDK_COMPONENT_METADATA_RESULT_FAILED;
        case mavsdk::ComponentMetadata::Result::Timeout:
            return MAVSDK_COMPONENT_METADATA_RESULT_TIMEOUT;
        case mavsdk::ComponentMetadata::Result::NoSystem:
            return MAVSDK_COMPONENT_METADATA_RESULT_NO_SYSTEM;
        case mavsdk::ComponentMetadata::Result::NotRequested:
            return MAVSDK_COMPONENT_METADATA_RESULT_NOT_REQUESTED;
    }
}

static mavsdk::ComponentMetadata::MetadataType
translate_metadata_type_from_c(mavsdk_component_metadata_metadata_type_t c_enum) {
    switch(c_enum) {
        case MAVSDK_COMPONENT_METADATA_METADATA_TYPE_ALL_COMPLETED:
            return mavsdk::ComponentMetadata::MetadataType::AllCompleted;
        case MAVSDK_COMPONENT_METADATA_METADATA_TYPE_PARAMETER:
            return mavsdk::ComponentMetadata::MetadataType::Parameter;
        case MAVSDK_COMPONENT_METADATA_METADATA_TYPE_EVENTS:
            return mavsdk::ComponentMetadata::MetadataType::Events;
        case MAVSDK_COMPONENT_METADATA_METADATA_TYPE_ACTUATORS:
            return mavsdk::ComponentMetadata::MetadataType::Actuators;
    }
    return mavsdk::ComponentMetadata::MetadataType::AllCompleted;
}

static mavsdk_component_metadata_metadata_type_t
translate_metadata_type_to_c(mavsdk::ComponentMetadata::MetadataType cpp_enum) {
    switch(cpp_enum) {
        case mavsdk::ComponentMetadata::MetadataType::AllCompleted:
            return MAVSDK_COMPONENT_METADATA_METADATA_TYPE_ALL_COMPLETED;
        case mavsdk::ComponentMetadata::MetadataType::Parameter:
            return MAVSDK_COMPONENT_METADATA_METADATA_TYPE_PARAMETER;
        case mavsdk::ComponentMetadata::MetadataType::Events:
            return MAVSDK_COMPONENT_METADATA_METADATA_TYPE_EVENTS;
        case mavsdk::ComponentMetadata::MetadataType::Actuators:
            return MAVSDK_COMPONENT_METADATA_METADATA_TYPE_ACTUATORS;
    }
    return MAVSDK_COMPONENT_METADATA_METADATA_TYPE_ALL_COMPLETED;
}



static mavsdk::ComponentMetadata::MetadataData
translate_metadata_data_from_c(const mavsdk_component_metadata_metadata_data_t& c_struct) {
    mavsdk::ComponentMetadata::MetadataData cpp_struct{};
    if (c_struct.json_metadata) {
        cpp_struct.json_metadata = c_struct.json_metadata;
    }
    return cpp_struct;
}

static mavsdk_component_metadata_metadata_data_t
translate_metadata_data_to_c(const mavsdk::ComponentMetadata::MetadataData& cpp_struct) {
    mavsdk_component_metadata_metadata_data_t c_struct{};
    c_struct.json_metadata = strdup(cpp_struct.json_metadata.c_str());
    return c_struct;
}

void mavsdk_component_metadata_metadata_data_destroy(
    mavsdk_component_metadata_metadata_data_t* target) {
    if (!target) return;
    if (target->json_metadata) {
        free((void*)target->json_metadata);
        target->json_metadata = nullptr;
    }
}

void mavsdk_component_metadata_metadata_data_array_destroy(
    mavsdk_component_metadata_metadata_data_t** array,
    size_t size) {
    if (!array || !*array) return;

    for (size_t i = 0; i < size; i++) {
        mavsdk_component_metadata_metadata_data_destroy(&(*array)[i]);
    }

    delete[] *array;
    *array = nullptr;
}



static mavsdk::ComponentMetadata::MetadataUpdate
translate_metadata_update_from_c(const mavsdk_component_metadata_metadata_update_t& c_struct) {
    mavsdk::ComponentMetadata::MetadataUpdate cpp_struct{};
    cpp_struct.compid = c_struct.compid;
    cpp_struct.type = translate_metadata_type_from_c(c_struct.type);
    if (c_struct.json_metadata) {
        cpp_struct.json_metadata = c_struct.json_metadata;
    }
    return cpp_struct;
}

static mavsdk_component_metadata_metadata_update_t
translate_metadata_update_to_c(const mavsdk::ComponentMetadata::MetadataUpdate& cpp_struct) {
    mavsdk_component_metadata_metadata_update_t c_struct{};
    c_struct.compid = cpp_struct.compid;
    c_struct.type = translate_metadata_type_to_c(cpp_struct.type);
    c_struct.json_metadata = strdup(cpp_struct.json_metadata.c_str());
    return c_struct;
}

void mavsdk_component_metadata_metadata_update_destroy(
    mavsdk_component_metadata_metadata_update_t* target) {
    if (!target) return;
    if (target->json_metadata) {
        free((void*)target->json_metadata);
        target->json_metadata = nullptr;
    }
}

void mavsdk_component_metadata_metadata_update_array_destroy(
    mavsdk_component_metadata_metadata_update_t** array,
    size_t size) {
    if (!array || !*array) return;

    for (size_t i = 0; i < size; i++) {
        mavsdk_component_metadata_metadata_update_destroy(&(*array)[i]);
    }

    delete[] *array;
    *array = nullptr;
}


// ===== Primitive Array Destroy Functions =====
void mavsdk_component_metadata_float_array_destroy(float** array) {
    if (!array || !*array) return;
    delete[] *array;
    *array = nullptr;
}

void mavsdk_component_metadata_double_array_destroy(double** array) {
    if (!array || !*array) return;
    delete[] *array;
    *array = nullptr;
}

void mavsdk_component_metadata_int32t_array_destroy(int32_t** array) {
    if (!array || !*array) return;
    delete[] *array;
    *array = nullptr;
}

void mavsdk_component_metadata_uint32t_array_destroy(uint32_t** array) {
    if (!array || !*array) return;
    delete[] *array;
    *array = nullptr;
}

void mavsdk_component_metadata_int64t_array_destroy(int64_t** array) {
    if (!array || !*array) return;
    delete[] *array;
    *array = nullptr;
}

void mavsdk_component_metadata_uint64t_array_destroy(uint64_t** array) {
    if (!array || !*array) return;
    delete[] *array;
    *array = nullptr;
}

void mavsdk_component_metadata_bool_array_destroy(bool** array) {
    if (!array || !*array) return;
    delete[] *array;
    *array = nullptr;
}


void mavsdk_component_metadata_string_destroy(char** str) {
    if (!str || !*str) return;
    free(*str);
    *str = nullptr;
}

void mavsdk_component_metadata_byte_buffer_destroy(uint8_t** buffer) {
    if (!buffer || !*buffer) return;
    delete[] *buffer;
    *buffer = nullptr;
}

// ===== ComponentMetadata Wrapper =====

struct mavsdk_component_metadata_wrapper {
    std::shared_ptr<mavsdk::ComponentMetadata> cpp_plugin;
    std::mutex handles_mutex;
    std::vector<mavsdk::ComponentMetadata::MetadataAvailableHandle*> metadata_available_handles;
};

mavsdk_component_metadata_t
mavsdk_component_metadata_create(mavsdk_system_t system) {
    if (system == nullptr) {
        return nullptr;
    }

    auto wrapper = new mavsdk_component_metadata_wrapper();
    auto system_ptr = reinterpret_cast<std::shared_ptr<mavsdk::System>*>(system);
    wrapper->cpp_plugin = std::make_shared<mavsdk::ComponentMetadata>(*system_ptr);

    return reinterpret_cast<mavsdk_component_metadata_t>(wrapper);
}

void mavsdk_component_metadata_destroy(mavsdk_component_metadata_t component_metadata) {
    if (component_metadata == nullptr) {
        return;
    }

    auto wrapper = reinterpret_cast<mavsdk_component_metadata_wrapper*>(component_metadata);

    // Unsubscribe all active streams before destroying to prevent
    // callbacks firing into a destroyed object
    {
        std::lock_guard<std::mutex> lock(wrapper->handles_mutex);
        for (auto* h : wrapper->metadata_available_handles) {
            wrapper->cpp_plugin->unsubscribe_metadata_available(std::move(*h));
            delete h;
        }
        wrapper->metadata_available_handles.clear();
    }

    delete wrapper;
}

// ===== Method Implementations =====


// RequestComponent sync
void
mavsdk_component_metadata_request_component(
    mavsdk_component_metadata_t component_metadata,
    uint32_t compid)
{
    auto wrapper = reinterpret_cast<mavsdk_component_metadata_wrapper*>(component_metadata);

wrapper->cpp_plugin->request_component(        compid);

}


// RequestAutopilotComponent sync
void
mavsdk_component_metadata_request_autopilot_component(
    mavsdk_component_metadata_t component_metadata)
{
    auto wrapper = reinterpret_cast<mavsdk_component_metadata_wrapper*>(component_metadata);

wrapper->cpp_plugin->request_autopilot_component();

}

// MetadataAvailable async
mavsdk_component_metadata_metadata_available_handle_t mavsdk_component_metadata_subscribe_metadata_available(
    mavsdk_component_metadata_t component_metadata,
    mavsdk_component_metadata_metadata_available_callback_t callback,
    void* user_data)
{
    auto wrapper = reinterpret_cast<mavsdk_component_metadata_wrapper*>(component_metadata);

    auto cpp_handle =    wrapper->cpp_plugin->subscribe_metadata_available(
        [callback, user_data](
            mavsdk::ComponentMetadata::MetadataUpdate value) {
                if (callback) {
                    callback(
                        translate_metadata_update_to_c(value),
                        user_data);
                }
        });

    auto cpp_handle_ptr = new mavsdk::ComponentMetadata::MetadataAvailableHandle(std::move(cpp_handle));

    {
        std::lock_guard<std::mutex> lock(wrapper->handles_mutex);
        wrapper->metadata_available_handles.push_back(cpp_handle_ptr);
    }

    return reinterpret_cast<mavsdk_component_metadata_metadata_available_handle_t>(cpp_handle_ptr);
}

void mavsdk_component_metadata_unsubscribe_metadata_available(
    mavsdk_component_metadata_t component_metadata,
    mavsdk_component_metadata_metadata_available_handle_t handle)
{
    if (handle) {
        auto wrapper = reinterpret_cast<mavsdk_component_metadata_wrapper*>(component_metadata);
        auto cpp_handle = reinterpret_cast<mavsdk::ComponentMetadata::MetadataAvailableHandle*>(handle);

        {
            std::lock_guard<std::mutex> lock(wrapper->handles_mutex);
            auto& vec = wrapper->metadata_available_handles;
            vec.erase(std::remove(vec.begin(), vec.end(), cpp_handle), vec.end());
        }

        wrapper->cpp_plugin->unsubscribe_metadata_available(std::move(*cpp_handle));
        delete cpp_handle;
    }
}



// GetMetadata sync
mavsdk_component_metadata_result_t
mavsdk_component_metadata_get_metadata(
    mavsdk_component_metadata_t component_metadata,
    uint32_t compid,
    mavsdk_component_metadata_metadata_type_t metadata_type,
    mavsdk_component_metadata_metadata_data_t* response_out)
{
    auto wrapper = reinterpret_cast<mavsdk_component_metadata_wrapper*>(component_metadata);

    auto result_pair = wrapper->cpp_plugin->get_metadata(
        compid,
        translate_metadata_type_from_c(metadata_type));

    if (response_out != nullptr) {
        *response_out = translate_metadata_data_to_c(result_pair.second);
    }

    return translate_result(result_pair.first);
}
