// WARNING: THIS FILE IS AUTOGENERATED! As such, it should not be edited.
// Edits need to be made to the proto files
// (see https://github.com/mavlink/MAVSDK-Proto/blob/main/protos/winch/winch.proto)

#include "winch.h"

#include <mavsdk/plugins/winch/winch.h>
#include <algorithm>
#include <cstring>
#include <mutex>
#include <vector>

// ===== C++ to C Type Conversions =====

static mavsdk_winch_result_t
translate_result(mavsdk::Winch::Result cpp_result) {
    switch(cpp_result) {
        case mavsdk::Winch::Result::Unknown:
            return MAVSDK_WINCH_RESULT_UNKNOWN;
        case mavsdk::Winch::Result::Success:
            return MAVSDK_WINCH_RESULT_SUCCESS;
        case mavsdk::Winch::Result::NoSystem:
            return MAVSDK_WINCH_RESULT_NO_SYSTEM;
        case mavsdk::Winch::Result::Busy:
            return MAVSDK_WINCH_RESULT_BUSY;
        case mavsdk::Winch::Result::Timeout:
            return MAVSDK_WINCH_RESULT_TIMEOUT;
        case mavsdk::Winch::Result::Unsupported:
            return MAVSDK_WINCH_RESULT_UNSUPPORTED;
        case mavsdk::Winch::Result::Failed:
            return MAVSDK_WINCH_RESULT_FAILED;
    }
}

static mavsdk::Winch::WinchAction
translate_winch_action_from_c(mavsdk_winch_winch_action_t c_enum) {
    switch(c_enum) {
        case MAVSDK_WINCH_WINCH_ACTION_RELAXED:
            return mavsdk::Winch::WinchAction::Relaxed;
        case MAVSDK_WINCH_WINCH_ACTION_RELATIVE_LENGTH_CONTROL:
            return mavsdk::Winch::WinchAction::RelativeLengthControl;
        case MAVSDK_WINCH_WINCH_ACTION_RATE_CONTROL:
            return mavsdk::Winch::WinchAction::RateControl;
        case MAVSDK_WINCH_WINCH_ACTION_LOCK:
            return mavsdk::Winch::WinchAction::Lock;
        case MAVSDK_WINCH_WINCH_ACTION_DELIVER:
            return mavsdk::Winch::WinchAction::Deliver;
        case MAVSDK_WINCH_WINCH_ACTION_HOLD:
            return mavsdk::Winch::WinchAction::Hold;
        case MAVSDK_WINCH_WINCH_ACTION_RETRACT:
            return mavsdk::Winch::WinchAction::Retract;
        case MAVSDK_WINCH_WINCH_ACTION_LOAD_LINE:
            return mavsdk::Winch::WinchAction::LoadLine;
        case MAVSDK_WINCH_WINCH_ACTION_ABANDON_LINE:
            return mavsdk::Winch::WinchAction::AbandonLine;
        case MAVSDK_WINCH_WINCH_ACTION_LOAD_PAYLOAD:
            return mavsdk::Winch::WinchAction::LoadPayload;
    }
    return mavsdk::Winch::WinchAction::Relaxed;
}

static mavsdk_winch_winch_action_t
translate_winch_action_to_c(mavsdk::Winch::WinchAction cpp_enum) {
    switch(cpp_enum) {
        case mavsdk::Winch::WinchAction::Relaxed:
            return MAVSDK_WINCH_WINCH_ACTION_RELAXED;
        case mavsdk::Winch::WinchAction::RelativeLengthControl:
            return MAVSDK_WINCH_WINCH_ACTION_RELATIVE_LENGTH_CONTROL;
        case mavsdk::Winch::WinchAction::RateControl:
            return MAVSDK_WINCH_WINCH_ACTION_RATE_CONTROL;
        case mavsdk::Winch::WinchAction::Lock:
            return MAVSDK_WINCH_WINCH_ACTION_LOCK;
        case mavsdk::Winch::WinchAction::Deliver:
            return MAVSDK_WINCH_WINCH_ACTION_DELIVER;
        case mavsdk::Winch::WinchAction::Hold:
            return MAVSDK_WINCH_WINCH_ACTION_HOLD;
        case mavsdk::Winch::WinchAction::Retract:
            return MAVSDK_WINCH_WINCH_ACTION_RETRACT;
        case mavsdk::Winch::WinchAction::LoadLine:
            return MAVSDK_WINCH_WINCH_ACTION_LOAD_LINE;
        case mavsdk::Winch::WinchAction::AbandonLine:
            return MAVSDK_WINCH_WINCH_ACTION_ABANDON_LINE;
        case mavsdk::Winch::WinchAction::LoadPayload:
            return MAVSDK_WINCH_WINCH_ACTION_LOAD_PAYLOAD;
    }
    return MAVSDK_WINCH_WINCH_ACTION_RELAXED;
}



static mavsdk::Winch::StatusFlags
translate_status_flags_from_c(const mavsdk_winch_status_flags_t& c_struct) {
    mavsdk::Winch::StatusFlags cpp_struct{};
    cpp_struct.healthy = c_struct.healthy;
    cpp_struct.fully_retracted = c_struct.fully_retracted;
    cpp_struct.moving = c_struct.moving;
    cpp_struct.clutch_engaged = c_struct.clutch_engaged;
    cpp_struct.locked = c_struct.locked;
    cpp_struct.dropping = c_struct.dropping;
    cpp_struct.arresting = c_struct.arresting;
    cpp_struct.ground_sense = c_struct.ground_sense;
    cpp_struct.retracting = c_struct.retracting;
    cpp_struct.redeliver = c_struct.redeliver;
    cpp_struct.abandon_line = c_struct.abandon_line;
    cpp_struct.locking = c_struct.locking;
    cpp_struct.load_line = c_struct.load_line;
    cpp_struct.load_payload = c_struct.load_payload;
    return cpp_struct;
}

static mavsdk_winch_status_flags_t
translate_status_flags_to_c(const mavsdk::Winch::StatusFlags& cpp_struct) {
    mavsdk_winch_status_flags_t c_struct{};
    c_struct.healthy = cpp_struct.healthy;
    c_struct.fully_retracted = cpp_struct.fully_retracted;
    c_struct.moving = cpp_struct.moving;
    c_struct.clutch_engaged = cpp_struct.clutch_engaged;
    c_struct.locked = cpp_struct.locked;
    c_struct.dropping = cpp_struct.dropping;
    c_struct.arresting = cpp_struct.arresting;
    c_struct.ground_sense = cpp_struct.ground_sense;
    c_struct.retracting = cpp_struct.retracting;
    c_struct.redeliver = cpp_struct.redeliver;
    c_struct.abandon_line = cpp_struct.abandon_line;
    c_struct.locking = cpp_struct.locking;
    c_struct.load_line = cpp_struct.load_line;
    c_struct.load_payload = cpp_struct.load_payload;
    return c_struct;
}

void mavsdk_winch_status_flags_destroy(
    mavsdk_winch_status_flags_t* target) {
    if (!target) return;
}

void mavsdk_winch_status_flags_array_destroy(
    mavsdk_winch_status_flags_t** array,
    size_t size) {
    if (!array || !*array) return;

    for (size_t i = 0; i < size; i++) {
        mavsdk_winch_status_flags_destroy(&(*array)[i]);
    }

    delete[] *array;
    *array = nullptr;
}


static mavsdk::Winch::Status
translate_status_from_c(const mavsdk_winch_status_t& c_struct) {
    mavsdk::Winch::Status cpp_struct{};
    cpp_struct.time_usec = c_struct.time_usec;
    cpp_struct.line_length_m = c_struct.line_length_m;
    cpp_struct.speed_m_s = c_struct.speed_m_s;
    cpp_struct.tension_kg = c_struct.tension_kg;
    cpp_struct.voltage_v = c_struct.voltage_v;
    cpp_struct.current_a = c_struct.current_a;
    cpp_struct.temperature_c = c_struct.temperature_c;
    cpp_struct.status_flags = translate_status_flags_from_c(c_struct.status_flags);
    return cpp_struct;
}

static mavsdk_winch_status_t
translate_status_to_c(const mavsdk::Winch::Status& cpp_struct) {
    mavsdk_winch_status_t c_struct{};
    c_struct.time_usec = cpp_struct.time_usec;
    c_struct.line_length_m = cpp_struct.line_length_m;
    c_struct.speed_m_s = cpp_struct.speed_m_s;
    c_struct.tension_kg = cpp_struct.tension_kg;
    c_struct.voltage_v = cpp_struct.voltage_v;
    c_struct.current_a = cpp_struct.current_a;
    c_struct.temperature_c = cpp_struct.temperature_c;
    c_struct.status_flags = translate_status_flags_to_c(cpp_struct.status_flags);
    return c_struct;
}

void mavsdk_winch_status_destroy(
    mavsdk_winch_status_t* target) {
    if (!target) return;
}

void mavsdk_winch_status_array_destroy(
    mavsdk_winch_status_t** array,
    size_t size) {
    if (!array || !*array) return;

    for (size_t i = 0; i < size; i++) {
        mavsdk_winch_status_destroy(&(*array)[i]);
    }

    delete[] *array;
    *array = nullptr;
}



// ===== Primitive Array Destroy Functions =====
void mavsdk_winch_float_array_destroy(float** array) {
    if (!array || !*array) return;
    delete[] *array;
    *array = nullptr;
}

void mavsdk_winch_double_array_destroy(double** array) {
    if (!array || !*array) return;
    delete[] *array;
    *array = nullptr;
}

void mavsdk_winch_int32t_array_destroy(int32_t** array) {
    if (!array || !*array) return;
    delete[] *array;
    *array = nullptr;
}

void mavsdk_winch_uint32t_array_destroy(uint32_t** array) {
    if (!array || !*array) return;
    delete[] *array;
    *array = nullptr;
}

void mavsdk_winch_int64t_array_destroy(int64_t** array) {
    if (!array || !*array) return;
    delete[] *array;
    *array = nullptr;
}

void mavsdk_winch_uint64t_array_destroy(uint64_t** array) {
    if (!array || !*array) return;
    delete[] *array;
    *array = nullptr;
}

void mavsdk_winch_bool_array_destroy(bool** array) {
    if (!array || !*array) return;
    delete[] *array;
    *array = nullptr;
}


void mavsdk_winch_string_destroy(char** str) {
    if (!str || !*str) return;
    free(*str);
    *str = nullptr;
}

void mavsdk_winch_byte_buffer_destroy(uint8_t** buffer) {
    if (!buffer || !*buffer) return;
    delete[] *buffer;
    *buffer = nullptr;
}

// ===== Winch Wrapper =====

struct mavsdk_winch_wrapper {
    std::shared_ptr<mavsdk::Winch> cpp_plugin;
    std::mutex handles_mutex;
    std::vector<mavsdk::Winch::StatusHandle*> status_handles;
};

mavsdk_winch_t
mavsdk_winch_create(mavsdk_system_t system) {
    if (system == nullptr) {
        return nullptr;
    }

    auto wrapper = new mavsdk_winch_wrapper();
    auto system_ptr = reinterpret_cast<std::shared_ptr<mavsdk::System>*>(system);
    wrapper->cpp_plugin = std::make_shared<mavsdk::Winch>(*system_ptr);

    return reinterpret_cast<mavsdk_winch_t>(wrapper);
}

void mavsdk_winch_destroy(mavsdk_winch_t winch) {
    if (winch == nullptr) {
        return;
    }

    auto wrapper = reinterpret_cast<mavsdk_winch_wrapper*>(winch);

    // Unsubscribe all active streams before destroying to prevent
    // callbacks firing into a destroyed object
    {
        std::lock_guard<std::mutex> lock(wrapper->handles_mutex);
        for (auto* h : wrapper->status_handles) {
            wrapper->cpp_plugin->unsubscribe_status(std::move(*h));
            delete h;
        }
        wrapper->status_handles.clear();
    }

    delete wrapper;
}

// ===== Method Implementations =====

// Status async
mavsdk_winch_status_handle_t mavsdk_winch_subscribe_status(
    mavsdk_winch_t winch,
    mavsdk_winch_status_callback_t callback,
    void* user_data)
{
    auto wrapper = reinterpret_cast<mavsdk_winch_wrapper*>(winch);

    auto cpp_handle =    wrapper->cpp_plugin->subscribe_status(
        [callback, user_data](
            mavsdk::Winch::Status value) {
                if (callback) {
                    callback(
                        translate_status_to_c(value),
                        user_data);
                }
        });

    auto cpp_handle_ptr = new mavsdk::Winch::StatusHandle(std::move(cpp_handle));

    {
        std::lock_guard<std::mutex> lock(wrapper->handles_mutex);
        wrapper->status_handles.push_back(cpp_handle_ptr);
    }

    return reinterpret_cast<mavsdk_winch_status_handle_t>(cpp_handle_ptr);
}

void mavsdk_winch_unsubscribe_status(
    mavsdk_winch_t winch,
    mavsdk_winch_status_handle_t handle)
{
    if (handle) {
        auto wrapper = reinterpret_cast<mavsdk_winch_wrapper*>(winch);
        auto cpp_handle = reinterpret_cast<mavsdk::Winch::StatusHandle*>(handle);

        {
            std::lock_guard<std::mutex> lock(wrapper->handles_mutex);
            auto& vec = wrapper->status_handles;
            vec.erase(std::remove(vec.begin(), vec.end(), cpp_handle), vec.end());
        }

        wrapper->cpp_plugin->unsubscribe_status(std::move(*cpp_handle));
        delete cpp_handle;
    }
}

// Status sync
void
mavsdk_winch_status(
    mavsdk_winch_t winch,
    mavsdk_winch_status_t* status_out)
{
    auto wrapper = reinterpret_cast<mavsdk_winch_wrapper*>(winch);

    auto ret_value = wrapper->cpp_plugin->status();

    if (status_out != nullptr) {
        *status_out = translate_status_to_c(ret_value);
    }
}

// Relax async
void mavsdk_winch_relax_async(
    mavsdk_winch_t winch,
    uint32_t instance,
    mavsdk_winch_relax_callback_t callback,
    void* user_data)
{
    auto wrapper = reinterpret_cast<mavsdk_winch_wrapper*>(winch);

    wrapper->cpp_plugin->relax_async(
        instance,
        [callback, user_data](
            mavsdk::Winch::Result result) {
                if (callback) {
                    callback(
                        translate_result(result),
                        user_data);
                }
        });
}


// Relax sync
mavsdk_winch_result_t
mavsdk_winch_relax(
    mavsdk_winch_t winch,
    uint32_t instance)
{
    auto wrapper = reinterpret_cast<mavsdk_winch_wrapper*>(winch);

    auto ret_value = wrapper->cpp_plugin->relax(        instance);

    return translate_result(ret_value);
}

// RelativeLengthControl async
void mavsdk_winch_relative_length_control_async(
    mavsdk_winch_t winch,
    uint32_t instance,
    float length_m,
    float rate_m_s,
    mavsdk_winch_relative_length_control_callback_t callback,
    void* user_data)
{
    auto wrapper = reinterpret_cast<mavsdk_winch_wrapper*>(winch);

    wrapper->cpp_plugin->relative_length_control_async(
        instance,
        length_m,
        rate_m_s,
        [callback, user_data](
            mavsdk::Winch::Result result) {
                if (callback) {
                    callback(
                        translate_result(result),
                        user_data);
                }
        });
}


// RelativeLengthControl sync
mavsdk_winch_result_t
mavsdk_winch_relative_length_control(
    mavsdk_winch_t winch,
    uint32_t instance,
    float length_m,
    float rate_m_s)
{
    auto wrapper = reinterpret_cast<mavsdk_winch_wrapper*>(winch);

    auto ret_value = wrapper->cpp_plugin->relative_length_control(        instance,        length_m,        rate_m_s);

    return translate_result(ret_value);
}

// RateControl async
void mavsdk_winch_rate_control_async(
    mavsdk_winch_t winch,
    uint32_t instance,
    float rate_m_s,
    mavsdk_winch_rate_control_callback_t callback,
    void* user_data)
{
    auto wrapper = reinterpret_cast<mavsdk_winch_wrapper*>(winch);

    wrapper->cpp_plugin->rate_control_async(
        instance,
        rate_m_s,
        [callback, user_data](
            mavsdk::Winch::Result result) {
                if (callback) {
                    callback(
                        translate_result(result),
                        user_data);
                }
        });
}


// RateControl sync
mavsdk_winch_result_t
mavsdk_winch_rate_control(
    mavsdk_winch_t winch,
    uint32_t instance,
    float rate_m_s)
{
    auto wrapper = reinterpret_cast<mavsdk_winch_wrapper*>(winch);

    auto ret_value = wrapper->cpp_plugin->rate_control(        instance,        rate_m_s);

    return translate_result(ret_value);
}

// Lock async
void mavsdk_winch_lock_async(
    mavsdk_winch_t winch,
    uint32_t instance,
    mavsdk_winch_lock_callback_t callback,
    void* user_data)
{
    auto wrapper = reinterpret_cast<mavsdk_winch_wrapper*>(winch);

    wrapper->cpp_plugin->lock_async(
        instance,
        [callback, user_data](
            mavsdk::Winch::Result result) {
                if (callback) {
                    callback(
                        translate_result(result),
                        user_data);
                }
        });
}


// Lock sync
mavsdk_winch_result_t
mavsdk_winch_lock(
    mavsdk_winch_t winch,
    uint32_t instance)
{
    auto wrapper = reinterpret_cast<mavsdk_winch_wrapper*>(winch);

    auto ret_value = wrapper->cpp_plugin->lock(        instance);

    return translate_result(ret_value);
}

// Deliver async
void mavsdk_winch_deliver_async(
    mavsdk_winch_t winch,
    uint32_t instance,
    mavsdk_winch_deliver_callback_t callback,
    void* user_data)
{
    auto wrapper = reinterpret_cast<mavsdk_winch_wrapper*>(winch);

    wrapper->cpp_plugin->deliver_async(
        instance,
        [callback, user_data](
            mavsdk::Winch::Result result) {
                if (callback) {
                    callback(
                        translate_result(result),
                        user_data);
                }
        });
}


// Deliver sync
mavsdk_winch_result_t
mavsdk_winch_deliver(
    mavsdk_winch_t winch,
    uint32_t instance)
{
    auto wrapper = reinterpret_cast<mavsdk_winch_wrapper*>(winch);

    auto ret_value = wrapper->cpp_plugin->deliver(        instance);

    return translate_result(ret_value);
}

// Hold async
void mavsdk_winch_hold_async(
    mavsdk_winch_t winch,
    uint32_t instance,
    mavsdk_winch_hold_callback_t callback,
    void* user_data)
{
    auto wrapper = reinterpret_cast<mavsdk_winch_wrapper*>(winch);

    wrapper->cpp_plugin->hold_async(
        instance,
        [callback, user_data](
            mavsdk::Winch::Result result) {
                if (callback) {
                    callback(
                        translate_result(result),
                        user_data);
                }
        });
}


// Hold sync
mavsdk_winch_result_t
mavsdk_winch_hold(
    mavsdk_winch_t winch,
    uint32_t instance)
{
    auto wrapper = reinterpret_cast<mavsdk_winch_wrapper*>(winch);

    auto ret_value = wrapper->cpp_plugin->hold(        instance);

    return translate_result(ret_value);
}

// Retract async
void mavsdk_winch_retract_async(
    mavsdk_winch_t winch,
    uint32_t instance,
    mavsdk_winch_retract_callback_t callback,
    void* user_data)
{
    auto wrapper = reinterpret_cast<mavsdk_winch_wrapper*>(winch);

    wrapper->cpp_plugin->retract_async(
        instance,
        [callback, user_data](
            mavsdk::Winch::Result result) {
                if (callback) {
                    callback(
                        translate_result(result),
                        user_data);
                }
        });
}


// Retract sync
mavsdk_winch_result_t
mavsdk_winch_retract(
    mavsdk_winch_t winch,
    uint32_t instance)
{
    auto wrapper = reinterpret_cast<mavsdk_winch_wrapper*>(winch);

    auto ret_value = wrapper->cpp_plugin->retract(        instance);

    return translate_result(ret_value);
}

// LoadLine async
void mavsdk_winch_load_line_async(
    mavsdk_winch_t winch,
    uint32_t instance,
    mavsdk_winch_load_line_callback_t callback,
    void* user_data)
{
    auto wrapper = reinterpret_cast<mavsdk_winch_wrapper*>(winch);

    wrapper->cpp_plugin->load_line_async(
        instance,
        [callback, user_data](
            mavsdk::Winch::Result result) {
                if (callback) {
                    callback(
                        translate_result(result),
                        user_data);
                }
        });
}


// LoadLine sync
mavsdk_winch_result_t
mavsdk_winch_load_line(
    mavsdk_winch_t winch,
    uint32_t instance)
{
    auto wrapper = reinterpret_cast<mavsdk_winch_wrapper*>(winch);

    auto ret_value = wrapper->cpp_plugin->load_line(        instance);

    return translate_result(ret_value);
}

// AbandonLine async
void mavsdk_winch_abandon_line_async(
    mavsdk_winch_t winch,
    uint32_t instance,
    mavsdk_winch_abandon_line_callback_t callback,
    void* user_data)
{
    auto wrapper = reinterpret_cast<mavsdk_winch_wrapper*>(winch);

    wrapper->cpp_plugin->abandon_line_async(
        instance,
        [callback, user_data](
            mavsdk::Winch::Result result) {
                if (callback) {
                    callback(
                        translate_result(result),
                        user_data);
                }
        });
}


// AbandonLine sync
mavsdk_winch_result_t
mavsdk_winch_abandon_line(
    mavsdk_winch_t winch,
    uint32_t instance)
{
    auto wrapper = reinterpret_cast<mavsdk_winch_wrapper*>(winch);

    auto ret_value = wrapper->cpp_plugin->abandon_line(        instance);

    return translate_result(ret_value);
}

// LoadPayload async
void mavsdk_winch_load_payload_async(
    mavsdk_winch_t winch,
    uint32_t instance,
    mavsdk_winch_load_payload_callback_t callback,
    void* user_data)
{
    auto wrapper = reinterpret_cast<mavsdk_winch_wrapper*>(winch);

    wrapper->cpp_plugin->load_payload_async(
        instance,
        [callback, user_data](
            mavsdk::Winch::Result result) {
                if (callback) {
                    callback(
                        translate_result(result),
                        user_data);
                }
        });
}


// LoadPayload sync
mavsdk_winch_result_t
mavsdk_winch_load_payload(
    mavsdk_winch_t winch,
    uint32_t instance)
{
    auto wrapper = reinterpret_cast<mavsdk_winch_wrapper*>(winch);

    auto ret_value = wrapper->cpp_plugin->load_payload(        instance);

    return translate_result(ret_value);
}
