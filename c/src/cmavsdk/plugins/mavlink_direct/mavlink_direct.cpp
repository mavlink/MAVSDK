// WARNING: THIS FILE IS AUTOGENERATED! As such, it should not be edited.
// Edits need to be made to the proto files
// (see https://github.com/mavlink/MAVSDK-Proto/blob/main/protos/mavlink_direct/mavlink_direct.proto)

#include "mavlink_direct.h"

#include <mavsdk/plugins/mavlink_direct/mavlink_direct.h>
#include <cstring>
#include <vector>

// ===== C++ to C Type Conversions =====

static mavsdk_mavlink_direct_result_t
translate_result(mavsdk::MavlinkDirect::Result cpp_result) {
    switch(cpp_result) {
        case mavsdk::MavlinkDirect::Result::Unknown:
            return MAVSDK_MAVLINK_DIRECT_RESULT_UNKNOWN;
        case mavsdk::MavlinkDirect::Result::Success:
            return MAVSDK_MAVLINK_DIRECT_RESULT_SUCCESS;
        case mavsdk::MavlinkDirect::Result::Error:
            return MAVSDK_MAVLINK_DIRECT_RESULT_ERROR;
        case mavsdk::MavlinkDirect::Result::InvalidMessage:
            return MAVSDK_MAVLINK_DIRECT_RESULT_INVALID_MESSAGE;
        case mavsdk::MavlinkDirect::Result::InvalidField:
            return MAVSDK_MAVLINK_DIRECT_RESULT_INVALID_FIELD;
        case mavsdk::MavlinkDirect::Result::ConnectionError:
            return MAVSDK_MAVLINK_DIRECT_RESULT_CONNECTION_ERROR;
        case mavsdk::MavlinkDirect::Result::NoSystem:
            return MAVSDK_MAVLINK_DIRECT_RESULT_NO_SYSTEM;
        case mavsdk::MavlinkDirect::Result::Timeout:
            return MAVSDK_MAVLINK_DIRECT_RESULT_TIMEOUT;
    }
}



static mavsdk::MavlinkDirect::MavlinkMessage
translate_mavlink_message_from_c(const mavsdk_mavlink_direct_mavlink_message_t& c_struct) {
    mavsdk::MavlinkDirect::MavlinkMessage cpp_struct{};
    if (c_struct.message_name) {
        cpp_struct.message_name = c_struct.message_name;
    }
    cpp_struct.system_id = c_struct.system_id;
    cpp_struct.component_id = c_struct.component_id;
    cpp_struct.target_system_id = c_struct.target_system_id;
    cpp_struct.target_component_id = c_struct.target_component_id;
    if (c_struct.fields_json) {
        cpp_struct.fields_json = c_struct.fields_json;
    }
    return cpp_struct;
}

static mavsdk_mavlink_direct_mavlink_message_t
translate_mavlink_message_to_c(const mavsdk::MavlinkDirect::MavlinkMessage& cpp_struct) {
    mavsdk_mavlink_direct_mavlink_message_t c_struct{};
    c_struct.message_name = strdup(cpp_struct.message_name.c_str());
    c_struct.system_id = cpp_struct.system_id;
    c_struct.component_id = cpp_struct.component_id;
    c_struct.target_system_id = cpp_struct.target_system_id;
    c_struct.target_component_id = cpp_struct.target_component_id;
    c_struct.fields_json = strdup(cpp_struct.fields_json.c_str());
    return c_struct;
}

void mavsdk_mavlink_direct_mavlink_message_destroy(
    mavsdk_mavlink_direct_mavlink_message_t* target) {
    if (!target) return;
    if (target->message_name) {
        free((void*)target->message_name);
        target->message_name = nullptr;
    }
    if (target->fields_json) {
        free((void*)target->fields_json);
        target->fields_json = nullptr;
    }
}

void mavsdk_mavlink_direct_mavlink_message_array_destroy(
    mavsdk_mavlink_direct_mavlink_message_t** array,
    size_t size) {
    if (!array || !*array) return;

    for (size_t i = 0; i < size; i++) {
        mavsdk_mavlink_direct_mavlink_message_destroy(&(*array)[i]);
    }

    delete[] *array;
    *array = nullptr;
}



// ===== Primitive Array Destroy Functions =====
void mavsdk_mavlink_direct_float_array_destroy(float** array) {
    if (!array || !*array) return;
    delete[] *array;
    *array = nullptr;
}

void mavsdk_mavlink_direct_double_array_destroy(double** array) {
    if (!array || !*array) return;
    delete[] *array;
    *array = nullptr;
}

void mavsdk_mavlink_direct_int32t_array_destroy(int32_t** array) {
    if (!array || !*array) return;
    delete[] *array;
    *array = nullptr;
}

void mavsdk_mavlink_direct_uint32t_array_destroy(uint32_t** array) {
    if (!array || !*array) return;
    delete[] *array;
    *array = nullptr;
}

void mavsdk_mavlink_direct_int64t_array_destroy(int64_t** array) {
    if (!array || !*array) return;
    delete[] *array;
    *array = nullptr;
}

void mavsdk_mavlink_direct_uint64t_array_destroy(uint64_t** array) {
    if (!array || !*array) return;
    delete[] *array;
    *array = nullptr;
}

void mavsdk_mavlink_direct_bool_array_destroy(bool** array) {
    if (!array || !*array) return;
    delete[] *array;
    *array = nullptr;
}


void mavsdk_mavlink_direct_string_destroy(char** str) {
    if (!str || !*str) return;
    free(*str);
    *str = nullptr;
}

void mavsdk_mavlink_direct_byte_buffer_destroy(uint8_t** buffer) {
    if (!buffer || !*buffer) return;
    delete[] *buffer;
    *buffer = nullptr;
}

// ===== MavlinkDirect Wrapper =====

struct mavsdk_mavlink_direct_wrapper {
    std::shared_ptr<mavsdk::MavlinkDirect> cpp_plugin;
};

mavsdk_mavlink_direct_t
mavsdk_mavlink_direct_create(mavsdk_system_t system) {
    if (system == nullptr) {
        return nullptr;
    }

    auto wrapper = new mavsdk_mavlink_direct_wrapper();
    auto system_ptr = reinterpret_cast<std::shared_ptr<mavsdk::System>*>(system);
    wrapper->cpp_plugin = std::make_shared<mavsdk::MavlinkDirect>(*system_ptr);

    return reinterpret_cast<mavsdk_mavlink_direct_t>(wrapper);
}

void mavsdk_mavlink_direct_destroy(mavsdk_mavlink_direct_t mavlink_direct) {
    if (mavlink_direct == nullptr) {
        return;
    }

    auto wrapper = reinterpret_cast<mavsdk_mavlink_direct_wrapper*>(mavlink_direct);
    delete wrapper;
}

// ===== Method Implementations =====


// SendMessage sync
mavsdk_mavlink_direct_result_t
mavsdk_mavlink_direct_send_message(
    mavsdk_mavlink_direct_t mavlink_direct,
    mavsdk_mavlink_direct_mavlink_message_t message)
{
    auto wrapper = reinterpret_cast<mavsdk_mavlink_direct_wrapper*>(mavlink_direct);

    auto ret_value = wrapper->cpp_plugin->send_message(        translate_mavlink_message_from_c(message));

    return translate_result(ret_value);
}

// Message async
mavsdk_mavlink_direct_message_handle_t mavsdk_mavlink_direct_subscribe_message(
    mavsdk_mavlink_direct_t mavlink_direct,
    char* message_name,
    mavsdk_mavlink_direct_message_callback_t callback,
    void* user_data)
{
    auto wrapper = reinterpret_cast<mavsdk_mavlink_direct_wrapper*>(mavlink_direct);

    auto cpp_handle =    wrapper->cpp_plugin->subscribe_message(
        message_name,
        [callback, user_data](
            mavsdk::MavlinkDirect::MavlinkMessage value) {
                if (callback) {
                    callback(
                        translate_mavlink_message_to_c(value),
                        user_data);
                }
        });

    auto handle_wrapper = new mavsdk::MavlinkDirect::MessageHandle(std::move(cpp_handle));
    return reinterpret_cast<mavsdk_mavlink_direct_message_handle_t>(handle_wrapper);
}

void mavsdk_mavlink_direct_unsubscribe_message(
    mavsdk_mavlink_direct_t mavlink_direct,
    mavsdk_mavlink_direct_message_handle_t handle)
{
    if (handle) {
        auto wrapper = reinterpret_cast<mavsdk_mavlink_direct_wrapper*>(mavlink_direct);
        auto cpp_handle = reinterpret_cast<mavsdk::MavlinkDirect::MessageHandle*>(handle);
        wrapper->cpp_plugin->unsubscribe_message(std::move(*cpp_handle));
        delete cpp_handle;
    }
}



// LoadCustomXml sync
mavsdk_mavlink_direct_result_t
mavsdk_mavlink_direct_load_custom_xml(
    mavsdk_mavlink_direct_t mavlink_direct,
    char* xml_content)
{
    auto wrapper = reinterpret_cast<mavsdk_mavlink_direct_wrapper*>(mavlink_direct);

    auto ret_value = wrapper->cpp_plugin->load_custom_xml(        xml_content);

    return translate_result(ret_value);
}
