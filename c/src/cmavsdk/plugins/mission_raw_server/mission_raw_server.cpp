// WARNING: THIS FILE IS AUTOGENERATED! As such, it should not be edited.
// Edits need to be made to the proto files
// (see https://github.com/mavlink/MAVSDK-Proto/blob/main/protos/mission_raw_server/mission_raw_server.proto)

#include "mission_raw_server.h"

#include <mavsdk/plugins/mission_raw_server/mission_raw_server.h>
#include <algorithm>
#include <cstring>
#include <mutex>
#include <vector>

// ===== C++ to C Type Conversions =====

static mavsdk_mission_raw_server_result_t
translate_result(mavsdk::MissionRawServer::Result cpp_result) {
    switch(cpp_result) {
        case mavsdk::MissionRawServer::Result::Unknown:
            return MAVSDK_MISSION_RAW_SERVER_RESULT_UNKNOWN;
        case mavsdk::MissionRawServer::Result::Success:
            return MAVSDK_MISSION_RAW_SERVER_RESULT_SUCCESS;
        case mavsdk::MissionRawServer::Result::Error:
            return MAVSDK_MISSION_RAW_SERVER_RESULT_ERROR;
        case mavsdk::MissionRawServer::Result::TooManyMissionItems:
            return MAVSDK_MISSION_RAW_SERVER_RESULT_TOO_MANY_MISSION_ITEMS;
        case mavsdk::MissionRawServer::Result::Busy:
            return MAVSDK_MISSION_RAW_SERVER_RESULT_BUSY;
        case mavsdk::MissionRawServer::Result::Timeout:
            return MAVSDK_MISSION_RAW_SERVER_RESULT_TIMEOUT;
        case mavsdk::MissionRawServer::Result::InvalidArgument:
            return MAVSDK_MISSION_RAW_SERVER_RESULT_INVALID_ARGUMENT;
        case mavsdk::MissionRawServer::Result::Unsupported:
            return MAVSDK_MISSION_RAW_SERVER_RESULT_UNSUPPORTED;
        case mavsdk::MissionRawServer::Result::NoMissionAvailable:
            return MAVSDK_MISSION_RAW_SERVER_RESULT_NO_MISSION_AVAILABLE;
        case mavsdk::MissionRawServer::Result::UnsupportedMissionCmd:
            return MAVSDK_MISSION_RAW_SERVER_RESULT_UNSUPPORTED_MISSION_CMD;
        case mavsdk::MissionRawServer::Result::TransferCancelled:
            return MAVSDK_MISSION_RAW_SERVER_RESULT_TRANSFER_CANCELLED;
        case mavsdk::MissionRawServer::Result::NoSystem:
            return MAVSDK_MISSION_RAW_SERVER_RESULT_NO_SYSTEM;
        case mavsdk::MissionRawServer::Result::Next:
            return MAVSDK_MISSION_RAW_SERVER_RESULT_NEXT;
    }
}



static mavsdk::MissionRawServer::MissionItem
translate_mission_item_from_c(const mavsdk_mission_raw_server_mission_item_t& c_struct) {
    mavsdk::MissionRawServer::MissionItem cpp_struct{};
    cpp_struct.seq = c_struct.seq;
    cpp_struct.frame = c_struct.frame;
    cpp_struct.command = c_struct.command;
    cpp_struct.current = c_struct.current;
    cpp_struct.autocontinue = c_struct.autocontinue;
    cpp_struct.param1 = c_struct.param1;
    cpp_struct.param2 = c_struct.param2;
    cpp_struct.param3 = c_struct.param3;
    cpp_struct.param4 = c_struct.param4;
    cpp_struct.x = c_struct.x;
    cpp_struct.y = c_struct.y;
    cpp_struct.z = c_struct.z;
    cpp_struct.mission_type = c_struct.mission_type;
    return cpp_struct;
}

static mavsdk_mission_raw_server_mission_item_t
translate_mission_item_to_c(const mavsdk::MissionRawServer::MissionItem& cpp_struct) {
    mavsdk_mission_raw_server_mission_item_t c_struct{};
    c_struct.seq = cpp_struct.seq;
    c_struct.frame = cpp_struct.frame;
    c_struct.command = cpp_struct.command;
    c_struct.current = cpp_struct.current;
    c_struct.autocontinue = cpp_struct.autocontinue;
    c_struct.param1 = cpp_struct.param1;
    c_struct.param2 = cpp_struct.param2;
    c_struct.param3 = cpp_struct.param3;
    c_struct.param4 = cpp_struct.param4;
    c_struct.x = cpp_struct.x;
    c_struct.y = cpp_struct.y;
    c_struct.z = cpp_struct.z;
    c_struct.mission_type = cpp_struct.mission_type;
    return c_struct;
}

void mavsdk_mission_raw_server_mission_item_destroy(
    mavsdk_mission_raw_server_mission_item_t* target) {
    if (!target) return;
}

void mavsdk_mission_raw_server_mission_item_array_destroy(
    mavsdk_mission_raw_server_mission_item_t** array,
    size_t size) {
    if (!array || !*array) return;

    for (size_t i = 0; i < size; i++) {
        mavsdk_mission_raw_server_mission_item_destroy(&(*array)[i]);
    }

    delete[] *array;
    *array = nullptr;
}


static mavsdk::MissionRawServer::MissionPlan
translate_mission_plan_from_c(const mavsdk_mission_raw_server_mission_plan_t& c_struct) {
    mavsdk::MissionRawServer::MissionPlan cpp_struct{};
    cpp_struct.mission_items.reserve(c_struct.mission_items_size);
    for (size_t i = 0; i < c_struct.mission_items_size; i++) {
        cpp_struct.mission_items.push_back(
            translate_mission_item_from_c(c_struct.mission_items[i]));
    }
    return cpp_struct;
}

static mavsdk_mission_raw_server_mission_plan_t
translate_mission_plan_to_c(const mavsdk::MissionRawServer::MissionPlan& cpp_struct) {
    mavsdk_mission_raw_server_mission_plan_t c_struct{};
    c_struct.mission_items_size = cpp_struct.mission_items.size();
    c_struct.mission_items = new mavsdk_mission_raw_server_mission_item_t[c_struct.mission_items_size];
    for (size_t i = 0; i < c_struct.mission_items_size; i++) {
        c_struct.mission_items[i] = translate_mission_item_to_c(cpp_struct.mission_items[i]);
    }
    return c_struct;
}

void mavsdk_mission_raw_server_mission_plan_destroy(
    mavsdk_mission_raw_server_mission_plan_t* target) {
    if (!target) return;
    if (target->mission_items) {
        for (size_t i = 0; i < target->mission_items_size; i++) {
            mavsdk_mission_raw_server_mission_item_destroy(&target->mission_items[i]);
        }
        delete[] target->mission_items;
        target->mission_items = nullptr;
        target->mission_items_size = 0;
    }
}

void mavsdk_mission_raw_server_mission_plan_array_destroy(
    mavsdk_mission_raw_server_mission_plan_t** array,
    size_t size) {
    if (!array || !*array) return;

    for (size_t i = 0; i < size; i++) {
        mavsdk_mission_raw_server_mission_plan_destroy(&(*array)[i]);
    }

    delete[] *array;
    *array = nullptr;
}


static mavsdk::MissionRawServer::MissionProgress
translate_mission_progress_from_c(const mavsdk_mission_raw_server_mission_progress_t& c_struct) {
    mavsdk::MissionRawServer::MissionProgress cpp_struct{};
    cpp_struct.current = c_struct.current;
    cpp_struct.total = c_struct.total;
    return cpp_struct;
}

static mavsdk_mission_raw_server_mission_progress_t
translate_mission_progress_to_c(const mavsdk::MissionRawServer::MissionProgress& cpp_struct) {
    mavsdk_mission_raw_server_mission_progress_t c_struct{};
    c_struct.current = cpp_struct.current;
    c_struct.total = cpp_struct.total;
    return c_struct;
}

void mavsdk_mission_raw_server_mission_progress_destroy(
    mavsdk_mission_raw_server_mission_progress_t* target) {
    if (!target) return;
}

void mavsdk_mission_raw_server_mission_progress_array_destroy(
    mavsdk_mission_raw_server_mission_progress_t** array,
    size_t size) {
    if (!array || !*array) return;

    for (size_t i = 0; i < size; i++) {
        mavsdk_mission_raw_server_mission_progress_destroy(&(*array)[i]);
    }

    delete[] *array;
    *array = nullptr;
}



// ===== Primitive Array Destroy Functions =====
void mavsdk_mission_raw_server_float_array_destroy(float** array) {
    if (!array || !*array) return;
    delete[] *array;
    *array = nullptr;
}

void mavsdk_mission_raw_server_double_array_destroy(double** array) {
    if (!array || !*array) return;
    delete[] *array;
    *array = nullptr;
}

void mavsdk_mission_raw_server_int32t_array_destroy(int32_t** array) {
    if (!array || !*array) return;
    delete[] *array;
    *array = nullptr;
}

void mavsdk_mission_raw_server_uint32t_array_destroy(uint32_t** array) {
    if (!array || !*array) return;
    delete[] *array;
    *array = nullptr;
}

void mavsdk_mission_raw_server_int64t_array_destroy(int64_t** array) {
    if (!array || !*array) return;
    delete[] *array;
    *array = nullptr;
}

void mavsdk_mission_raw_server_uint64t_array_destroy(uint64_t** array) {
    if (!array || !*array) return;
    delete[] *array;
    *array = nullptr;
}

void mavsdk_mission_raw_server_bool_array_destroy(bool** array) {
    if (!array || !*array) return;
    delete[] *array;
    *array = nullptr;
}


void mavsdk_mission_raw_server_string_destroy(char** str) {
    if (!str || !*str) return;
    free(*str);
    *str = nullptr;
}

void mavsdk_mission_raw_server_byte_buffer_destroy(uint8_t** buffer) {
    if (!buffer || !*buffer) return;
    delete[] *buffer;
    *buffer = nullptr;
}

// ===== MissionRawServer Wrapper =====

struct mavsdk_mission_raw_server_wrapper {
    std::shared_ptr<mavsdk::MissionRawServer> cpp_plugin;
    std::mutex handles_mutex;
    std::vector<mavsdk::MissionRawServer::IncomingMissionHandle*> incoming_mission_handles;
    std::vector<mavsdk::MissionRawServer::CurrentItemChangedHandle*> current_item_changed_handles;
    std::vector<mavsdk::MissionRawServer::ClearAllHandle*> clear_all_handles;
};

mavsdk_mission_raw_server_t
mavsdk_mission_raw_server_create(mavsdk_server_component_t server_component) {
    if (server_component == nullptr) {
        return nullptr;
    }

    auto wrapper = new mavsdk_mission_raw_server_wrapper();
    auto server_component_ptr = reinterpret_cast<std::shared_ptr<mavsdk::ServerComponent>*>(server_component);
    wrapper->cpp_plugin = std::make_shared<mavsdk::MissionRawServer>(*server_component_ptr);

    return reinterpret_cast<mavsdk_mission_raw_server_t>(wrapper);
}

void mavsdk_mission_raw_server_destroy(mavsdk_mission_raw_server_t mission_raw_server) {
    if (mission_raw_server == nullptr) {
        return;
    }

    auto wrapper = reinterpret_cast<mavsdk_mission_raw_server_wrapper*>(mission_raw_server);

    // Unsubscribe all active streams before destroying to prevent
    // callbacks firing into a destroyed object
    {
        std::lock_guard<std::mutex> lock(wrapper->handles_mutex);
        for (auto* h : wrapper->incoming_mission_handles) {
            wrapper->cpp_plugin->unsubscribe_incoming_mission(std::move(*h));
            delete h;
        }
        wrapper->incoming_mission_handles.clear();
        for (auto* h : wrapper->current_item_changed_handles) {
            wrapper->cpp_plugin->unsubscribe_current_item_changed(std::move(*h));
            delete h;
        }
        wrapper->current_item_changed_handles.clear();
        for (auto* h : wrapper->clear_all_handles) {
            wrapper->cpp_plugin->unsubscribe_clear_all(std::move(*h));
            delete h;
        }
        wrapper->clear_all_handles.clear();
    }

    delete wrapper;
}

// ===== Method Implementations =====

// IncomingMission async
mavsdk_mission_raw_server_incoming_mission_handle_t mavsdk_mission_raw_server_subscribe_incoming_mission(
    mavsdk_mission_raw_server_t mission_raw_server,
    mavsdk_mission_raw_server_incoming_mission_callback_t callback,
    void* user_data)
{
    auto wrapper = reinterpret_cast<mavsdk_mission_raw_server_wrapper*>(mission_raw_server);

    auto cpp_handle =    wrapper->cpp_plugin->subscribe_incoming_mission(
        [callback, user_data](
            mavsdk::MissionRawServer::Result result,
            mavsdk::MissionRawServer::MissionPlan value) {
                if (callback) {
                    callback(
                        translate_result(result),
                        translate_mission_plan_to_c(value),
                        user_data);
                }
        });

    auto cpp_handle_ptr = new mavsdk::MissionRawServer::IncomingMissionHandle(std::move(cpp_handle));

    {
        std::lock_guard<std::mutex> lock(wrapper->handles_mutex);
        wrapper->incoming_mission_handles.push_back(cpp_handle_ptr);
    }

    return reinterpret_cast<mavsdk_mission_raw_server_incoming_mission_handle_t>(cpp_handle_ptr);
}

void mavsdk_mission_raw_server_unsubscribe_incoming_mission(
    mavsdk_mission_raw_server_t mission_raw_server,
    mavsdk_mission_raw_server_incoming_mission_handle_t handle)
{
    if (handle) {
        auto wrapper = reinterpret_cast<mavsdk_mission_raw_server_wrapper*>(mission_raw_server);
        auto cpp_handle = reinterpret_cast<mavsdk::MissionRawServer::IncomingMissionHandle*>(handle);

        {
            std::lock_guard<std::mutex> lock(wrapper->handles_mutex);
            auto& vec = wrapper->incoming_mission_handles;
            vec.erase(std::remove(vec.begin(), vec.end(), cpp_handle), vec.end());
        }

        wrapper->cpp_plugin->unsubscribe_incoming_mission(std::move(*cpp_handle));
        delete cpp_handle;
    }
}


// CurrentItemChanged async
mavsdk_mission_raw_server_current_item_changed_handle_t mavsdk_mission_raw_server_subscribe_current_item_changed(
    mavsdk_mission_raw_server_t mission_raw_server,
    mavsdk_mission_raw_server_current_item_changed_callback_t callback,
    void* user_data)
{
    auto wrapper = reinterpret_cast<mavsdk_mission_raw_server_wrapper*>(mission_raw_server);

    auto cpp_handle =    wrapper->cpp_plugin->subscribe_current_item_changed(
        [callback, user_data](
            mavsdk::MissionRawServer::MissionItem value) {
                if (callback) {
                    callback(
                        translate_mission_item_to_c(value),
                        user_data);
                }
        });

    auto cpp_handle_ptr = new mavsdk::MissionRawServer::CurrentItemChangedHandle(std::move(cpp_handle));

    {
        std::lock_guard<std::mutex> lock(wrapper->handles_mutex);
        wrapper->current_item_changed_handles.push_back(cpp_handle_ptr);
    }

    return reinterpret_cast<mavsdk_mission_raw_server_current_item_changed_handle_t>(cpp_handle_ptr);
}

void mavsdk_mission_raw_server_unsubscribe_current_item_changed(
    mavsdk_mission_raw_server_t mission_raw_server,
    mavsdk_mission_raw_server_current_item_changed_handle_t handle)
{
    if (handle) {
        auto wrapper = reinterpret_cast<mavsdk_mission_raw_server_wrapper*>(mission_raw_server);
        auto cpp_handle = reinterpret_cast<mavsdk::MissionRawServer::CurrentItemChangedHandle*>(handle);

        {
            std::lock_guard<std::mutex> lock(wrapper->handles_mutex);
            auto& vec = wrapper->current_item_changed_handles;
            vec.erase(std::remove(vec.begin(), vec.end(), cpp_handle), vec.end());
        }

        wrapper->cpp_plugin->unsubscribe_current_item_changed(std::move(*cpp_handle));
        delete cpp_handle;
    }
}



// SetCurrentItemComplete sync
void
mavsdk_mission_raw_server_set_current_item_complete(
    mavsdk_mission_raw_server_t mission_raw_server)
{
    auto wrapper = reinterpret_cast<mavsdk_mission_raw_server_wrapper*>(mission_raw_server);

wrapper->cpp_plugin->set_current_item_complete();

}

// ClearAll async
mavsdk_mission_raw_server_clear_all_handle_t mavsdk_mission_raw_server_subscribe_clear_all(
    mavsdk_mission_raw_server_t mission_raw_server,
    mavsdk_mission_raw_server_clear_all_callback_t callback,
    void* user_data)
{
    auto wrapper = reinterpret_cast<mavsdk_mission_raw_server_wrapper*>(mission_raw_server);

    auto cpp_handle =    wrapper->cpp_plugin->subscribe_clear_all(
        [callback, user_data](
            uint32_t value) {
                if (callback) {
                    callback(
                        value,
                        user_data);
                }
        });

    auto cpp_handle_ptr = new mavsdk::MissionRawServer::ClearAllHandle(std::move(cpp_handle));

    {
        std::lock_guard<std::mutex> lock(wrapper->handles_mutex);
        wrapper->clear_all_handles.push_back(cpp_handle_ptr);
    }

    return reinterpret_cast<mavsdk_mission_raw_server_clear_all_handle_t>(cpp_handle_ptr);
}

void mavsdk_mission_raw_server_unsubscribe_clear_all(
    mavsdk_mission_raw_server_t mission_raw_server,
    mavsdk_mission_raw_server_clear_all_handle_t handle)
{
    if (handle) {
        auto wrapper = reinterpret_cast<mavsdk_mission_raw_server_wrapper*>(mission_raw_server);
        auto cpp_handle = reinterpret_cast<mavsdk::MissionRawServer::ClearAllHandle*>(handle);

        {
            std::lock_guard<std::mutex> lock(wrapper->handles_mutex);
            auto& vec = wrapper->clear_all_handles;
            vec.erase(std::remove(vec.begin(), vec.end(), cpp_handle), vec.end());
        }

        wrapper->cpp_plugin->unsubscribe_clear_all(std::move(*cpp_handle));
        delete cpp_handle;
    }
}

