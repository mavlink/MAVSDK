// WARNING: THIS FILE IS AUTOGENERATED! As such, it should not be edited.
// Edits need to be made to the proto files
// (see https://github.com/mavlink/MAVSDK-Proto/blob/main/protos/ftp/ftp.proto)

#include "ftp.h"

#include <mavsdk/plugins/ftp/ftp.h>
#include <algorithm>
#include <cstring>
#include <mutex>
#include <vector>

// ===== C++ to C Type Conversions =====

static mavsdk_ftp_result_t
translate_result(mavsdk::Ftp::Result cpp_result) {
    switch(cpp_result) {
        case mavsdk::Ftp::Result::Unknown:
            return MAVSDK_FTP_RESULT_UNKNOWN;
        case mavsdk::Ftp::Result::Success:
            return MAVSDK_FTP_RESULT_SUCCESS;
        case mavsdk::Ftp::Result::Next:
            return MAVSDK_FTP_RESULT_NEXT;
        case mavsdk::Ftp::Result::Timeout:
            return MAVSDK_FTP_RESULT_TIMEOUT;
        case mavsdk::Ftp::Result::Busy:
            return MAVSDK_FTP_RESULT_BUSY;
        case mavsdk::Ftp::Result::FileIoError:
            return MAVSDK_FTP_RESULT_FILE_IO_ERROR;
        case mavsdk::Ftp::Result::FileExists:
            return MAVSDK_FTP_RESULT_FILE_EXISTS;
        case mavsdk::Ftp::Result::FileDoesNotExist:
            return MAVSDK_FTP_RESULT_FILE_DOES_NOT_EXIST;
        case mavsdk::Ftp::Result::FileProtected:
            return MAVSDK_FTP_RESULT_FILE_PROTECTED;
        case mavsdk::Ftp::Result::InvalidParameter:
            return MAVSDK_FTP_RESULT_INVALID_PARAMETER;
        case mavsdk::Ftp::Result::Unsupported:
            return MAVSDK_FTP_RESULT_UNSUPPORTED;
        case mavsdk::Ftp::Result::ProtocolError:
            return MAVSDK_FTP_RESULT_PROTOCOL_ERROR;
        case mavsdk::Ftp::Result::NoSystem:
            return MAVSDK_FTP_RESULT_NO_SYSTEM;
    }
}



static mavsdk::Ftp::ListDirectoryData
translate_list_directory_data_from_c(const mavsdk_ftp_list_directory_data_t& c_struct) {
    mavsdk::Ftp::ListDirectoryData cpp_struct{};
    cpp_struct.dirs.reserve(c_struct.dirs_size);
    for (size_t i = 0; i < c_struct.dirs_size; i++) {
        if (c_struct.dirs[i]) {
            cpp_struct.dirs.push_back(c_struct.dirs[i]);
        }
    }
    cpp_struct.files.reserve(c_struct.files_size);
    for (size_t i = 0; i < c_struct.files_size; i++) {
        if (c_struct.files[i]) {
            cpp_struct.files.push_back(c_struct.files[i]);
        }
    }
    return cpp_struct;
}

static mavsdk_ftp_list_directory_data_t
translate_list_directory_data_to_c(const mavsdk::Ftp::ListDirectoryData& cpp_struct) {
    mavsdk_ftp_list_directory_data_t c_struct{};
    c_struct.dirs_size = cpp_struct.dirs.size();
    c_struct.dirs = new char*[c_struct.dirs_size];
    for (size_t i = 0; i < c_struct.dirs_size; i++) {
        c_struct.dirs[i] = strdup(cpp_struct.dirs[i].c_str());
    }
    c_struct.files_size = cpp_struct.files.size();
    c_struct.files = new char*[c_struct.files_size];
    for (size_t i = 0; i < c_struct.files_size; i++) {
        c_struct.files[i] = strdup(cpp_struct.files[i].c_str());
    }
    return c_struct;
}

void mavsdk_ftp_list_directory_data_destroy(
    mavsdk_ftp_list_directory_data_t* target) {
    if (!target) return;
    if (target->dirs) {
        for (size_t i = 0; i < target->dirs_size; i++) {
            if (target->dirs[i]) {
                free(target->dirs[i]);
            }
        }
        delete[] target->dirs;
        target->dirs = nullptr;
        target->dirs_size = 0;
    }
    if (target->files) {
        for (size_t i = 0; i < target->files_size; i++) {
            if (target->files[i]) {
                free(target->files[i]);
            }
        }
        delete[] target->files;
        target->files = nullptr;
        target->files_size = 0;
    }
}

void mavsdk_ftp_list_directory_data_array_destroy(
    mavsdk_ftp_list_directory_data_t** array,
    size_t size) {
    if (!array || !*array) return;

    for (size_t i = 0; i < size; i++) {
        mavsdk_ftp_list_directory_data_destroy(&(*array)[i]);
    }

    delete[] *array;
    *array = nullptr;
}


static mavsdk::Ftp::ProgressData
translate_progress_data_from_c(const mavsdk_ftp_progress_data_t& c_struct) {
    mavsdk::Ftp::ProgressData cpp_struct{};
    cpp_struct.bytes_transferred = c_struct.bytes_transferred;
    cpp_struct.total_bytes = c_struct.total_bytes;
    return cpp_struct;
}

static mavsdk_ftp_progress_data_t
translate_progress_data_to_c(const mavsdk::Ftp::ProgressData& cpp_struct) {
    mavsdk_ftp_progress_data_t c_struct{};
    c_struct.bytes_transferred = cpp_struct.bytes_transferred;
    c_struct.total_bytes = cpp_struct.total_bytes;
    return c_struct;
}

void mavsdk_ftp_progress_data_destroy(
    mavsdk_ftp_progress_data_t* target) {
    if (!target) return;
}

void mavsdk_ftp_progress_data_array_destroy(
    mavsdk_ftp_progress_data_t** array,
    size_t size) {
    if (!array || !*array) return;

    for (size_t i = 0; i < size; i++) {
        mavsdk_ftp_progress_data_destroy(&(*array)[i]);
    }

    delete[] *array;
    *array = nullptr;
}



// ===== Primitive Array Destroy Functions =====
void mavsdk_ftp_float_array_destroy(float** array) {
    if (!array || !*array) return;
    delete[] *array;
    *array = nullptr;
}

void mavsdk_ftp_double_array_destroy(double** array) {
    if (!array || !*array) return;
    delete[] *array;
    *array = nullptr;
}

void mavsdk_ftp_int32t_array_destroy(int32_t** array) {
    if (!array || !*array) return;
    delete[] *array;
    *array = nullptr;
}

void mavsdk_ftp_uint32t_array_destroy(uint32_t** array) {
    if (!array || !*array) return;
    delete[] *array;
    *array = nullptr;
}

void mavsdk_ftp_int64t_array_destroy(int64_t** array) {
    if (!array || !*array) return;
    delete[] *array;
    *array = nullptr;
}

void mavsdk_ftp_uint64t_array_destroy(uint64_t** array) {
    if (!array || !*array) return;
    delete[] *array;
    *array = nullptr;
}

void mavsdk_ftp_bool_array_destroy(bool** array) {
    if (!array || !*array) return;
    delete[] *array;
    *array = nullptr;
}


void mavsdk_ftp_string_destroy(char** str) {
    if (!str || !*str) return;
    free(*str);
    *str = nullptr;
}

void mavsdk_ftp_byte_buffer_destroy(uint8_t** buffer) {
    if (!buffer || !*buffer) return;
    delete[] *buffer;
    *buffer = nullptr;
}

// ===== Ftp Wrapper =====

struct mavsdk_ftp_wrapper {
    std::shared_ptr<mavsdk::Ftp> cpp_plugin;
    std::mutex handles_mutex;
};

mavsdk_ftp_t
mavsdk_ftp_create(mavsdk_system_t system) {
    if (system == nullptr) {
        return nullptr;
    }

    auto wrapper = new mavsdk_ftp_wrapper();
    auto system_ptr = reinterpret_cast<std::shared_ptr<mavsdk::System>*>(system);
    wrapper->cpp_plugin = std::make_shared<mavsdk::Ftp>(*system_ptr);

    return reinterpret_cast<mavsdk_ftp_t>(wrapper);
}

void mavsdk_ftp_destroy(mavsdk_ftp_t ftp) {
    if (ftp == nullptr) {
        return;
    }

    auto wrapper = reinterpret_cast<mavsdk_ftp_wrapper*>(ftp);

    // Unsubscribe all active streams before destroying to prevent
    // callbacks firing into a destroyed object
    {
        std::lock_guard<std::mutex> lock(wrapper->handles_mutex);
    }

    delete wrapper;
}

// ===== Method Implementations =====

// Download async
void mavsdk_ftp_download_async(
    mavsdk_ftp_t ftp,
    char* remote_file_path,
    char* local_dir,
    bool use_burst,
    mavsdk_ftp_download_callback_t callback,
    void* user_data)
{
    auto wrapper = reinterpret_cast<mavsdk_ftp_wrapper*>(ftp);

    wrapper->cpp_plugin->download_async(
        remote_file_path,
        local_dir,
        use_burst,
        [callback, user_data](
            mavsdk::Ftp::Result result,
            mavsdk::Ftp::ProgressData value) {
                if (callback) {
                    callback(
                        translate_result(result),
                        translate_progress_data_to_c(value),
                        user_data);
                }
        });
}



// Upload async
void mavsdk_ftp_upload_async(
    mavsdk_ftp_t ftp,
    char* local_file_path,
    char* remote_dir,
    mavsdk_ftp_upload_callback_t callback,
    void* user_data)
{
    auto wrapper = reinterpret_cast<mavsdk_ftp_wrapper*>(ftp);

    wrapper->cpp_plugin->upload_async(
        local_file_path,
        remote_dir,
        [callback, user_data](
            mavsdk::Ftp::Result result,
            mavsdk::Ftp::ProgressData value) {
                if (callback) {
                    callback(
                        translate_result(result),
                        translate_progress_data_to_c(value),
                        user_data);
                }
        });
}



// ListDirectory async
void mavsdk_ftp_list_directory_async(
    mavsdk_ftp_t ftp,
    char* remote_dir,
    mavsdk_ftp_list_directory_callback_t callback,
    void* user_data)
{
    auto wrapper = reinterpret_cast<mavsdk_ftp_wrapper*>(ftp);

    wrapper->cpp_plugin->list_directory_async(
        remote_dir,
        [callback, user_data](
            mavsdk::Ftp::Result result,
            mavsdk::Ftp::ListDirectoryData value) {
                if (callback) {
                    callback(
                        translate_result(result),
                        translate_list_directory_data_to_c(value),
                        user_data);
                }
        });
}


// ListDirectory sync
mavsdk_ftp_result_t
mavsdk_ftp_list_directory(
    mavsdk_ftp_t ftp,
    char* remote_dir,
    mavsdk_ftp_list_directory_data_t* data_out)
{
    auto wrapper = reinterpret_cast<mavsdk_ftp_wrapper*>(ftp);

    auto result_pair = wrapper->cpp_plugin->list_directory(
        remote_dir);

    if (data_out != nullptr) {
        *data_out = translate_list_directory_data_to_c(result_pair.second);
    }

    return translate_result(result_pair.first);
}

// CreateDirectory async
void mavsdk_ftp_create_directory_async(
    mavsdk_ftp_t ftp,
    char* remote_dir,
    mavsdk_ftp_create_directory_callback_t callback,
    void* user_data)
{
    auto wrapper = reinterpret_cast<mavsdk_ftp_wrapper*>(ftp);

    wrapper->cpp_plugin->create_directory_async(
        remote_dir,
        [callback, user_data](
            mavsdk::Ftp::Result result) {
                if (callback) {
                    callback(
                        translate_result(result),
                        user_data);
                }
        });
}


// CreateDirectory sync
mavsdk_ftp_result_t
mavsdk_ftp_create_directory(
    mavsdk_ftp_t ftp,
    char* remote_dir)
{
    auto wrapper = reinterpret_cast<mavsdk_ftp_wrapper*>(ftp);

    auto ret_value = wrapper->cpp_plugin->create_directory(        remote_dir);

    return translate_result(ret_value);
}

// RemoveDirectory async
void mavsdk_ftp_remove_directory_async(
    mavsdk_ftp_t ftp,
    char* remote_dir,
    mavsdk_ftp_remove_directory_callback_t callback,
    void* user_data)
{
    auto wrapper = reinterpret_cast<mavsdk_ftp_wrapper*>(ftp);

    wrapper->cpp_plugin->remove_directory_async(
        remote_dir,
        [callback, user_data](
            mavsdk::Ftp::Result result) {
                if (callback) {
                    callback(
                        translate_result(result),
                        user_data);
                }
        });
}


// RemoveDirectory sync
mavsdk_ftp_result_t
mavsdk_ftp_remove_directory(
    mavsdk_ftp_t ftp,
    char* remote_dir)
{
    auto wrapper = reinterpret_cast<mavsdk_ftp_wrapper*>(ftp);

    auto ret_value = wrapper->cpp_plugin->remove_directory(        remote_dir);

    return translate_result(ret_value);
}

// RemoveFile async
void mavsdk_ftp_remove_file_async(
    mavsdk_ftp_t ftp,
    char* remote_file_path,
    mavsdk_ftp_remove_file_callback_t callback,
    void* user_data)
{
    auto wrapper = reinterpret_cast<mavsdk_ftp_wrapper*>(ftp);

    wrapper->cpp_plugin->remove_file_async(
        remote_file_path,
        [callback, user_data](
            mavsdk::Ftp::Result result) {
                if (callback) {
                    callback(
                        translate_result(result),
                        user_data);
                }
        });
}


// RemoveFile sync
mavsdk_ftp_result_t
mavsdk_ftp_remove_file(
    mavsdk_ftp_t ftp,
    char* remote_file_path)
{
    auto wrapper = reinterpret_cast<mavsdk_ftp_wrapper*>(ftp);

    auto ret_value = wrapper->cpp_plugin->remove_file(        remote_file_path);

    return translate_result(ret_value);
}

// Rename async
void mavsdk_ftp_rename_async(
    mavsdk_ftp_t ftp,
    char* remote_from_path,
    char* remote_to_path,
    mavsdk_ftp_rename_callback_t callback,
    void* user_data)
{
    auto wrapper = reinterpret_cast<mavsdk_ftp_wrapper*>(ftp);

    wrapper->cpp_plugin->rename_async(
        remote_from_path,
        remote_to_path,
        [callback, user_data](
            mavsdk::Ftp::Result result) {
                if (callback) {
                    callback(
                        translate_result(result),
                        user_data);
                }
        });
}


// Rename sync
mavsdk_ftp_result_t
mavsdk_ftp_rename(
    mavsdk_ftp_t ftp,
    char* remote_from_path,
    char* remote_to_path)
{
    auto wrapper = reinterpret_cast<mavsdk_ftp_wrapper*>(ftp);

    auto ret_value = wrapper->cpp_plugin->rename(        remote_from_path,        remote_to_path);

    return translate_result(ret_value);
}

// AreFilesIdentical async
void mavsdk_ftp_are_files_identical_async(
    mavsdk_ftp_t ftp,
    char* local_file_path,
    char* remote_file_path,
    mavsdk_ftp_are_files_identical_callback_t callback,
    void* user_data)
{
    auto wrapper = reinterpret_cast<mavsdk_ftp_wrapper*>(ftp);

    wrapper->cpp_plugin->are_files_identical_async(
        local_file_path,
        remote_file_path,
        [callback, user_data](
            mavsdk::Ftp::Result result,
            bool value) {
                if (callback) {
                    callback(
                        translate_result(result),
                        value,
                        user_data);
                }
        });
}


// AreFilesIdentical sync
mavsdk_ftp_result_t
mavsdk_ftp_are_files_identical(
    mavsdk_ftp_t ftp,
    char* local_file_path,
    char* remote_file_path,
    bool* are_identical_out)
{
    auto wrapper = reinterpret_cast<mavsdk_ftp_wrapper*>(ftp);

    auto result_pair = wrapper->cpp_plugin->are_files_identical(
        local_file_path,
        remote_file_path);

    *are_identical_out = result_pair.second;

    return translate_result(result_pair.first);
}


// SetTargetCompid sync
mavsdk_ftp_result_t
mavsdk_ftp_set_target_compid(
    mavsdk_ftp_t ftp,
    uint32_t compid)
{
    auto wrapper = reinterpret_cast<mavsdk_ftp_wrapper*>(ftp);

    auto ret_value = wrapper->cpp_plugin->set_target_compid(        compid);

    return translate_result(ret_value);
}
