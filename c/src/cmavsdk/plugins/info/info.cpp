// WARNING: THIS FILE IS AUTOGENERATED! As such, it should not be edited.
// Edits need to be made to the proto files
// (see https://github.com/mavlink/MAVSDK-Proto/blob/main/protos/info/info.proto)

#include "info.h"

#include <mavsdk/plugins/info/info.h>
#include <cstring>
#include <vector>

// ===== C++ to C Type Conversions =====

static mavsdk_info_result_t
translate_result(mavsdk::Info::Result cpp_result) {
    switch(cpp_result) {
        case mavsdk::Info::Result::Unknown:
            return MAVSDK_INFO_RESULT_UNKNOWN;
        case mavsdk::Info::Result::Success:
            return MAVSDK_INFO_RESULT_SUCCESS;
        case mavsdk::Info::Result::InformationNotReceivedYet:
            return MAVSDK_INFO_RESULT_INFORMATION_NOT_RECEIVED_YET;
        case mavsdk::Info::Result::NoSystem:
            return MAVSDK_INFO_RESULT_NO_SYSTEM;
    }
}



static mavsdk::Info::FlightInfo
translate_flight_info_from_c(const mavsdk_info_flight_info_t& c_struct) {
    mavsdk::Info::FlightInfo cpp_struct{};
    cpp_struct.time_boot_ms = c_struct.time_boot_ms;
    cpp_struct.flight_uid = c_struct.flight_uid;
    cpp_struct.duration_since_arming_ms = c_struct.duration_since_arming_ms;
    cpp_struct.duration_since_takeoff_ms = c_struct.duration_since_takeoff_ms;
    return cpp_struct;
}

static mavsdk_info_flight_info_t
translate_flight_info_to_c(const mavsdk::Info::FlightInfo& cpp_struct) {
    mavsdk_info_flight_info_t c_struct{};
    c_struct.time_boot_ms = cpp_struct.time_boot_ms;
    c_struct.flight_uid = cpp_struct.flight_uid;
    c_struct.duration_since_arming_ms = cpp_struct.duration_since_arming_ms;
    c_struct.duration_since_takeoff_ms = cpp_struct.duration_since_takeoff_ms;
    return c_struct;
}

void mavsdk_info_flight_info_destroy(
    mavsdk_info_flight_info_t* target) {
    if (!target) return;
}

void mavsdk_info_flight_info_array_destroy(
    mavsdk_info_flight_info_t** array,
    size_t size) {
    if (!array || !*array) return;

    for (size_t i = 0; i < size; i++) {
        mavsdk_info_flight_info_destroy(&(*array)[i]);
    }

    delete[] *array;
    *array = nullptr;
}


static mavsdk::Info::Identification
translate_identification_from_c(const mavsdk_info_identification_t& c_struct) {
    mavsdk::Info::Identification cpp_struct{};
    if (c_struct.hardware_uid) {
        cpp_struct.hardware_uid = c_struct.hardware_uid;
    }
    cpp_struct.legacy_uid = c_struct.legacy_uid;
    return cpp_struct;
}

static mavsdk_info_identification_t
translate_identification_to_c(const mavsdk::Info::Identification& cpp_struct) {
    mavsdk_info_identification_t c_struct{};
    c_struct.hardware_uid = strdup(cpp_struct.hardware_uid.c_str());
    c_struct.legacy_uid = cpp_struct.legacy_uid;
    return c_struct;
}

void mavsdk_info_identification_destroy(
    mavsdk_info_identification_t* target) {
    if (!target) return;
    if (target->hardware_uid) {
        free((void*)target->hardware_uid);
        target->hardware_uid = nullptr;
    }
}

void mavsdk_info_identification_array_destroy(
    mavsdk_info_identification_t** array,
    size_t size) {
    if (!array || !*array) return;

    for (size_t i = 0; i < size; i++) {
        mavsdk_info_identification_destroy(&(*array)[i]);
    }

    delete[] *array;
    *array = nullptr;
}


static mavsdk::Info::Product
translate_product_from_c(const mavsdk_info_product_t& c_struct) {
    mavsdk::Info::Product cpp_struct{};
    cpp_struct.vendor_id = c_struct.vendor_id;
    if (c_struct.vendor_name) {
        cpp_struct.vendor_name = c_struct.vendor_name;
    }
    cpp_struct.product_id = c_struct.product_id;
    if (c_struct.product_name) {
        cpp_struct.product_name = c_struct.product_name;
    }
    return cpp_struct;
}

static mavsdk_info_product_t
translate_product_to_c(const mavsdk::Info::Product& cpp_struct) {
    mavsdk_info_product_t c_struct{};
    c_struct.vendor_id = cpp_struct.vendor_id;
    c_struct.vendor_name = strdup(cpp_struct.vendor_name.c_str());
    c_struct.product_id = cpp_struct.product_id;
    c_struct.product_name = strdup(cpp_struct.product_name.c_str());
    return c_struct;
}

void mavsdk_info_product_destroy(
    mavsdk_info_product_t* target) {
    if (!target) return;
    if (target->vendor_name) {
        free((void*)target->vendor_name);
        target->vendor_name = nullptr;
    }
    if (target->product_name) {
        free((void*)target->product_name);
        target->product_name = nullptr;
    }
}

void mavsdk_info_product_array_destroy(
    mavsdk_info_product_t** array,
    size_t size) {
    if (!array || !*array) return;

    for (size_t i = 0; i < size; i++) {
        mavsdk_info_product_destroy(&(*array)[i]);
    }

    delete[] *array;
    *array = nullptr;
}


static mavsdk::Info::Version::FlightSoftwareVersionType
translate_version_flight_software_version_type_from_c(mavsdk_info_version_flight_software_version_type_t c_enum) {
    switch(c_enum) {
        case MAVSDK_INFO_VERSION_FLIGHT_SOFTWARE_VERSION_TYPE_UNKNOWN:
            return mavsdk::Info::Version::FlightSoftwareVersionType::Unknown;
        case MAVSDK_INFO_VERSION_FLIGHT_SOFTWARE_VERSION_TYPE_DEV:
            return mavsdk::Info::Version::FlightSoftwareVersionType::Dev;
        case MAVSDK_INFO_VERSION_FLIGHT_SOFTWARE_VERSION_TYPE_ALPHA:
            return mavsdk::Info::Version::FlightSoftwareVersionType::Alpha;
        case MAVSDK_INFO_VERSION_FLIGHT_SOFTWARE_VERSION_TYPE_BETA:
            return mavsdk::Info::Version::FlightSoftwareVersionType::Beta;
        case MAVSDK_INFO_VERSION_FLIGHT_SOFTWARE_VERSION_TYPE_RC:
            return mavsdk::Info::Version::FlightSoftwareVersionType::Rc;
        case MAVSDK_INFO_VERSION_FLIGHT_SOFTWARE_VERSION_TYPE_RELEASE:
            return mavsdk::Info::Version::FlightSoftwareVersionType::Release;
    }
    return mavsdk::Info::Version::FlightSoftwareVersionType::Unknown;
}


static mavsdk::Info::Version
translate_version_from_c(const mavsdk_info_version_t& c_struct) {
    mavsdk::Info::Version cpp_struct{};
    cpp_struct.flight_sw_major = c_struct.flight_sw_major;
    cpp_struct.flight_sw_minor = c_struct.flight_sw_minor;
    cpp_struct.flight_sw_patch = c_struct.flight_sw_patch;
    cpp_struct.flight_sw_vendor_major = c_struct.flight_sw_vendor_major;
    cpp_struct.flight_sw_vendor_minor = c_struct.flight_sw_vendor_minor;
    cpp_struct.flight_sw_vendor_patch = c_struct.flight_sw_vendor_patch;
    cpp_struct.os_sw_major = c_struct.os_sw_major;
    cpp_struct.os_sw_minor = c_struct.os_sw_minor;
    cpp_struct.os_sw_patch = c_struct.os_sw_patch;
    if (c_struct.flight_sw_git_hash) {
        cpp_struct.flight_sw_git_hash = c_struct.flight_sw_git_hash;
    }
    if (c_struct.os_sw_git_hash) {
        cpp_struct.os_sw_git_hash = c_struct.os_sw_git_hash;
    }
    cpp_struct.flight_sw_version_type = translate_version_flight_software_version_type_from_c(c_struct.flight_sw_version_type);
    return cpp_struct;
}


static mavsdk_info_version_flight_software_version_type_t
translate_version_flight_software_version_type_to_c(mavsdk::Info::Version::FlightSoftwareVersionType cpp_enum) {
    switch(cpp_enum) {
        case mavsdk::Info::Version::FlightSoftwareVersionType::Unknown:
            return MAVSDK_INFO_VERSION_FLIGHT_SOFTWARE_VERSION_TYPE_UNKNOWN;
        case mavsdk::Info::Version::FlightSoftwareVersionType::Dev:
            return MAVSDK_INFO_VERSION_FLIGHT_SOFTWARE_VERSION_TYPE_DEV;
        case mavsdk::Info::Version::FlightSoftwareVersionType::Alpha:
            return MAVSDK_INFO_VERSION_FLIGHT_SOFTWARE_VERSION_TYPE_ALPHA;
        case mavsdk::Info::Version::FlightSoftwareVersionType::Beta:
            return MAVSDK_INFO_VERSION_FLIGHT_SOFTWARE_VERSION_TYPE_BETA;
        case mavsdk::Info::Version::FlightSoftwareVersionType::Rc:
            return MAVSDK_INFO_VERSION_FLIGHT_SOFTWARE_VERSION_TYPE_RC;
        case mavsdk::Info::Version::FlightSoftwareVersionType::Release:
            return MAVSDK_INFO_VERSION_FLIGHT_SOFTWARE_VERSION_TYPE_RELEASE;
    }
    return MAVSDK_INFO_VERSION_FLIGHT_SOFTWARE_VERSION_TYPE_UNKNOWN;
}

static mavsdk_info_version_t
translate_version_to_c(const mavsdk::Info::Version& cpp_struct) {
    mavsdk_info_version_t c_struct{};
    c_struct.flight_sw_major = cpp_struct.flight_sw_major;
    c_struct.flight_sw_minor = cpp_struct.flight_sw_minor;
    c_struct.flight_sw_patch = cpp_struct.flight_sw_patch;
    c_struct.flight_sw_vendor_major = cpp_struct.flight_sw_vendor_major;
    c_struct.flight_sw_vendor_minor = cpp_struct.flight_sw_vendor_minor;
    c_struct.flight_sw_vendor_patch = cpp_struct.flight_sw_vendor_patch;
    c_struct.os_sw_major = cpp_struct.os_sw_major;
    c_struct.os_sw_minor = cpp_struct.os_sw_minor;
    c_struct.os_sw_patch = cpp_struct.os_sw_patch;
    c_struct.flight_sw_git_hash = strdup(cpp_struct.flight_sw_git_hash.c_str());
    c_struct.os_sw_git_hash = strdup(cpp_struct.os_sw_git_hash.c_str());
    c_struct.flight_sw_version_type = translate_version_flight_software_version_type_to_c(cpp_struct.flight_sw_version_type);
    return c_struct;
}

void mavsdk_info_version_destroy(
    mavsdk_info_version_t* target) {
    if (!target) return;
    if (target->flight_sw_git_hash) {
        free((void*)target->flight_sw_git_hash);
        target->flight_sw_git_hash = nullptr;
    }
    if (target->os_sw_git_hash) {
        free((void*)target->os_sw_git_hash);
        target->os_sw_git_hash = nullptr;
    }
}

void mavsdk_info_version_array_destroy(
    mavsdk_info_version_t** array,
    size_t size) {
    if (!array || !*array) return;

    for (size_t i = 0; i < size; i++) {
        mavsdk_info_version_destroy(&(*array)[i]);
    }

    delete[] *array;
    *array = nullptr;
}



// ===== Primitive Array Destroy Functions =====
void mavsdk_info_float_array_destroy(float** array) {
    if (!array || !*array) return;
    delete[] *array;
    *array = nullptr;
}

void mavsdk_info_double_array_destroy(double** array) {
    if (!array || !*array) return;
    delete[] *array;
    *array = nullptr;
}

void mavsdk_info_int32t_array_destroy(int32_t** array) {
    if (!array || !*array) return;
    delete[] *array;
    *array = nullptr;
}

void mavsdk_info_uint32t_array_destroy(uint32_t** array) {
    if (!array || !*array) return;
    delete[] *array;
    *array = nullptr;
}

void mavsdk_info_int64t_array_destroy(int64_t** array) {
    if (!array || !*array) return;
    delete[] *array;
    *array = nullptr;
}

void mavsdk_info_uint64t_array_destroy(uint64_t** array) {
    if (!array || !*array) return;
    delete[] *array;
    *array = nullptr;
}

void mavsdk_info_bool_array_destroy(bool** array) {
    if (!array || !*array) return;
    delete[] *array;
    *array = nullptr;
}


void mavsdk_info_string_destroy(char** str) {
    if (!str || !*str) return;
    free(*str);
    *str = nullptr;
}

void mavsdk_info_byte_buffer_destroy(uint8_t** buffer) {
    if (!buffer || !*buffer) return;
    delete[] *buffer;
    *buffer = nullptr;
}

// ===== Info Wrapper =====

struct mavsdk_info_wrapper {
    std::shared_ptr<mavsdk::Info> cpp_plugin;
};

mavsdk_info_t
mavsdk_info_create(mavsdk_system_t system) {
    if (system == nullptr) {
        return nullptr;
    }

    auto wrapper = new mavsdk_info_wrapper();
    auto system_ptr = reinterpret_cast<std::shared_ptr<mavsdk::System>*>(system);
    wrapper->cpp_plugin = std::make_shared<mavsdk::Info>(*system_ptr);

    return reinterpret_cast<mavsdk_info_t>(wrapper);
}

void mavsdk_info_destroy(mavsdk_info_t info) {
    if (info == nullptr) {
        return;
    }

    auto wrapper = reinterpret_cast<mavsdk_info_wrapper*>(info);
    delete wrapper;
}

// ===== Method Implementations =====


// GetFlightInformation sync
mavsdk_info_result_t
mavsdk_info_get_flight_information(
    mavsdk_info_t info,
    mavsdk_info_flight_info_t* flight_info_out)
{
    auto wrapper = reinterpret_cast<mavsdk_info_wrapper*>(info);

    auto result_pair = wrapper->cpp_plugin->get_flight_information(
);

    if (flight_info_out != nullptr) {
        *flight_info_out = translate_flight_info_to_c(result_pair.second);
    }

    return translate_result(result_pair.first);
}


// GetIdentification sync
mavsdk_info_result_t
mavsdk_info_get_identification(
    mavsdk_info_t info,
    mavsdk_info_identification_t* identification_out)
{
    auto wrapper = reinterpret_cast<mavsdk_info_wrapper*>(info);

    auto result_pair = wrapper->cpp_plugin->get_identification(
);

    if (identification_out != nullptr) {
        *identification_out = translate_identification_to_c(result_pair.second);
    }

    return translate_result(result_pair.first);
}


// GetProduct sync
mavsdk_info_result_t
mavsdk_info_get_product(
    mavsdk_info_t info,
    mavsdk_info_product_t* product_out)
{
    auto wrapper = reinterpret_cast<mavsdk_info_wrapper*>(info);

    auto result_pair = wrapper->cpp_plugin->get_product(
);

    if (product_out != nullptr) {
        *product_out = translate_product_to_c(result_pair.second);
    }

    return translate_result(result_pair.first);
}


// GetVersion sync
mavsdk_info_result_t
mavsdk_info_get_version(
    mavsdk_info_t info,
    mavsdk_info_version_t* version_out)
{
    auto wrapper = reinterpret_cast<mavsdk_info_wrapper*>(info);

    auto result_pair = wrapper->cpp_plugin->get_version(
);

    if (version_out != nullptr) {
        *version_out = translate_version_to_c(result_pair.second);
    }

    return translate_result(result_pair.first);
}


// GetSpeedFactor sync
mavsdk_info_result_t
mavsdk_info_get_speed_factor(
    mavsdk_info_t info,
    double* speed_factor_out)
{
    auto wrapper = reinterpret_cast<mavsdk_info_wrapper*>(info);

    auto result_pair = wrapper->cpp_plugin->get_speed_factor(
);

    *speed_factor_out = result_pair.second;

    return translate_result(result_pair.first);
}

// FlightInformation async
mavsdk_info_flight_information_handle_t mavsdk_info_subscribe_flight_information(
    mavsdk_info_t info,
    mavsdk_info_flight_information_callback_t callback,
    void* user_data)
{
    auto wrapper = reinterpret_cast<mavsdk_info_wrapper*>(info);

    auto cpp_handle =    wrapper->cpp_plugin->subscribe_flight_information(
        [callback, user_data](
            mavsdk::Info::FlightInfo value) {
                if (callback) {
                    callback(
                        translate_flight_info_to_c(value),
                        user_data);
                }
        });

    auto handle_wrapper = new mavsdk::Info::FlightInformationHandle(std::move(cpp_handle));
    return reinterpret_cast<mavsdk_info_flight_information_handle_t>(handle_wrapper);
}

void mavsdk_info_unsubscribe_flight_information(
    mavsdk_info_t info,
    mavsdk_info_flight_information_handle_t handle)
{
    if (handle) {
        auto wrapper = reinterpret_cast<mavsdk_info_wrapper*>(info);
        auto cpp_handle = reinterpret_cast<mavsdk::Info::FlightInformationHandle*>(handle);
        wrapper->cpp_plugin->unsubscribe_flight_information(std::move(*cpp_handle));
        delete cpp_handle;
    }
}

