// WARNING: THIS FILE IS AUTOGENERATED! As such, it should not be edited.
// Edits need to be made to the proto files
// (see https://github.com/mavlink/MAVSDK-Proto/blob/main/protos/geofence/geofence.proto)

#include "geofence.h"

#include <mavsdk/plugins/geofence/geofence.h>
#include <algorithm>
#include <cstring>
#include <mutex>
#include <vector>

// ===== C++ to C Type Conversions =====

static mavsdk_geofence_result_t
translate_result(mavsdk::Geofence::Result cpp_result) {
    switch(cpp_result) {
        case mavsdk::Geofence::Result::Unknown:
            return MAVSDK_GEOFENCE_RESULT_UNKNOWN;
        case mavsdk::Geofence::Result::Success:
            return MAVSDK_GEOFENCE_RESULT_SUCCESS;
        case mavsdk::Geofence::Result::Error:
            return MAVSDK_GEOFENCE_RESULT_ERROR;
        case mavsdk::Geofence::Result::TooManyGeofenceItems:
            return MAVSDK_GEOFENCE_RESULT_TOO_MANY_GEOFENCE_ITEMS;
        case mavsdk::Geofence::Result::Busy:
            return MAVSDK_GEOFENCE_RESULT_BUSY;
        case mavsdk::Geofence::Result::Timeout:
            return MAVSDK_GEOFENCE_RESULT_TIMEOUT;
        case mavsdk::Geofence::Result::InvalidArgument:
            return MAVSDK_GEOFENCE_RESULT_INVALID_ARGUMENT;
        case mavsdk::Geofence::Result::NoSystem:
            return MAVSDK_GEOFENCE_RESULT_NO_SYSTEM;
    }
}

static mavsdk::Geofence::FenceType
translate_fence_type_from_c(mavsdk_geofence_fence_type_t c_enum) {
    switch(c_enum) {
        case MAVSDK_GEOFENCE_FENCE_TYPE_INCLUSION:
            return mavsdk::Geofence::FenceType::Inclusion;
        case MAVSDK_GEOFENCE_FENCE_TYPE_EXCLUSION:
            return mavsdk::Geofence::FenceType::Exclusion;
    }
    return mavsdk::Geofence::FenceType::Inclusion;
}

static mavsdk_geofence_fence_type_t
translate_fence_type_to_c(mavsdk::Geofence::FenceType cpp_enum) {
    switch(cpp_enum) {
        case mavsdk::Geofence::FenceType::Inclusion:
            return MAVSDK_GEOFENCE_FENCE_TYPE_INCLUSION;
        case mavsdk::Geofence::FenceType::Exclusion:
            return MAVSDK_GEOFENCE_FENCE_TYPE_EXCLUSION;
    }
    return MAVSDK_GEOFENCE_FENCE_TYPE_INCLUSION;
}



static mavsdk::Geofence::Point
translate_point_from_c(const mavsdk_geofence_point_t& c_struct) {
    mavsdk::Geofence::Point cpp_struct{};
    cpp_struct.latitude_deg = c_struct.latitude_deg;
    cpp_struct.longitude_deg = c_struct.longitude_deg;
    return cpp_struct;
}

static mavsdk_geofence_point_t
translate_point_to_c(const mavsdk::Geofence::Point& cpp_struct) {
    mavsdk_geofence_point_t c_struct{};
    c_struct.latitude_deg = cpp_struct.latitude_deg;
    c_struct.longitude_deg = cpp_struct.longitude_deg;
    return c_struct;
}

void mavsdk_geofence_point_destroy(
    mavsdk_geofence_point_t* target) {
    if (!target) return;
}

void mavsdk_geofence_point_array_destroy(
    mavsdk_geofence_point_t** array,
    size_t size) {
    if (!array || !*array) return;

    for (size_t i = 0; i < size; i++) {
        mavsdk_geofence_point_destroy(&(*array)[i]);
    }

    delete[] *array;
    *array = nullptr;
}


static mavsdk::Geofence::Polygon
translate_polygon_from_c(const mavsdk_geofence_polygon_t& c_struct) {
    mavsdk::Geofence::Polygon cpp_struct{};
    cpp_struct.points.reserve(c_struct.points_size);
    for (size_t i = 0; i < c_struct.points_size; i++) {
        cpp_struct.points.push_back(
            translate_point_from_c(c_struct.points[i]));
    }
    cpp_struct.fence_type = translate_fence_type_from_c(c_struct.fence_type);
    return cpp_struct;
}

static mavsdk_geofence_polygon_t
translate_polygon_to_c(const mavsdk::Geofence::Polygon& cpp_struct) {
    mavsdk_geofence_polygon_t c_struct{};
    c_struct.points_size = cpp_struct.points.size();
    c_struct.points = new mavsdk_geofence_point_t[c_struct.points_size];
    for (size_t i = 0; i < c_struct.points_size; i++) {
        c_struct.points[i] = translate_point_to_c(cpp_struct.points[i]);
    }
    c_struct.fence_type = translate_fence_type_to_c(cpp_struct.fence_type);
    return c_struct;
}

void mavsdk_geofence_polygon_destroy(
    mavsdk_geofence_polygon_t* target) {
    if (!target) return;
    if (target->points) {
        for (size_t i = 0; i < target->points_size; i++) {
            mavsdk_geofence_point_destroy(&target->points[i]);
        }
        delete[] target->points;
        target->points = nullptr;
        target->points_size = 0;
    }
}

void mavsdk_geofence_polygon_array_destroy(
    mavsdk_geofence_polygon_t** array,
    size_t size) {
    if (!array || !*array) return;

    for (size_t i = 0; i < size; i++) {
        mavsdk_geofence_polygon_destroy(&(*array)[i]);
    }

    delete[] *array;
    *array = nullptr;
}


static mavsdk::Geofence::Circle
translate_circle_from_c(const mavsdk_geofence_circle_t& c_struct) {
    mavsdk::Geofence::Circle cpp_struct{};
    cpp_struct.point = translate_point_from_c(c_struct.point);
    cpp_struct.radius = c_struct.radius;
    cpp_struct.fence_type = translate_fence_type_from_c(c_struct.fence_type);
    return cpp_struct;
}

static mavsdk_geofence_circle_t
translate_circle_to_c(const mavsdk::Geofence::Circle& cpp_struct) {
    mavsdk_geofence_circle_t c_struct{};
    c_struct.point = translate_point_to_c(cpp_struct.point);
    c_struct.radius = cpp_struct.radius;
    c_struct.fence_type = translate_fence_type_to_c(cpp_struct.fence_type);
    return c_struct;
}

void mavsdk_geofence_circle_destroy(
    mavsdk_geofence_circle_t* target) {
    if (!target) return;
}

void mavsdk_geofence_circle_array_destroy(
    mavsdk_geofence_circle_t** array,
    size_t size) {
    if (!array || !*array) return;

    for (size_t i = 0; i < size; i++) {
        mavsdk_geofence_circle_destroy(&(*array)[i]);
    }

    delete[] *array;
    *array = nullptr;
}


static mavsdk::Geofence::GeofenceData
translate_geofence_data_from_c(const mavsdk_geofence_geofence_data_t& c_struct) {
    mavsdk::Geofence::GeofenceData cpp_struct{};
    cpp_struct.polygons.reserve(c_struct.polygons_size);
    for (size_t i = 0; i < c_struct.polygons_size; i++) {
        cpp_struct.polygons.push_back(
            translate_polygon_from_c(c_struct.polygons[i]));
    }
    cpp_struct.circles.reserve(c_struct.circles_size);
    for (size_t i = 0; i < c_struct.circles_size; i++) {
        cpp_struct.circles.push_back(
            translate_circle_from_c(c_struct.circles[i]));
    }
    return cpp_struct;
}

static mavsdk_geofence_geofence_data_t
translate_geofence_data_to_c(const mavsdk::Geofence::GeofenceData& cpp_struct) {
    mavsdk_geofence_geofence_data_t c_struct{};
    c_struct.polygons_size = cpp_struct.polygons.size();
    c_struct.polygons = new mavsdk_geofence_polygon_t[c_struct.polygons_size];
    for (size_t i = 0; i < c_struct.polygons_size; i++) {
        c_struct.polygons[i] = translate_polygon_to_c(cpp_struct.polygons[i]);
    }
    c_struct.circles_size = cpp_struct.circles.size();
    c_struct.circles = new mavsdk_geofence_circle_t[c_struct.circles_size];
    for (size_t i = 0; i < c_struct.circles_size; i++) {
        c_struct.circles[i] = translate_circle_to_c(cpp_struct.circles[i]);
    }
    return c_struct;
}

void mavsdk_geofence_geofence_data_destroy(
    mavsdk_geofence_geofence_data_t* target) {
    if (!target) return;
    if (target->polygons) {
        for (size_t i = 0; i < target->polygons_size; i++) {
            mavsdk_geofence_polygon_destroy(&target->polygons[i]);
        }
        delete[] target->polygons;
        target->polygons = nullptr;
        target->polygons_size = 0;
    }
    if (target->circles) {
        for (size_t i = 0; i < target->circles_size; i++) {
            mavsdk_geofence_circle_destroy(&target->circles[i]);
        }
        delete[] target->circles;
        target->circles = nullptr;
        target->circles_size = 0;
    }
}

void mavsdk_geofence_geofence_data_array_destroy(
    mavsdk_geofence_geofence_data_t** array,
    size_t size) {
    if (!array || !*array) return;

    for (size_t i = 0; i < size; i++) {
        mavsdk_geofence_geofence_data_destroy(&(*array)[i]);
    }

    delete[] *array;
    *array = nullptr;
}



// ===== Primitive Array Destroy Functions =====
void mavsdk_geofence_float_array_destroy(float** array) {
    if (!array || !*array) return;
    delete[] *array;
    *array = nullptr;
}

void mavsdk_geofence_double_array_destroy(double** array) {
    if (!array || !*array) return;
    delete[] *array;
    *array = nullptr;
}

void mavsdk_geofence_int32t_array_destroy(int32_t** array) {
    if (!array || !*array) return;
    delete[] *array;
    *array = nullptr;
}

void mavsdk_geofence_uint32t_array_destroy(uint32_t** array) {
    if (!array || !*array) return;
    delete[] *array;
    *array = nullptr;
}

void mavsdk_geofence_int64t_array_destroy(int64_t** array) {
    if (!array || !*array) return;
    delete[] *array;
    *array = nullptr;
}

void mavsdk_geofence_uint64t_array_destroy(uint64_t** array) {
    if (!array || !*array) return;
    delete[] *array;
    *array = nullptr;
}

void mavsdk_geofence_bool_array_destroy(bool** array) {
    if (!array || !*array) return;
    delete[] *array;
    *array = nullptr;
}


void mavsdk_geofence_string_destroy(char** str) {
    if (!str || !*str) return;
    free(*str);
    *str = nullptr;
}

void mavsdk_geofence_byte_buffer_destroy(uint8_t** buffer) {
    if (!buffer || !*buffer) return;
    delete[] *buffer;
    *buffer = nullptr;
}

// ===== Geofence Wrapper =====

struct mavsdk_geofence_wrapper {
    std::shared_ptr<mavsdk::Geofence> cpp_plugin;
    std::mutex handles_mutex;
};

mavsdk_geofence_t
mavsdk_geofence_create(mavsdk_system_t system) {
    if (system == nullptr) {
        return nullptr;
    }

    auto wrapper = new mavsdk_geofence_wrapper();
    auto system_ptr = reinterpret_cast<std::shared_ptr<mavsdk::System>*>(system);
    wrapper->cpp_plugin = std::make_shared<mavsdk::Geofence>(*system_ptr);

    return reinterpret_cast<mavsdk_geofence_t>(wrapper);
}

void mavsdk_geofence_destroy(mavsdk_geofence_t geofence) {
    if (geofence == nullptr) {
        return;
    }

    auto wrapper = reinterpret_cast<mavsdk_geofence_wrapper*>(geofence);

    // Unsubscribe all active streams before destroying to prevent
    // callbacks firing into a destroyed object
    {
        std::lock_guard<std::mutex> lock(wrapper->handles_mutex);
    }

    delete wrapper;
}

// ===== Method Implementations =====

// UploadGeofence async
void mavsdk_geofence_upload_geofence_async(
    mavsdk_geofence_t geofence,
    mavsdk_geofence_geofence_data_t geofence_data,
    mavsdk_geofence_upload_geofence_callback_t callback,
    void* user_data)
{
    auto wrapper = reinterpret_cast<mavsdk_geofence_wrapper*>(geofence);

    wrapper->cpp_plugin->upload_geofence_async(
        translate_geofence_data_from_c(geofence_data),
        [callback, user_data](
            mavsdk::Geofence::Result result) {
                if (callback) {
                    callback(
                        translate_result(result),
                        user_data);
                }
        });
}


// UploadGeofence sync
mavsdk_geofence_result_t
mavsdk_geofence_upload_geofence(
    mavsdk_geofence_t geofence,
    mavsdk_geofence_geofence_data_t geofence_data)
{
    auto wrapper = reinterpret_cast<mavsdk_geofence_wrapper*>(geofence);

    auto ret_value = wrapper->cpp_plugin->upload_geofence(        translate_geofence_data_from_c(geofence_data));

    return translate_result(ret_value);
}

// ClearGeofence async
void mavsdk_geofence_clear_geofence_async(
    mavsdk_geofence_t geofence,
    mavsdk_geofence_clear_geofence_callback_t callback,
    void* user_data)
{
    auto wrapper = reinterpret_cast<mavsdk_geofence_wrapper*>(geofence);

    wrapper->cpp_plugin->clear_geofence_async(
        [callback, user_data](
            mavsdk::Geofence::Result result) {
                if (callback) {
                    callback(
                        translate_result(result),
                        user_data);
                }
        });
}


// ClearGeofence sync
mavsdk_geofence_result_t
mavsdk_geofence_clear_geofence(
    mavsdk_geofence_t geofence)
{
    auto wrapper = reinterpret_cast<mavsdk_geofence_wrapper*>(geofence);

    auto ret_value = wrapper->cpp_plugin->clear_geofence();

    return translate_result(ret_value);
}
