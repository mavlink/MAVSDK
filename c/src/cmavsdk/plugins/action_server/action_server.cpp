// WARNING: THIS FILE IS AUTOGENERATED! As such, it should not be edited.
// Edits need to be made to the proto files
// (see https://github.com/mavlink/MAVSDK-Proto/blob/main/protos/action_server/action_server.proto)

#include "action_server.h"

#include <mavsdk/plugins/action_server/action_server.h>
#include <cstring>
#include <vector>

// ===== C++ to C Type Conversions =====

static mavsdk_action_server_result_t
translate_result(mavsdk::ActionServer::Result cpp_result) {
    switch(cpp_result) {
        case mavsdk::ActionServer::Result::Unknown:
            return MAVSDK_ACTION_SERVER_RESULT_UNKNOWN;
        case mavsdk::ActionServer::Result::Success:
            return MAVSDK_ACTION_SERVER_RESULT_SUCCESS;
        case mavsdk::ActionServer::Result::NoSystem:
            return MAVSDK_ACTION_SERVER_RESULT_NO_SYSTEM;
        case mavsdk::ActionServer::Result::ConnectionError:
            return MAVSDK_ACTION_SERVER_RESULT_CONNECTION_ERROR;
        case mavsdk::ActionServer::Result::Busy:
            return MAVSDK_ACTION_SERVER_RESULT_BUSY;
        case mavsdk::ActionServer::Result::CommandDenied:
            return MAVSDK_ACTION_SERVER_RESULT_COMMAND_DENIED;
        case mavsdk::ActionServer::Result::CommandDeniedLandedStateUnknown:
            return MAVSDK_ACTION_SERVER_RESULT_COMMAND_DENIED_LANDED_STATE_UNKNOWN;
        case mavsdk::ActionServer::Result::CommandDeniedNotLanded:
            return MAVSDK_ACTION_SERVER_RESULT_COMMAND_DENIED_NOT_LANDED;
        case mavsdk::ActionServer::Result::Timeout:
            return MAVSDK_ACTION_SERVER_RESULT_TIMEOUT;
        case mavsdk::ActionServer::Result::VtolTransitionSupportUnknown:
            return MAVSDK_ACTION_SERVER_RESULT_VTOL_TRANSITION_SUPPORT_UNKNOWN;
        case mavsdk::ActionServer::Result::NoVtolTransitionSupport:
            return MAVSDK_ACTION_SERVER_RESULT_NO_VTOL_TRANSITION_SUPPORT;
        case mavsdk::ActionServer::Result::ParameterError:
            return MAVSDK_ACTION_SERVER_RESULT_PARAMETER_ERROR;
        case mavsdk::ActionServer::Result::Next:
            return MAVSDK_ACTION_SERVER_RESULT_NEXT;
    }
}

static mavsdk::ActionServer::FlightMode
translate_flight_mode_from_c(mavsdk_action_server_flight_mode_t c_enum) {
    switch(c_enum) {
        case MAVSDK_ACTION_SERVER_FLIGHT_MODE_UNKNOWN:
            return mavsdk::ActionServer::FlightMode::Unknown;
        case MAVSDK_ACTION_SERVER_FLIGHT_MODE_READY:
            return mavsdk::ActionServer::FlightMode::Ready;
        case MAVSDK_ACTION_SERVER_FLIGHT_MODE_TAKEOFF:
            return mavsdk::ActionServer::FlightMode::Takeoff;
        case MAVSDK_ACTION_SERVER_FLIGHT_MODE_HOLD:
            return mavsdk::ActionServer::FlightMode::Hold;
        case MAVSDK_ACTION_SERVER_FLIGHT_MODE_MISSION:
            return mavsdk::ActionServer::FlightMode::Mission;
        case MAVSDK_ACTION_SERVER_FLIGHT_MODE_RETURN_TO_LAUNCH:
            return mavsdk::ActionServer::FlightMode::ReturnToLaunch;
        case MAVSDK_ACTION_SERVER_FLIGHT_MODE_LAND:
            return mavsdk::ActionServer::FlightMode::Land;
        case MAVSDK_ACTION_SERVER_FLIGHT_MODE_OFFBOARD:
            return mavsdk::ActionServer::FlightMode::Offboard;
        case MAVSDK_ACTION_SERVER_FLIGHT_MODE_FOLLOW_ME:
            return mavsdk::ActionServer::FlightMode::FollowMe;
        case MAVSDK_ACTION_SERVER_FLIGHT_MODE_MANUAL:
            return mavsdk::ActionServer::FlightMode::Manual;
        case MAVSDK_ACTION_SERVER_FLIGHT_MODE_ALTCTL:
            return mavsdk::ActionServer::FlightMode::Altctl;
        case MAVSDK_ACTION_SERVER_FLIGHT_MODE_POSCTL:
            return mavsdk::ActionServer::FlightMode::Posctl;
        case MAVSDK_ACTION_SERVER_FLIGHT_MODE_ACRO:
            return mavsdk::ActionServer::FlightMode::Acro;
        case MAVSDK_ACTION_SERVER_FLIGHT_MODE_STABILIZED:
            return mavsdk::ActionServer::FlightMode::Stabilized;
    }
    return mavsdk::ActionServer::FlightMode::Unknown;
}

static mavsdk_action_server_flight_mode_t
translate_flight_mode_to_c(mavsdk::ActionServer::FlightMode cpp_enum) {
    switch(cpp_enum) {
        case mavsdk::ActionServer::FlightMode::Unknown:
            return MAVSDK_ACTION_SERVER_FLIGHT_MODE_UNKNOWN;
        case mavsdk::ActionServer::FlightMode::Ready:
            return MAVSDK_ACTION_SERVER_FLIGHT_MODE_READY;
        case mavsdk::ActionServer::FlightMode::Takeoff:
            return MAVSDK_ACTION_SERVER_FLIGHT_MODE_TAKEOFF;
        case mavsdk::ActionServer::FlightMode::Hold:
            return MAVSDK_ACTION_SERVER_FLIGHT_MODE_HOLD;
        case mavsdk::ActionServer::FlightMode::Mission:
            return MAVSDK_ACTION_SERVER_FLIGHT_MODE_MISSION;
        case mavsdk::ActionServer::FlightMode::ReturnToLaunch:
            return MAVSDK_ACTION_SERVER_FLIGHT_MODE_RETURN_TO_LAUNCH;
        case mavsdk::ActionServer::FlightMode::Land:
            return MAVSDK_ACTION_SERVER_FLIGHT_MODE_LAND;
        case mavsdk::ActionServer::FlightMode::Offboard:
            return MAVSDK_ACTION_SERVER_FLIGHT_MODE_OFFBOARD;
        case mavsdk::ActionServer::FlightMode::FollowMe:
            return MAVSDK_ACTION_SERVER_FLIGHT_MODE_FOLLOW_ME;
        case mavsdk::ActionServer::FlightMode::Manual:
            return MAVSDK_ACTION_SERVER_FLIGHT_MODE_MANUAL;
        case mavsdk::ActionServer::FlightMode::Altctl:
            return MAVSDK_ACTION_SERVER_FLIGHT_MODE_ALTCTL;
        case mavsdk::ActionServer::FlightMode::Posctl:
            return MAVSDK_ACTION_SERVER_FLIGHT_MODE_POSCTL;
        case mavsdk::ActionServer::FlightMode::Acro:
            return MAVSDK_ACTION_SERVER_FLIGHT_MODE_ACRO;
        case mavsdk::ActionServer::FlightMode::Stabilized:
            return MAVSDK_ACTION_SERVER_FLIGHT_MODE_STABILIZED;
    }
    return MAVSDK_ACTION_SERVER_FLIGHT_MODE_UNKNOWN;
}



static mavsdk::ActionServer::AllowableFlightModes
translate_allowable_flight_modes_from_c(const mavsdk_action_server_allowable_flight_modes_t& c_struct) {
    mavsdk::ActionServer::AllowableFlightModes cpp_struct{};
    cpp_struct.can_auto_mode = c_struct.can_auto_mode;
    cpp_struct.can_guided_mode = c_struct.can_guided_mode;
    cpp_struct.can_stabilize_mode = c_struct.can_stabilize_mode;
    cpp_struct.can_auto_rtl_mode = c_struct.can_auto_rtl_mode;
    cpp_struct.can_auto_takeoff_mode = c_struct.can_auto_takeoff_mode;
    cpp_struct.can_auto_land_mode = c_struct.can_auto_land_mode;
    cpp_struct.can_auto_loiter_mode = c_struct.can_auto_loiter_mode;
    return cpp_struct;
}

static mavsdk_action_server_allowable_flight_modes_t
translate_allowable_flight_modes_to_c(const mavsdk::ActionServer::AllowableFlightModes& cpp_struct) {
    mavsdk_action_server_allowable_flight_modes_t c_struct{};
    c_struct.can_auto_mode = cpp_struct.can_auto_mode;
    c_struct.can_guided_mode = cpp_struct.can_guided_mode;
    c_struct.can_stabilize_mode = cpp_struct.can_stabilize_mode;
    c_struct.can_auto_rtl_mode = cpp_struct.can_auto_rtl_mode;
    c_struct.can_auto_takeoff_mode = cpp_struct.can_auto_takeoff_mode;
    c_struct.can_auto_land_mode = cpp_struct.can_auto_land_mode;
    c_struct.can_auto_loiter_mode = cpp_struct.can_auto_loiter_mode;
    return c_struct;
}

void mavsdk_action_server_allowable_flight_modes_destroy(
    mavsdk_action_server_allowable_flight_modes_t* target) {
    if (!target) return;
}

void mavsdk_action_server_allowable_flight_modes_array_destroy(
    mavsdk_action_server_allowable_flight_modes_t** array,
    size_t size) {
    if (!array || !*array) return;

    for (size_t i = 0; i < size; i++) {
        mavsdk_action_server_allowable_flight_modes_destroy(&(*array)[i]);
    }

    delete[] *array;
    *array = nullptr;
}


static mavsdk::ActionServer::ArmDisarm
translate_arm_disarm_from_c(const mavsdk_action_server_arm_disarm_t& c_struct) {
    mavsdk::ActionServer::ArmDisarm cpp_struct{};
    cpp_struct.arm = c_struct.arm;
    cpp_struct.force = c_struct.force;
    return cpp_struct;
}

static mavsdk_action_server_arm_disarm_t
translate_arm_disarm_to_c(const mavsdk::ActionServer::ArmDisarm& cpp_struct) {
    mavsdk_action_server_arm_disarm_t c_struct{};
    c_struct.arm = cpp_struct.arm;
    c_struct.force = cpp_struct.force;
    return c_struct;
}

void mavsdk_action_server_arm_disarm_destroy(
    mavsdk_action_server_arm_disarm_t* target) {
    if (!target) return;
}

void mavsdk_action_server_arm_disarm_array_destroy(
    mavsdk_action_server_arm_disarm_t** array,
    size_t size) {
    if (!array || !*array) return;

    for (size_t i = 0; i < size; i++) {
        mavsdk_action_server_arm_disarm_destroy(&(*array)[i]);
    }

    delete[] *array;
    *array = nullptr;
}



// ===== Primitive Array Destroy Functions =====
void mavsdk_action_server_float_array_destroy(float** array) {
    if (!array || !*array) return;
    delete[] *array;
    *array = nullptr;
}

void mavsdk_action_server_double_array_destroy(double** array) {
    if (!array || !*array) return;
    delete[] *array;
    *array = nullptr;
}

void mavsdk_action_server_int32t_array_destroy(int32_t** array) {
    if (!array || !*array) return;
    delete[] *array;
    *array = nullptr;
}

void mavsdk_action_server_uint32t_array_destroy(uint32_t** array) {
    if (!array || !*array) return;
    delete[] *array;
    *array = nullptr;
}

void mavsdk_action_server_int64t_array_destroy(int64_t** array) {
    if (!array || !*array) return;
    delete[] *array;
    *array = nullptr;
}

void mavsdk_action_server_uint64t_array_destroy(uint64_t** array) {
    if (!array || !*array) return;
    delete[] *array;
    *array = nullptr;
}

void mavsdk_action_server_bool_array_destroy(bool** array) {
    if (!array || !*array) return;
    delete[] *array;
    *array = nullptr;
}


void mavsdk_action_server_string_destroy(char** str) {
    if (!str || !*str) return;
    free(*str);
    *str = nullptr;
}

void mavsdk_action_server_byte_buffer_destroy(uint8_t** buffer) {
    if (!buffer || !*buffer) return;
    delete[] *buffer;
    *buffer = nullptr;
}

// ===== ActionServer Wrapper =====

struct mavsdk_action_server_wrapper {
    std::shared_ptr<mavsdk::ActionServer> cpp_plugin;
};

mavsdk_action_server_t
mavsdk_action_server_create(mavsdk_server_component_t server_component) {
    if (server_component == nullptr) {
        return nullptr;
    }

    auto wrapper = new mavsdk_action_server_wrapper();
    auto server_component_ptr = reinterpret_cast<std::shared_ptr<mavsdk::ServerComponent>*>(server_component);
    wrapper->cpp_plugin = std::make_shared<mavsdk::ActionServer>(*server_component_ptr);

    return reinterpret_cast<mavsdk_action_server_t>(wrapper);
}

void mavsdk_action_server_destroy(mavsdk_action_server_t action_server) {
    if (action_server == nullptr) {
        return;
    }

    auto wrapper = reinterpret_cast<mavsdk_action_server_wrapper*>(action_server);
    delete wrapper;
}

// ===== Method Implementations =====

// ArmDisarm async
mavsdk_action_server_arm_disarm_handle_t mavsdk_action_server_subscribe_arm_disarm(
    mavsdk_action_server_t action_server,
    mavsdk_action_server_arm_disarm_callback_t callback,
    void* user_data)
{
    auto wrapper = reinterpret_cast<mavsdk_action_server_wrapper*>(action_server);

    auto cpp_handle =    wrapper->cpp_plugin->subscribe_arm_disarm(
        [callback, user_data](
            mavsdk::ActionServer::Result result,
            mavsdk::ActionServer::ArmDisarm value) {
                if (callback) {
                    callback(
                        translate_result(result),
                        translate_arm_disarm_to_c(value),
                        user_data);
                }
        });

    auto handle_wrapper = new mavsdk::ActionServer::ArmDisarmHandle(std::move(cpp_handle));
    return reinterpret_cast<mavsdk_action_server_arm_disarm_handle_t>(handle_wrapper);
}

void mavsdk_action_server_unsubscribe_arm_disarm(
    mavsdk_action_server_t action_server,
    mavsdk_action_server_arm_disarm_handle_t handle)
{
    if (handle) {
        auto wrapper = reinterpret_cast<mavsdk_action_server_wrapper*>(action_server);
        auto cpp_handle = reinterpret_cast<mavsdk::ActionServer::ArmDisarmHandle*>(handle);
        wrapper->cpp_plugin->unsubscribe_arm_disarm(std::move(*cpp_handle));
        delete cpp_handle;
    }
}


// FlightModeChange async
mavsdk_action_server_flight_mode_change_handle_t mavsdk_action_server_subscribe_flight_mode_change(
    mavsdk_action_server_t action_server,
    mavsdk_action_server_flight_mode_change_callback_t callback,
    void* user_data)
{
    auto wrapper = reinterpret_cast<mavsdk_action_server_wrapper*>(action_server);

    auto cpp_handle =    wrapper->cpp_plugin->subscribe_flight_mode_change(
        [callback, user_data](
            mavsdk::ActionServer::Result result,
            mavsdk::ActionServer::FlightMode value) {
                if (callback) {
                    callback(
                        translate_result(result),
                        translate_flight_mode_to_c(value),
                        user_data);
                }
        });

    auto handle_wrapper = new mavsdk::ActionServer::FlightModeChangeHandle(std::move(cpp_handle));
    return reinterpret_cast<mavsdk_action_server_flight_mode_change_handle_t>(handle_wrapper);
}

void mavsdk_action_server_unsubscribe_flight_mode_change(
    mavsdk_action_server_t action_server,
    mavsdk_action_server_flight_mode_change_handle_t handle)
{
    if (handle) {
        auto wrapper = reinterpret_cast<mavsdk_action_server_wrapper*>(action_server);
        auto cpp_handle = reinterpret_cast<mavsdk::ActionServer::FlightModeChangeHandle*>(handle);
        wrapper->cpp_plugin->unsubscribe_flight_mode_change(std::move(*cpp_handle));
        delete cpp_handle;
    }
}


// Takeoff async
mavsdk_action_server_takeoff_handle_t mavsdk_action_server_subscribe_takeoff(
    mavsdk_action_server_t action_server,
    mavsdk_action_server_takeoff_callback_t callback,
    void* user_data)
{
    auto wrapper = reinterpret_cast<mavsdk_action_server_wrapper*>(action_server);

    auto cpp_handle =    wrapper->cpp_plugin->subscribe_takeoff(
        [callback, user_data](
            mavsdk::ActionServer::Result result,
            bool value) {
                if (callback) {
                    callback(
                        translate_result(result),
                        value,
                        user_data);
                }
        });

    auto handle_wrapper = new mavsdk::ActionServer::TakeoffHandle(std::move(cpp_handle));
    return reinterpret_cast<mavsdk_action_server_takeoff_handle_t>(handle_wrapper);
}

void mavsdk_action_server_unsubscribe_takeoff(
    mavsdk_action_server_t action_server,
    mavsdk_action_server_takeoff_handle_t handle)
{
    if (handle) {
        auto wrapper = reinterpret_cast<mavsdk_action_server_wrapper*>(action_server);
        auto cpp_handle = reinterpret_cast<mavsdk::ActionServer::TakeoffHandle*>(handle);
        wrapper->cpp_plugin->unsubscribe_takeoff(std::move(*cpp_handle));
        delete cpp_handle;
    }
}


// Land async
mavsdk_action_server_land_handle_t mavsdk_action_server_subscribe_land(
    mavsdk_action_server_t action_server,
    mavsdk_action_server_land_callback_t callback,
    void* user_data)
{
    auto wrapper = reinterpret_cast<mavsdk_action_server_wrapper*>(action_server);

    auto cpp_handle =    wrapper->cpp_plugin->subscribe_land(
        [callback, user_data](
            mavsdk::ActionServer::Result result,
            bool value) {
                if (callback) {
                    callback(
                        translate_result(result),
                        value,
                        user_data);
                }
        });

    auto handle_wrapper = new mavsdk::ActionServer::LandHandle(std::move(cpp_handle));
    return reinterpret_cast<mavsdk_action_server_land_handle_t>(handle_wrapper);
}

void mavsdk_action_server_unsubscribe_land(
    mavsdk_action_server_t action_server,
    mavsdk_action_server_land_handle_t handle)
{
    if (handle) {
        auto wrapper = reinterpret_cast<mavsdk_action_server_wrapper*>(action_server);
        auto cpp_handle = reinterpret_cast<mavsdk::ActionServer::LandHandle*>(handle);
        wrapper->cpp_plugin->unsubscribe_land(std::move(*cpp_handle));
        delete cpp_handle;
    }
}


// Reboot async
mavsdk_action_server_reboot_handle_t mavsdk_action_server_subscribe_reboot(
    mavsdk_action_server_t action_server,
    mavsdk_action_server_reboot_callback_t callback,
    void* user_data)
{
    auto wrapper = reinterpret_cast<mavsdk_action_server_wrapper*>(action_server);

    auto cpp_handle =    wrapper->cpp_plugin->subscribe_reboot(
        [callback, user_data](
            mavsdk::ActionServer::Result result,
            bool value) {
                if (callback) {
                    callback(
                        translate_result(result),
                        value,
                        user_data);
                }
        });

    auto handle_wrapper = new mavsdk::ActionServer::RebootHandle(std::move(cpp_handle));
    return reinterpret_cast<mavsdk_action_server_reboot_handle_t>(handle_wrapper);
}

void mavsdk_action_server_unsubscribe_reboot(
    mavsdk_action_server_t action_server,
    mavsdk_action_server_reboot_handle_t handle)
{
    if (handle) {
        auto wrapper = reinterpret_cast<mavsdk_action_server_wrapper*>(action_server);
        auto cpp_handle = reinterpret_cast<mavsdk::ActionServer::RebootHandle*>(handle);
        wrapper->cpp_plugin->unsubscribe_reboot(std::move(*cpp_handle));
        delete cpp_handle;
    }
}


// Shutdown async
mavsdk_action_server_shutdown_handle_t mavsdk_action_server_subscribe_shutdown(
    mavsdk_action_server_t action_server,
    mavsdk_action_server_shutdown_callback_t callback,
    void* user_data)
{
    auto wrapper = reinterpret_cast<mavsdk_action_server_wrapper*>(action_server);

    auto cpp_handle =    wrapper->cpp_plugin->subscribe_shutdown(
        [callback, user_data](
            mavsdk::ActionServer::Result result,
            bool value) {
                if (callback) {
                    callback(
                        translate_result(result),
                        value,
                        user_data);
                }
        });

    auto handle_wrapper = new mavsdk::ActionServer::ShutdownHandle(std::move(cpp_handle));
    return reinterpret_cast<mavsdk_action_server_shutdown_handle_t>(handle_wrapper);
}

void mavsdk_action_server_unsubscribe_shutdown(
    mavsdk_action_server_t action_server,
    mavsdk_action_server_shutdown_handle_t handle)
{
    if (handle) {
        auto wrapper = reinterpret_cast<mavsdk_action_server_wrapper*>(action_server);
        auto cpp_handle = reinterpret_cast<mavsdk::ActionServer::ShutdownHandle*>(handle);
        wrapper->cpp_plugin->unsubscribe_shutdown(std::move(*cpp_handle));
        delete cpp_handle;
    }
}


// Terminate async
mavsdk_action_server_terminate_handle_t mavsdk_action_server_subscribe_terminate(
    mavsdk_action_server_t action_server,
    mavsdk_action_server_terminate_callback_t callback,
    void* user_data)
{
    auto wrapper = reinterpret_cast<mavsdk_action_server_wrapper*>(action_server);

    auto cpp_handle =    wrapper->cpp_plugin->subscribe_terminate(
        [callback, user_data](
            mavsdk::ActionServer::Result result,
            bool value) {
                if (callback) {
                    callback(
                        translate_result(result),
                        value,
                        user_data);
                }
        });

    auto handle_wrapper = new mavsdk::ActionServer::TerminateHandle(std::move(cpp_handle));
    return reinterpret_cast<mavsdk_action_server_terminate_handle_t>(handle_wrapper);
}

void mavsdk_action_server_unsubscribe_terminate(
    mavsdk_action_server_t action_server,
    mavsdk_action_server_terminate_handle_t handle)
{
    if (handle) {
        auto wrapper = reinterpret_cast<mavsdk_action_server_wrapper*>(action_server);
        auto cpp_handle = reinterpret_cast<mavsdk::ActionServer::TerminateHandle*>(handle);
        wrapper->cpp_plugin->unsubscribe_terminate(std::move(*cpp_handle));
        delete cpp_handle;
    }
}



// SetAllowTakeoff sync
mavsdk_action_server_result_t
mavsdk_action_server_set_allow_takeoff(
    mavsdk_action_server_t action_server,
    bool allow_takeoff)
{
    auto wrapper = reinterpret_cast<mavsdk_action_server_wrapper*>(action_server);

    auto ret_value = wrapper->cpp_plugin->set_allow_takeoff(        allow_takeoff);

    return translate_result(ret_value);
}


// SetArmable sync
mavsdk_action_server_result_t
mavsdk_action_server_set_armable(
    mavsdk_action_server_t action_server,
    bool armable,
    bool force_armable)
{
    auto wrapper = reinterpret_cast<mavsdk_action_server_wrapper*>(action_server);

    auto ret_value = wrapper->cpp_plugin->set_armable(        armable,        force_armable);

    return translate_result(ret_value);
}


// SetDisarmable sync
mavsdk_action_server_result_t
mavsdk_action_server_set_disarmable(
    mavsdk_action_server_t action_server,
    bool disarmable,
    bool force_disarmable)
{
    auto wrapper = reinterpret_cast<mavsdk_action_server_wrapper*>(action_server);

    auto ret_value = wrapper->cpp_plugin->set_disarmable(        disarmable,        force_disarmable);

    return translate_result(ret_value);
}


// SetAllowableFlightModes sync
mavsdk_action_server_result_t
mavsdk_action_server_set_allowable_flight_modes(
    mavsdk_action_server_t action_server,
    mavsdk_action_server_allowable_flight_modes_t flight_modes)
{
    auto wrapper = reinterpret_cast<mavsdk_action_server_wrapper*>(action_server);

    auto ret_value = wrapper->cpp_plugin->set_allowable_flight_modes(        translate_allowable_flight_modes_from_c(flight_modes));

    return translate_result(ret_value);
}


// GetAllowableFlightModes sync
void
mavsdk_action_server_get_allowable_flight_modes(
    mavsdk_action_server_t action_server,
    mavsdk_action_server_allowable_flight_modes_t* flight_modes_out)
{
    auto wrapper = reinterpret_cast<mavsdk_action_server_wrapper*>(action_server);

    auto ret_value = wrapper->cpp_plugin->get_allowable_flight_modes();

    if (flight_modes_out != nullptr) {
        *flight_modes_out = translate_allowable_flight_modes_to_c(ret_value);
    }
}


// SetArmedState sync
mavsdk_action_server_result_t
mavsdk_action_server_set_armed_state(
    mavsdk_action_server_t action_server,
    bool is_armed)
{
    auto wrapper = reinterpret_cast<mavsdk_action_server_wrapper*>(action_server);

    auto ret_value = wrapper->cpp_plugin->set_armed_state(        is_armed);

    return translate_result(ret_value);
}


// SetFlightMode sync
mavsdk_action_server_result_t
mavsdk_action_server_set_flight_mode(
    mavsdk_action_server_t action_server,
    mavsdk_action_server_flight_mode_t flight_mode)
{
    auto wrapper = reinterpret_cast<mavsdk_action_server_wrapper*>(action_server);

    auto ret_value = wrapper->cpp_plugin->set_flight_mode(        translate_flight_mode_from_c(flight_mode));

    return translate_result(ret_value);
}


// SetFlightModeInternal sync
mavsdk_action_server_result_t
mavsdk_action_server_set_flight_mode_internal(
    mavsdk_action_server_t action_server,
    mavsdk_action_server_flight_mode_t flight_mode)
{
    auto wrapper = reinterpret_cast<mavsdk_action_server_wrapper*>(action_server);

    auto ret_value = wrapper->cpp_plugin->set_flight_mode_internal(        translate_flight_mode_from_c(flight_mode));

    return translate_result(ret_value);
}
