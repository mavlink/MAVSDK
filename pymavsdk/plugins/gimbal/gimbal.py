# ruff: noqa: F401

# WARNING: THIS FILE IS AUTOGENERATED! As such, it should not be edited.
# Edits need to be made to the proto files
# (see https://github.com/mavlink/MAVSDK-Proto/blob/main/protos/gimbal/gimbal.proto)

"""
Provide control over a gimbal.
"""

import ctypes

from typing import Callable, Any
from enum import IntEnum

from ...cmavsdk_loader import _cmavsdk_lib


# ===== Enums =====
class GimbalMode(IntEnum):
    """Gimbal mode type."""

    YAW_FOLLOW = 0
    YAW_LOCK = 1


class ControlMode(IntEnum):
    """Control mode"""

    NONE = 0
    PRIMARY = 1
    SECONDARY = 2


class SendMode(IntEnum):
    """The send mode type"""

    ONCE = 0
    STREAM = 1


# ===== Result Enums =====
class GimbalResult(IntEnum):
    """Possible results returned for gimbal commands."""

    UNKNOWN = 0
    SUCCESS = 1
    ERROR = 2
    TIMEOUT = 3
    UNSUPPORTED = 4
    NO_SYSTEM = 5
    INVALID_ARGUMENT = 6


# ===== Internal C Structures =====
class QuaternionCStruct(ctypes.Structure):
    """
    Internal C structure for Quaternion.
    Used only for C library communication.
    """

    _fields_ = [
        ("w", ctypes.c_float),
        ("x", ctypes.c_float),
        ("y", ctypes.c_float),
        ("z", ctypes.c_float),
    ]


class EulerAngleCStruct(ctypes.Structure):
    """
    Internal C structure for EulerAngle.
    Used only for C library communication.
    """

    _fields_ = [
        ("roll_deg", ctypes.c_float),
        ("pitch_deg", ctypes.c_float),
        ("yaw_deg", ctypes.c_float),
    ]


class AngularVelocityBodyCStruct(ctypes.Structure):
    """
    Internal C structure for AngularVelocityBody.
    Used only for C library communication.
    """

    _fields_ = [
        ("roll_rad_s", ctypes.c_float),
        ("pitch_rad_s", ctypes.c_float),
        ("yaw_rad_s", ctypes.c_float),
    ]


class AttitudeCStruct(ctypes.Structure):
    """
    Internal C structure for Attitude.
    Used only for C library communication.
    """

    _fields_ = [
        ("gimbal_id", ctypes.c_int32),
        ("euler_angle_forward", EulerAngleCStruct),
        ("quaternion_forward", QuaternionCStruct),
        ("euler_angle_north", EulerAngleCStruct),
        ("quaternion_north", QuaternionCStruct),
        ("angular_velocity", AngularVelocityBodyCStruct),
        ("timestamp_us", ctypes.c_uint64),
    ]


class GimbalItemCStruct(ctypes.Structure):
    """
    Internal C structure for GimbalItem.
    Used only for C library communication.
    """

    _fields_ = [
        ("gimbal_id", ctypes.c_int32),
        ("vendor_name", ctypes.c_char_p),
        ("model_name", ctypes.c_char_p),
        ("custom_name", ctypes.c_char_p),
        ("gimbal_manager_component_id", ctypes.c_int32),
        ("gimbal_device_id", ctypes.c_int32),
    ]


class GimbalListCStruct(ctypes.Structure):
    """
    Internal C structure for GimbalList.
    Used only for C library communication.
    """

    _fields_ = [
        ("gimbals", ctypes.POINTER(GimbalItemCStruct)),
        ("gimbals_size", ctypes.c_size_t),
    ]


class ControlStatusCStruct(ctypes.Structure):
    """
    Internal C structure for ControlStatus.
    Used only for C library communication.
    """

    _fields_ = [
        ("gimbal_id", ctypes.c_int32),
        ("control_mode", ctypes.c_int),
        ("sysid_primary_control", ctypes.c_int32),
        ("compid_primary_control", ctypes.c_int32),
        ("sysid_secondary_control", ctypes.c_int32),
        ("compid_secondary_control", ctypes.c_int32),
    ]


# ===== Structures =====
class Quaternion:
    """
       Quaternion type.

    All rotations and axis systems follow the right-hand rule.
    The Hamilton quaternion product definition is used.
    A zero-rotation quaternion is represented by (1,0,0,0).
    The quaternion could also be written as w + xi + yj + zk.

    For more info see: https://en.wikipedia.org/wiki/Quaternion
    """

    def __init__(self, w=None, x=None, y=None, z=None):
        self.w = w
        self.x = x
        self.y = y
        self.z = z

    @classmethod
    def from_c_struct(cls, c_struct):
        """Convert from C structure to Python object"""
        instance = cls()
        instance.w = c_struct.w
        instance.x = c_struct.x
        instance.y = c_struct.y
        instance.z = c_struct.z
        return instance

    def to_c_struct(self):
        """Convert to C structure for C library calls"""
        c_struct = QuaternionCStruct()
        c_struct.w = self.w
        c_struct.x = self.x
        c_struct.y = self.y
        c_struct.z = self.z
        return c_struct

    def __str__(self):
        fields = []
        fields.append(f"w={self.w}")
        fields.append(f"x={self.x}")
        fields.append(f"y={self.y}")
        fields.append(f"z={self.z}")
        return f"Quaternion({', '.join(fields)})"


class EulerAngle:
    """
       Euler angle type.

    All rotations and axis systems follow the right-hand rule.
    The Euler angles are converted using the 3-1-2 sequence instead of standard 3-2-1 in order
    to avoid the gimbal lock at 90 degrees down.

    For more info see https://en.wikipedia.org/wiki/Euler_angles
    """

    def __init__(self, roll_deg=None, pitch_deg=None, yaw_deg=None):
        self.roll_deg = roll_deg
        self.pitch_deg = pitch_deg
        self.yaw_deg = yaw_deg

    @classmethod
    def from_c_struct(cls, c_struct):
        """Convert from C structure to Python object"""
        instance = cls()
        instance.roll_deg = c_struct.roll_deg
        instance.pitch_deg = c_struct.pitch_deg
        instance.yaw_deg = c_struct.yaw_deg
        return instance

    def to_c_struct(self):
        """Convert to C structure for C library calls"""
        c_struct = EulerAngleCStruct()
        c_struct.roll_deg = self.roll_deg
        c_struct.pitch_deg = self.pitch_deg
        c_struct.yaw_deg = self.yaw_deg
        return c_struct

    def __str__(self):
        fields = []
        fields.append(f"roll_deg={self.roll_deg}")
        fields.append(f"pitch_deg={self.pitch_deg}")
        fields.append(f"yaw_deg={self.yaw_deg}")
        return f"EulerAngle({', '.join(fields)})"


class AngularVelocityBody:
    """
    Gimbal angular rate type
    """

    def __init__(self, roll_rad_s=None, pitch_rad_s=None, yaw_rad_s=None):
        self.roll_rad_s = roll_rad_s
        self.pitch_rad_s = pitch_rad_s
        self.yaw_rad_s = yaw_rad_s

    @classmethod
    def from_c_struct(cls, c_struct):
        """Convert from C structure to Python object"""
        instance = cls()
        instance.roll_rad_s = c_struct.roll_rad_s
        instance.pitch_rad_s = c_struct.pitch_rad_s
        instance.yaw_rad_s = c_struct.yaw_rad_s
        return instance

    def to_c_struct(self):
        """Convert to C structure for C library calls"""
        c_struct = AngularVelocityBodyCStruct()
        c_struct.roll_rad_s = self.roll_rad_s
        c_struct.pitch_rad_s = self.pitch_rad_s
        c_struct.yaw_rad_s = self.yaw_rad_s
        return c_struct

    def __str__(self):
        fields = []
        fields.append(f"roll_rad_s={self.roll_rad_s}")
        fields.append(f"pitch_rad_s={self.pitch_rad_s}")
        fields.append(f"yaw_rad_s={self.yaw_rad_s}")
        return f"AngularVelocityBody({', '.join(fields)})"


class Attitude:
    """
    Gimbal attitude type
    """

    def __init__(
        self,
        gimbal_id=None,
        euler_angle_forward=None,
        quaternion_forward=None,
        euler_angle_north=None,
        quaternion_north=None,
        angular_velocity=None,
        timestamp_us=None,
    ):
        self.gimbal_id = gimbal_id
        self.euler_angle_forward = euler_angle_forward
        self.quaternion_forward = quaternion_forward
        self.euler_angle_north = euler_angle_north
        self.quaternion_north = quaternion_north
        self.angular_velocity = angular_velocity
        self.timestamp_us = timestamp_us

    @classmethod
    def from_c_struct(cls, c_struct):
        """Convert from C structure to Python object"""
        instance = cls()
        instance.gimbal_id = c_struct.gimbal_id
        instance.euler_angle_forward = EulerAngle.from_c_struct(
            c_struct.euler_angle_forward
        )
        instance.quaternion_forward = Quaternion.from_c_struct(
            c_struct.quaternion_forward
        )
        instance.euler_angle_north = EulerAngle.from_c_struct(
            c_struct.euler_angle_north
        )
        instance.quaternion_north = Quaternion.from_c_struct(c_struct.quaternion_north)
        instance.angular_velocity = AngularVelocityBody.from_c_struct(
            c_struct.angular_velocity
        )
        instance.timestamp_us = c_struct.timestamp_us
        return instance

    def to_c_struct(self):
        """Convert to C structure for C library calls"""
        c_struct = AttitudeCStruct()
        c_struct.gimbal_id = self.gimbal_id
        c_struct.euler_angle_forward = self.euler_angle_forward.to_c_struct()
        c_struct.quaternion_forward = self.quaternion_forward.to_c_struct()
        c_struct.euler_angle_north = self.euler_angle_north.to_c_struct()
        c_struct.quaternion_north = self.quaternion_north.to_c_struct()
        c_struct.angular_velocity = self.angular_velocity.to_c_struct()
        c_struct.timestamp_us = self.timestamp_us
        return c_struct

    def __str__(self):
        fields = []
        fields.append(f"gimbal_id={self.gimbal_id}")
        fields.append(f"euler_angle_forward={self.euler_angle_forward}")
        fields.append(f"quaternion_forward={self.quaternion_forward}")
        fields.append(f"euler_angle_north={self.euler_angle_north}")
        fields.append(f"quaternion_north={self.quaternion_north}")
        fields.append(f"angular_velocity={self.angular_velocity}")
        fields.append(f"timestamp_us={self.timestamp_us}")
        return f"Attitude({', '.join(fields)})"


class GimbalItem:
    """
    Gimbal list item
    """

    def __init__(
        self,
        gimbal_id=None,
        vendor_name=None,
        model_name=None,
        custom_name=None,
        gimbal_manager_component_id=None,
        gimbal_device_id=None,
    ):
        self.gimbal_id = gimbal_id
        self.vendor_name = vendor_name
        self.model_name = model_name
        self.custom_name = custom_name
        self.gimbal_manager_component_id = gimbal_manager_component_id
        self.gimbal_device_id = gimbal_device_id

    @classmethod
    def from_c_struct(cls, c_struct):
        """Convert from C structure to Python object"""
        instance = cls()
        instance.gimbal_id = c_struct.gimbal_id
        instance.vendor_name = c_struct.vendor_name.decode("utf-8")
        instance.model_name = c_struct.model_name.decode("utf-8")
        instance.custom_name = c_struct.custom_name.decode("utf-8")
        instance.gimbal_manager_component_id = c_struct.gimbal_manager_component_id
        instance.gimbal_device_id = c_struct.gimbal_device_id
        return instance

    def to_c_struct(self):
        """Convert to C structure for C library calls"""
        c_struct = GimbalItemCStruct()
        c_struct.gimbal_id = self.gimbal_id
        c_struct.vendor_name = self.vendor_name.encode("utf-8")
        c_struct.model_name = self.model_name.encode("utf-8")
        c_struct.custom_name = self.custom_name.encode("utf-8")
        c_struct.gimbal_manager_component_id = self.gimbal_manager_component_id
        c_struct.gimbal_device_id = self.gimbal_device_id
        return c_struct

    def __str__(self):
        fields = []
        fields.append(f"gimbal_id={self.gimbal_id}")
        fields.append(f"vendor_name={self.vendor_name}")
        fields.append(f"model_name={self.model_name}")
        fields.append(f"custom_name={self.custom_name}")
        fields.append(f"gimbal_manager_component_id={self.gimbal_manager_component_id}")
        fields.append(f"gimbal_device_id={self.gimbal_device_id}")
        return f"GimbalItem({', '.join(fields)})"


class GimbalList:
    """
    Gimbal list
    """

    def __init__(self, gimbals=None):
        self.gimbals = gimbals or []

    @classmethod
    def from_c_struct(cls, c_struct):
        """Convert from C structure to Python object"""
        instance = cls()
        if c_struct.gimbals_size > 0:
            instance.gimbals = [
                GimbalItem.from_c_struct(c_struct.gimbals[i])
                for i in range(c_struct.gimbals_size)
            ]
        else:
            instance.gimbals = []
        return instance

    def to_c_struct(self):
        """Convert to C structure for C library calls"""
        c_struct = GimbalListCStruct()
        array_type = GimbalItemCStruct * len(self.gimbals)
        c_array = array_type()
        for i, item in enumerate(self.gimbals):
            c_array[i] = item.to_c_struct()
        c_struct.gimbals = ctypes.cast(c_array, ctypes.POINTER(GimbalItemCStruct))
        c_struct.gimbals_size = len(self.gimbals)
        return c_struct

    def __str__(self):
        fields = []
        fields.append(f"gimbals={self.gimbals}")
        return f"GimbalList({', '.join(fields)})"


class ControlStatus:
    """
    Control status
    """

    def __init__(
        self,
        gimbal_id=None,
        control_mode=None,
        sysid_primary_control=None,
        compid_primary_control=None,
        sysid_secondary_control=None,
        compid_secondary_control=None,
    ):
        self.gimbal_id = gimbal_id
        self.control_mode = control_mode
        self.sysid_primary_control = sysid_primary_control
        self.compid_primary_control = compid_primary_control
        self.sysid_secondary_control = sysid_secondary_control
        self.compid_secondary_control = compid_secondary_control

    @classmethod
    def from_c_struct(cls, c_struct):
        """Convert from C structure to Python object"""
        instance = cls()
        instance.gimbal_id = c_struct.gimbal_id
        instance.control_mode = ControlMode(c_struct.control_mode)
        instance.sysid_primary_control = c_struct.sysid_primary_control
        instance.compid_primary_control = c_struct.compid_primary_control
        instance.sysid_secondary_control = c_struct.sysid_secondary_control
        instance.compid_secondary_control = c_struct.compid_secondary_control
        return instance

    def to_c_struct(self):
        """Convert to C structure for C library calls"""
        c_struct = ControlStatusCStruct()
        c_struct.gimbal_id = self.gimbal_id
        c_struct.control_mode = int(self.control_mode)
        c_struct.sysid_primary_control = self.sysid_primary_control
        c_struct.compid_primary_control = self.compid_primary_control
        c_struct.sysid_secondary_control = self.sysid_secondary_control
        c_struct.compid_secondary_control = self.compid_secondary_control
        return c_struct

    def __str__(self):
        fields = []
        fields.append(f"gimbal_id={self.gimbal_id}")
        fields.append(f"control_mode={self.control_mode}")
        fields.append(f"sysid_primary_control={self.sysid_primary_control}")
        fields.append(f"compid_primary_control={self.compid_primary_control}")
        fields.append(f"sysid_secondary_control={self.sysid_secondary_control}")
        fields.append(f"compid_secondary_control={self.compid_secondary_control}")
        return f"ControlStatus({', '.join(fields)})"


# ===== Plugin =====
class Gimbal:
    """Provide control over a gimbal."""

    def __init__(self, system):
        self._lib = _cmavsdk_lib
        self._handle = None
        self._callbacks = []  # Keep references to prevent GC

        if system is None:
            raise ValueError("system cannot be None")

        system_handle = system._handle

        if not system_handle:
            raise ValueError("system handle is null")

        self._handle = self._lib.mavsdk_gimbal_create(system_handle)

        if not self._handle:
            raise RuntimeError(
                "Failed to create Gimbal plugin - C function returned null handle"
            )

    def set_angles_async(
        self,
        gimbal_id,
        roll_deg,
        pitch_deg,
        yaw_deg,
        gimbal_mode,
        send_mode,
        callback: Callable,
        user_data: Any = None,
    ):
        """Set gimbal roll, pitch and yaw angles.

        This sets the desired roll, pitch and yaw angles of a gimbal.
        Will return when the command is accepted, however, it might
        take the gimbal longer to actually be set to the new angles.

        Note that the roll angle needs to be set to 0 when send_mode is Once."""

        def c_callback(result, ud):
            try:
                py_result = GimbalResult(result)

                callback(py_result, user_data)

            except Exception as e:
                print(f"Error in set_angles callback: {e}")

        cb = SetAnglesCallback(c_callback)
        self._callbacks.append(cb)

        self._lib.mavsdk_gimbal_set_angles_async(
            self._handle,
            gimbal_id,
            roll_deg,
            pitch_deg,
            yaw_deg,
            gimbal_mode,
            send_mode,
            cb,
            None,
        )

    def set_angles(
        self, gimbal_id, roll_deg, pitch_deg, yaw_deg, gimbal_mode, send_mode
    ):
        """Get set_angles (blocking)"""

        result_code = self._lib.mavsdk_gimbal_set_angles(
            self._handle,
            gimbal_id,
            roll_deg,
            pitch_deg,
            yaw_deg,
            gimbal_mode,
            send_mode,
        )
        result = GimbalResult(result_code)
        if result != GimbalResult.SUCCESS:
            raise Exception(f"set_angles failed: {result}")

        return result

    def set_angular_rates_async(
        self,
        gimbal_id,
        roll_rate_deg_s,
        pitch_rate_deg_s,
        yaw_rate_deg_s,
        gimbal_mode,
        send_mode,
        callback: Callable,
        user_data: Any = None,
    ):
        """Set gimbal angular rates.

        This sets the desired angular rates around roll, pitch and yaw axes of a gimbal.
        Will return when the command is accepted, however, it might
        take the gimbal longer to actually reach the angular rate.

        Note that the roll angle needs to be set to 0 when send_mode is Once."""

        def c_callback(result, ud):
            try:
                py_result = GimbalResult(result)

                callback(py_result, user_data)

            except Exception as e:
                print(f"Error in set_angular_rates callback: {e}")

        cb = SetAngularRatesCallback(c_callback)
        self._callbacks.append(cb)

        self._lib.mavsdk_gimbal_set_angular_rates_async(
            self._handle,
            gimbal_id,
            roll_rate_deg_s,
            pitch_rate_deg_s,
            yaw_rate_deg_s,
            gimbal_mode,
            send_mode,
            cb,
            None,
        )

    def set_angular_rates(
        self,
        gimbal_id,
        roll_rate_deg_s,
        pitch_rate_deg_s,
        yaw_rate_deg_s,
        gimbal_mode,
        send_mode,
    ):
        """Get set_angular_rates (blocking)"""

        result_code = self._lib.mavsdk_gimbal_set_angular_rates(
            self._handle,
            gimbal_id,
            roll_rate_deg_s,
            pitch_rate_deg_s,
            yaw_rate_deg_s,
            gimbal_mode,
            send_mode,
        )
        result = GimbalResult(result_code)
        if result != GimbalResult.SUCCESS:
            raise Exception(f"set_angular_rates failed: {result}")

        return result

    def set_roi_location_async(
        self,
        gimbal_id,
        latitude_deg,
        longitude_deg,
        altitude_m,
        callback: Callable,
        user_data: Any = None,
    ):
        """Set gimbal region of interest (ROI).

        This sets a region of interest that the gimbal will point to.
        The gimbal will continue to point to the specified region until it
        receives a new command.
        The function will return when the command is accepted, however, it might
        take the gimbal longer to actually rotate to the ROI."""

        def c_callback(result, ud):
            try:
                py_result = GimbalResult(result)

                callback(py_result, user_data)

            except Exception as e:
                print(f"Error in set_roi_location callback: {e}")

        cb = SetRoiLocationCallback(c_callback)
        self._callbacks.append(cb)

        self._lib.mavsdk_gimbal_set_roi_location_async(
            self._handle, gimbal_id, latitude_deg, longitude_deg, altitude_m, cb, None
        )

    def set_roi_location(self, gimbal_id, latitude_deg, longitude_deg, altitude_m):
        """Get set_roi_location (blocking)"""

        result_code = self._lib.mavsdk_gimbal_set_roi_location(
            self._handle,
            gimbal_id,
            latitude_deg,
            longitude_deg,
            altitude_m,
        )
        result = GimbalResult(result_code)
        if result != GimbalResult.SUCCESS:
            raise Exception(f"set_roi_location failed: {result}")

        return result

    def take_control_async(
        self, gimbal_id, control_mode, callback: Callable, user_data: Any = None
    ):
        """Take control.

        There can be only two components in control of a gimbal at any given time.
        One with "primary" control, and one with "secondary" control. The way the
        secondary control is implemented is not specified and hence depends on the
        vehicle.

        Components are expected to be cooperative, which means that they can
        override each other and should therefore do it carefully."""

        def c_callback(result, ud):
            try:
                py_result = GimbalResult(result)

                callback(py_result, user_data)

            except Exception as e:
                print(f"Error in take_control callback: {e}")

        cb = TakeControlCallback(c_callback)
        self._callbacks.append(cb)

        self._lib.mavsdk_gimbal_take_control_async(
            self._handle, gimbal_id, control_mode, cb, None
        )

    def take_control(self, gimbal_id, control_mode):
        """Get take_control (blocking)"""

        result_code = self._lib.mavsdk_gimbal_take_control(
            self._handle,
            gimbal_id,
            control_mode,
        )
        result = GimbalResult(result_code)
        if result != GimbalResult.SUCCESS:
            raise Exception(f"take_control failed: {result}")

        return result

    def release_control_async(
        self, gimbal_id, callback: Callable, user_data: Any = None
    ):
        """Release control.

        Release control, such that other components can control the gimbal."""

        def c_callback(result, ud):
            try:
                py_result = GimbalResult(result)

                callback(py_result, user_data)

            except Exception as e:
                print(f"Error in release_control callback: {e}")

        cb = ReleaseControlCallback(c_callback)
        self._callbacks.append(cb)

        self._lib.mavsdk_gimbal_release_control_async(self._handle, gimbal_id, cb, None)

    def release_control(self, gimbal_id):
        """Get release_control (blocking)"""

        result_code = self._lib.mavsdk_gimbal_release_control(
            self._handle,
            gimbal_id,
        )
        result = GimbalResult(result_code)
        if result != GimbalResult.SUCCESS:
            raise Exception(f"release_control failed: {result}")

        return result

    def subscribe_gimbal_list(self, callback: Callable, user_data: Any = None):
        """Subscribe to list of gimbals.

        This allows to find out what gimbals are connected to the system.
        Based on the gimbal ID, we can then address a specific gimbal."""

        def c_callback(c_data, ud):
            try:
                py_data = GimbalList.from_c_struct(c_data)

                self._lib.mavsdk_gimbal_gimbal_list_destroy(ctypes.byref(c_data))

                callback(py_data, user_data)

            except Exception as e:
                print(f"Error in gimbal_list callback: {e}")

        cb = GimbalListCallback(c_callback)
        self._callbacks.append(cb)

        return self._lib.mavsdk_gimbal_subscribe_gimbal_list(self._handle, cb, None)

    def unsubscribe_gimbal_list(self, handle: ctypes.c_void_p):
        """Unsubscribe from gimbal_list"""
        self._lib.mavsdk_gimbal_unsubscribe_gimbal_list(self._handle, handle)

    def gimbal_list(self):
        """Get gimbal_list (blocking)"""

        result_out = GimbalListCStruct()

        self._lib.mavsdk_gimbal_gimbal_list(self._handle, ctypes.byref(result_out))

        py_result = GimbalList.from_c_struct(result_out)
        self._lib.mavsdk_gimbal_gimbal_list_destroy(ctypes.byref(result_out))
        return py_result

    def subscribe_control_status(self, callback: Callable, user_data: Any = None):
        """Subscribe to control status updates.

        This allows a component to know if it has primary, secondary or
        no control over the gimbal. Also, it gives the system and component ids
        of the other components in control (if any)."""

        def c_callback(c_data, ud):
            try:
                py_data = ControlStatus.from_c_struct(c_data)

                self._lib.mavsdk_gimbal_control_status_destroy(ctypes.byref(c_data))

                callback(py_data, user_data)

            except Exception as e:
                print(f"Error in control_status callback: {e}")

        cb = ControlStatusCallback(c_callback)
        self._callbacks.append(cb)

        return self._lib.mavsdk_gimbal_subscribe_control_status(self._handle, cb, None)

    def unsubscribe_control_status(self, handle: ctypes.c_void_p):
        """Unsubscribe from control_status"""
        self._lib.mavsdk_gimbal_unsubscribe_control_status(self._handle, handle)

    def get_control_status(self, gimbal_id):
        """Get get_control_status (blocking)"""

        result_out = ControlStatusCStruct()

        result_code = self._lib.mavsdk_gimbal_get_control_status(
            self._handle, gimbal_id, ctypes.byref(result_out)
        )
        result = GimbalResult(result_code)
        if result != GimbalResult.SUCCESS:
            raise Exception(f"get_control_status failed: {result}")

        py_result = ControlStatus.from_c_struct(result_out)
        self._lib.mavsdk_gimbal_control_status_destroy(ctypes.byref(result_out))
        return py_result

    def subscribe_attitude(self, callback: Callable, user_data: Any = None):
        """Subscribe to attitude updates.

        This gets you the gimbal's attitude and angular rate."""

        def c_callback(c_data, ud):
            try:
                py_data = Attitude.from_c_struct(c_data)

                self._lib.mavsdk_gimbal_attitude_destroy(ctypes.byref(c_data))

                callback(py_data, user_data)

            except Exception as e:
                print(f"Error in attitude callback: {e}")

        cb = AttitudeCallback(c_callback)
        self._callbacks.append(cb)

        return self._lib.mavsdk_gimbal_subscribe_attitude(self._handle, cb, None)

    def unsubscribe_attitude(self, handle: ctypes.c_void_p):
        """Unsubscribe from attitude"""
        self._lib.mavsdk_gimbal_unsubscribe_attitude(self._handle, handle)

    def get_attitude(self, gimbal_id):
        """Get get_attitude (blocking)"""

        result_out = AttitudeCStruct()

        result_code = self._lib.mavsdk_gimbal_get_attitude(
            self._handle, gimbal_id, ctypes.byref(result_out)
        )
        result = GimbalResult(result_code)
        if result != GimbalResult.SUCCESS:
            raise Exception(f"get_attitude failed: {result}")

        py_result = Attitude.from_c_struct(result_out)
        self._lib.mavsdk_gimbal_attitude_destroy(ctypes.byref(result_out))
        return py_result

    def destroy(self):
        """Destroy the plugin instance"""
        if self._handle:
            self._lib.mavsdk_gimbal_destroy(self._handle)
            self._handle = None

    def __del__(self):
        self.destroy()


# ===== Callback Types =====
SetAnglesCallback = ctypes.CFUNCTYPE(None, ctypes.c_int, ctypes.c_void_p)
SetAngularRatesCallback = ctypes.CFUNCTYPE(None, ctypes.c_int, ctypes.c_void_p)
SetRoiLocationCallback = ctypes.CFUNCTYPE(None, ctypes.c_int, ctypes.c_void_p)
TakeControlCallback = ctypes.CFUNCTYPE(None, ctypes.c_int, ctypes.c_void_p)
ReleaseControlCallback = ctypes.CFUNCTYPE(None, ctypes.c_int, ctypes.c_void_p)
GimbalListCallback = ctypes.CFUNCTYPE(None, GimbalListCStruct, ctypes.c_void_p)
ControlStatusCallback = ctypes.CFUNCTYPE(None, ControlStatusCStruct, ctypes.c_void_p)
AttitudeCallback = ctypes.CFUNCTYPE(None, AttitudeCStruct, ctypes.c_void_p)

# ===== Setup Functions =====
_cmavsdk_lib.mavsdk_gimbal_create.argtypes = [ctypes.c_void_p]
_cmavsdk_lib.mavsdk_gimbal_create.restype = ctypes.c_void_p

_cmavsdk_lib.mavsdk_gimbal_destroy.argtypes = [ctypes.c_void_p]
_cmavsdk_lib.mavsdk_gimbal_destroy.restype = None

_cmavsdk_lib.mavsdk_gimbal_quaternion_destroy.argtypes = [
    ctypes.POINTER(QuaternionCStruct)
]
_cmavsdk_lib.mavsdk_gimbal_quaternion_destroy.restype = None

_cmavsdk_lib.mavsdk_gimbal_euler_angle_destroy.argtypes = [
    ctypes.POINTER(EulerAngleCStruct)
]
_cmavsdk_lib.mavsdk_gimbal_euler_angle_destroy.restype = None

_cmavsdk_lib.mavsdk_gimbal_angular_velocity_body_destroy.argtypes = [
    ctypes.POINTER(AngularVelocityBodyCStruct)
]
_cmavsdk_lib.mavsdk_gimbal_angular_velocity_body_destroy.restype = None

_cmavsdk_lib.mavsdk_gimbal_attitude_destroy.argtypes = [ctypes.POINTER(AttitudeCStruct)]
_cmavsdk_lib.mavsdk_gimbal_attitude_destroy.restype = None

_cmavsdk_lib.mavsdk_gimbal_gimbal_item_destroy.argtypes = [
    ctypes.POINTER(GimbalItemCStruct)
]
_cmavsdk_lib.mavsdk_gimbal_gimbal_item_destroy.restype = None

_cmavsdk_lib.mavsdk_gimbal_gimbal_list_destroy.argtypes = [
    ctypes.POINTER(GimbalListCStruct)
]
_cmavsdk_lib.mavsdk_gimbal_gimbal_list_destroy.restype = None

_cmavsdk_lib.mavsdk_gimbal_control_status_destroy.argtypes = [
    ctypes.POINTER(ControlStatusCStruct)
]
_cmavsdk_lib.mavsdk_gimbal_control_status_destroy.restype = None


_cmavsdk_lib.mavsdk_gimbal_set_angles_async.argtypes = [
    ctypes.c_void_p,
    ctypes.c_int32,
    ctypes.c_float,
    ctypes.c_float,
    ctypes.c_float,
    ctypes.c_int,
    ctypes.c_int,
    SetAnglesCallback,
    ctypes.c_void_p,
]

_cmavsdk_lib.mavsdk_gimbal_set_angles_async.restype = None

_cmavsdk_lib.mavsdk_gimbal_set_angles.argtypes = [
    ctypes.c_void_p,
    ctypes.c_int32,
    ctypes.c_float,
    ctypes.c_float,
    ctypes.c_float,
    ctypes.c_int,
    ctypes.c_int,
]

_cmavsdk_lib.mavsdk_gimbal_set_angles.restype = ctypes.c_int
_cmavsdk_lib.mavsdk_gimbal_set_angular_rates_async.argtypes = [
    ctypes.c_void_p,
    ctypes.c_int32,
    ctypes.c_float,
    ctypes.c_float,
    ctypes.c_float,
    ctypes.c_int,
    ctypes.c_int,
    SetAngularRatesCallback,
    ctypes.c_void_p,
]

_cmavsdk_lib.mavsdk_gimbal_set_angular_rates_async.restype = None

_cmavsdk_lib.mavsdk_gimbal_set_angular_rates.argtypes = [
    ctypes.c_void_p,
    ctypes.c_int32,
    ctypes.c_float,
    ctypes.c_float,
    ctypes.c_float,
    ctypes.c_int,
    ctypes.c_int,
]

_cmavsdk_lib.mavsdk_gimbal_set_angular_rates.restype = ctypes.c_int
_cmavsdk_lib.mavsdk_gimbal_set_roi_location_async.argtypes = [
    ctypes.c_void_p,
    ctypes.c_int32,
    ctypes.c_double,
    ctypes.c_double,
    ctypes.c_float,
    SetRoiLocationCallback,
    ctypes.c_void_p,
]

_cmavsdk_lib.mavsdk_gimbal_set_roi_location_async.restype = None

_cmavsdk_lib.mavsdk_gimbal_set_roi_location.argtypes = [
    ctypes.c_void_p,
    ctypes.c_int32,
    ctypes.c_double,
    ctypes.c_double,
    ctypes.c_float,
]

_cmavsdk_lib.mavsdk_gimbal_set_roi_location.restype = ctypes.c_int
_cmavsdk_lib.mavsdk_gimbal_take_control_async.argtypes = [
    ctypes.c_void_p,
    ctypes.c_int32,
    ctypes.c_int,
    TakeControlCallback,
    ctypes.c_void_p,
]

_cmavsdk_lib.mavsdk_gimbal_take_control_async.restype = None

_cmavsdk_lib.mavsdk_gimbal_take_control.argtypes = [
    ctypes.c_void_p,
    ctypes.c_int32,
    ctypes.c_int,
]

_cmavsdk_lib.mavsdk_gimbal_take_control.restype = ctypes.c_int
_cmavsdk_lib.mavsdk_gimbal_release_control_async.argtypes = [
    ctypes.c_void_p,
    ctypes.c_int32,
    ReleaseControlCallback,
    ctypes.c_void_p,
]

_cmavsdk_lib.mavsdk_gimbal_release_control_async.restype = None

_cmavsdk_lib.mavsdk_gimbal_release_control.argtypes = [
    ctypes.c_void_p,
    ctypes.c_int32,
]

_cmavsdk_lib.mavsdk_gimbal_release_control.restype = ctypes.c_int
_cmavsdk_lib.mavsdk_gimbal_subscribe_gimbal_list.argtypes = [
    ctypes.c_void_p,
    GimbalListCallback,
    ctypes.c_void_p,
]

_cmavsdk_lib.mavsdk_gimbal_subscribe_gimbal_list.restype = ctypes.c_void_p
# Unsubscribe
_cmavsdk_lib.mavsdk_gimbal_unsubscribe_gimbal_list.argtypes = [
    ctypes.c_void_p,
    ctypes.c_void_p,
]

_cmavsdk_lib.mavsdk_gimbal_unsubscribe_gimbal_list.restype = None

_cmavsdk_lib.mavsdk_gimbal_gimbal_list.argtypes = [
    ctypes.c_void_p,
    ctypes.POINTER(GimbalListCStruct),
]

_cmavsdk_lib.mavsdk_gimbal_gimbal_list.restype = None
_cmavsdk_lib.mavsdk_gimbal_subscribe_control_status.argtypes = [
    ctypes.c_void_p,
    ControlStatusCallback,
    ctypes.c_void_p,
]

_cmavsdk_lib.mavsdk_gimbal_subscribe_control_status.restype = ctypes.c_void_p
# Unsubscribe
_cmavsdk_lib.mavsdk_gimbal_unsubscribe_control_status.argtypes = [
    ctypes.c_void_p,
    ctypes.c_void_p,
]

_cmavsdk_lib.mavsdk_gimbal_unsubscribe_control_status.restype = None


_cmavsdk_lib.mavsdk_gimbal_get_control_status.argtypes = [
    ctypes.c_void_p,
    ctypes.c_int32,
    ctypes.POINTER(ControlStatusCStruct),
]

_cmavsdk_lib.mavsdk_gimbal_get_control_status.restype = ctypes.c_int
_cmavsdk_lib.mavsdk_gimbal_subscribe_attitude.argtypes = [
    ctypes.c_void_p,
    AttitudeCallback,
    ctypes.c_void_p,
]

_cmavsdk_lib.mavsdk_gimbal_subscribe_attitude.restype = ctypes.c_void_p
# Unsubscribe
_cmavsdk_lib.mavsdk_gimbal_unsubscribe_attitude.argtypes = [
    ctypes.c_void_p,
    ctypes.c_void_p,
]

_cmavsdk_lib.mavsdk_gimbal_unsubscribe_attitude.restype = None


_cmavsdk_lib.mavsdk_gimbal_get_attitude.argtypes = [
    ctypes.c_void_p,
    ctypes.c_int32,
    ctypes.POINTER(AttitudeCStruct),
]

_cmavsdk_lib.mavsdk_gimbal_get_attitude.restype = ctypes.c_int
