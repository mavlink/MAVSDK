# WARNING: THIS FILE IS AUTOGENERATED! As such, it should not be edited.
# Edits need to be made to the proto files
# (see https://github.com/mavlink/MAVSDK-Proto/blob/main/protos/gimbal/gimbal.proto)

"""
Provide control over a gimbal.
"""

import ctypes

from typing import Optional, List, Callable, Any
from enum import IntEnum

from ...cmavsdk_loader import _cmavsdk_lib


# ===== Enums =====
class GimbalMode(IntEnum):
    """Gimbal mode type."""
    YAW_FOLLOW = 0
    YAW_LOCK = 1

class ControlMode(IntEnum):
    """Control mode"""
    NONE = 0
    PRIMARY = 1
    SECONDARY = 2

class SendMode(IntEnum):
    """The send mode type"""
    ONCE = 0
    STREAM = 1


# ===== Result Enums =====
class GimbalResult(IntEnum):
    """Possible results returned for gimbal commands."""
    UNKNOWN = 0
    SUCCESS = 1
    ERROR = 2
    TIMEOUT = 3
    UNSUPPORTED = 4
    NO_SYSTEM = 5
    INVALID_ARGUMENT = 6


# ===== Internal C Structures =====
class QuaternionCStruct(ctypes.Structure):
    """
    Internal C structure for Quaternion.
    Used only for C library communication.
    """
    _fields_ = [
        ("w", ctypes.c_float),
        ("x", ctypes.c_float),
        ("y", ctypes.c_float),
        ("z", ctypes.c_float),
    ]

class EulerAngleCStruct(ctypes.Structure):
    """
    Internal C structure for EulerAngle.
    Used only for C library communication.
    """
    _fields_ = [
        ("roll_deg", ctypes.c_float),
        ("pitch_deg", ctypes.c_float),
        ("yaw_deg", ctypes.c_float),
    ]

class AngularVelocityBodyCStruct(ctypes.Structure):
    """
    Internal C structure for AngularVelocityBody.
    Used only for C library communication.
    """
    _fields_ = [
        ("roll_rad_s", ctypes.c_float),
        ("pitch_rad_s", ctypes.c_float),
        ("yaw_rad_s", ctypes.c_float),
    ]

class AttitudeCStruct(ctypes.Structure):
    """
    Internal C structure for Attitude.
    Used only for C library communication.
    """
    _fields_ = [
        ("gimbal_id", ctypes.c_int32),
        ("euler_angle_forward", EulerAngleCStruct),
        ("quaternion_forward", QuaternionCStruct),
        ("euler_angle_north", EulerAngleCStruct),
        ("quaternion_north", QuaternionCStruct),
        ("angular_velocity", AngularVelocityBodyCStruct),
        ("timestamp_us", ctypes.c_uint64),
    ]

class GimbalItemCStruct(ctypes.Structure):
    """
    Internal C structure for GimbalItem.
    Used only for C library communication.
    """
    _fields_ = [
        ("gimbal_id", ctypes.c_int32),
        ("vendor_name", ctypes.c_char_p),
        ("model_name", ctypes.c_char_p),
        ("custom_name", ctypes.c_char_p),
        ("gimbal_manager_component_id", ctypes.c_int32),
        ("gimbal_device_id", ctypes.c_int32),
    ]

class GimbalListCStruct(ctypes.Structure):
    """
    Internal C structure for GimbalList.
    Used only for C library communication.
    """
    _fields_ = [
        ("gimbals", ctypes.POINTER(GimbalItemCStruct)),
        ("gimbals_size", ctypes.c_size_t),
    ]

class ControlStatusCStruct(ctypes.Structure):
    """
    Internal C structure for ControlStatus.
    Used only for C library communication.
    """
    _fields_ = [
        ("gimbal_id", ctypes.c_int32),
        ("control_mode", ctypes.c_int),
        ("sysid_primary_control", ctypes.c_int32),
        ("compid_primary_control", ctypes.c_int32),
        ("sysid_secondary_control", ctypes.c_int32),
        ("compid_secondary_control", ctypes.c_int32),
    ]


# ===== Structures =====
class Quaternion:
    """
    Quaternion type.

 All rotations and axis systems follow the right-hand rule.
 The Hamilton quaternion product definition is used.
 A zero-rotation quaternion is represented by (1,0,0,0).
 The quaternion could also be written as w + xi + yj + zk.

 For more info see: https://en.wikipedia.org/wiki/Quaternion
    """

    def __init__(self, w=None, x=None, y=None, z=None):
        self.w = w
        self.x = x
        self.y = y
        self.z = z

    @classmethod
    def from_c_struct(cls, c_struct):
        """Convert from C structure to Python object"""
        instance = cls()
        instance.w = c_struct.w
        instance.x = c_struct.x
        instance.y = c_struct.y
        instance.z = c_struct.z
        return instance

    def to_c_struct(self):
        """Convert to C structure for C library calls"""
        c_struct = QuaternionCStruct()
        # Check for None values in primitive types
        if self.w is None:
            raise ValueError(f"Field 'w' must be set before converting to C struct")
        c_struct.w = self.w
        # Check for None values in primitive types
        if self.x is None:
            raise ValueError(f"Field 'x' must be set before converting to C struct")
        c_struct.x = self.x
        # Check for None values in primitive types
        if self.y is None:
            raise ValueError(f"Field 'y' must be set before converting to C struct")
        c_struct.y = self.y
        # Check for None values in primitive types
        if self.z is None:
            raise ValueError(f"Field 'z' must be set before converting to C struct")
        c_struct.z = self.z
        return c_struct

    def __str__(self):
        fields = []
        fields.append(f"w={self.w}")
        fields.append(f"x={self.x}")
        fields.append(f"y={self.y}")
        fields.append(f"z={self.z}")
        return f"Quaternion({', '.join(fields)})"

class EulerAngle:
    """
    Euler angle type.

 All rotations and axis systems follow the right-hand rule.
 The Euler angles are converted using the 3-1-2 sequence instead of standard 3-2-1 in order
 to avoid the gimbal lock at 90 degrees down.

 For more info see https://en.wikipedia.org/wiki/Euler_angles
    """

    def __init__(self, roll_deg=None, pitch_deg=None, yaw_deg=None):
        self.roll_deg = roll_deg
        self.pitch_deg = pitch_deg
        self.yaw_deg = yaw_deg

    @classmethod
    def from_c_struct(cls, c_struct):
        """Convert from C structure to Python object"""
        instance = cls()
        instance.roll_deg = c_struct.roll_deg
        instance.pitch_deg = c_struct.pitch_deg
        instance.yaw_deg = c_struct.yaw_deg
        return instance

    def to_c_struct(self):
        """Convert to C structure for C library calls"""
        c_struct = EulerAngleCStruct()
        # Check for None values in primitive types
        if self.roll_deg is None:
            raise ValueError(f"Field 'roll_deg' must be set before converting to C struct")
        c_struct.roll_deg = self.roll_deg
        # Check for None values in primitive types
        if self.pitch_deg is None:
            raise ValueError(f"Field 'pitch_deg' must be set before converting to C struct")
        c_struct.pitch_deg = self.pitch_deg
        # Check for None values in primitive types
        if self.yaw_deg is None:
            raise ValueError(f"Field 'yaw_deg' must be set before converting to C struct")
        c_struct.yaw_deg = self.yaw_deg
        return c_struct

    def __str__(self):
        fields = []
        fields.append(f"roll_deg={self.roll_deg}")
        fields.append(f"pitch_deg={self.pitch_deg}")
        fields.append(f"yaw_deg={self.yaw_deg}")
        return f"EulerAngle({', '.join(fields)})"

class AngularVelocityBody:
    """
    Gimbal angular rate type
    """

    def __init__(self, roll_rad_s=None, pitch_rad_s=None, yaw_rad_s=None):
        self.roll_rad_s = roll_rad_s
        self.pitch_rad_s = pitch_rad_s
        self.yaw_rad_s = yaw_rad_s

    @classmethod
    def from_c_struct(cls, c_struct):
        """Convert from C structure to Python object"""
        instance = cls()
        instance.roll_rad_s = c_struct.roll_rad_s
        instance.pitch_rad_s = c_struct.pitch_rad_s
        instance.yaw_rad_s = c_struct.yaw_rad_s
        return instance

    def to_c_struct(self):
        """Convert to C structure for C library calls"""
        c_struct = AngularVelocityBodyCStruct()
        # Check for None values in primitive types
        if self.roll_rad_s is None:
            raise ValueError(f"Field 'roll_rad_s' must be set before converting to C struct")
        c_struct.roll_rad_s = self.roll_rad_s
        # Check for None values in primitive types
        if self.pitch_rad_s is None:
            raise ValueError(f"Field 'pitch_rad_s' must be set before converting to C struct")
        c_struct.pitch_rad_s = self.pitch_rad_s
        # Check for None values in primitive types
        if self.yaw_rad_s is None:
            raise ValueError(f"Field 'yaw_rad_s' must be set before converting to C struct")
        c_struct.yaw_rad_s = self.yaw_rad_s
        return c_struct

    def __str__(self):
        fields = []
        fields.append(f"roll_rad_s={self.roll_rad_s}")
        fields.append(f"pitch_rad_s={self.pitch_rad_s}")
        fields.append(f"yaw_rad_s={self.yaw_rad_s}")
        return f"AngularVelocityBody({', '.join(fields)})"

class Attitude:
    """
    Gimbal attitude type
    """

    def __init__(self, gimbal_id=None, euler_angle_forward=None, quaternion_forward=None, euler_angle_north=None, quaternion_north=None, angular_velocity=None, timestamp_us=None):
        self.gimbal_id = gimbal_id
        self.euler_angle_forward = euler_angle_forward
        self.quaternion_forward = quaternion_forward
        self.euler_angle_north = euler_angle_north
        self.quaternion_north = quaternion_north
        self.angular_velocity = angular_velocity
        self.timestamp_us = timestamp_us

    @classmethod
    def from_c_struct(cls, c_struct):
        """Convert from C structure to Python object"""
        instance = cls()
        instance.gimbal_id = c_struct.gimbal_id
        # Convert nested C struct to Python object
        instance.euler_angle_forward = EulerAngle.from_c_struct(c_struct.euler_angle_forward)
        # Convert nested C struct to Python object
        instance.quaternion_forward = Quaternion.from_c_struct(c_struct.quaternion_forward)
        # Convert nested C struct to Python object
        instance.euler_angle_north = EulerAngle.from_c_struct(c_struct.euler_angle_north)
        # Convert nested C struct to Python object
        instance.quaternion_north = Quaternion.from_c_struct(c_struct.quaternion_north)
        # Convert nested C struct to Python object
        instance.angular_velocity = AngularVelocityBody.from_c_struct(c_struct.angular_velocity)
        instance.timestamp_us = c_struct.timestamp_us
        return instance

    def to_c_struct(self):
        """Convert to C structure for C library calls"""
        c_struct = AttitudeCStruct()
        # Check for None values in primitive types
        if self.gimbal_id is None:
            raise ValueError(f"Field 'gimbal_id' must be set before converting to C struct")
        c_struct.gimbal_id = self.gimbal_id
        # Convert nested Python object to C struct
        if self.euler_angle_forward is not None:
            c_struct.euler_angle_forward = self.euler_angle_forward.to_c_struct()
        # Convert nested Python object to C struct
        if self.quaternion_forward is not None:
            c_struct.quaternion_forward = self.quaternion_forward.to_c_struct()
        # Convert nested Python object to C struct
        if self.euler_angle_north is not None:
            c_struct.euler_angle_north = self.euler_angle_north.to_c_struct()
        # Convert nested Python object to C struct
        if self.quaternion_north is not None:
            c_struct.quaternion_north = self.quaternion_north.to_c_struct()
        # Convert nested Python object to C struct
        if self.angular_velocity is not None:
            c_struct.angular_velocity = self.angular_velocity.to_c_struct()
        # Check for None values in primitive types
        if self.timestamp_us is None:
            raise ValueError(f"Field 'timestamp_us' must be set before converting to C struct")
        c_struct.timestamp_us = self.timestamp_us
        return c_struct

    def __str__(self):
        fields = []
        fields.append(f"gimbal_id={self.gimbal_id}")
        fields.append(f"euler_angle_forward={self.euler_angle_forward}")
        fields.append(f"quaternion_forward={self.quaternion_forward}")
        fields.append(f"euler_angle_north={self.euler_angle_north}")
        fields.append(f"quaternion_north={self.quaternion_north}")
        fields.append(f"angular_velocity={self.angular_velocity}")
        fields.append(f"timestamp_us={self.timestamp_us}")
        return f"Attitude({', '.join(fields)})"

class GimbalItem:
    """
    Gimbal list item
    """

    def __init__(self, gimbal_id=None, vendor_name=None, model_name=None, custom_name=None, gimbal_manager_component_id=None, gimbal_device_id=None):
        self.gimbal_id = gimbal_id
        self.vendor_name = vendor_name
        self.model_name = model_name
        self.custom_name = custom_name
        self.gimbal_manager_component_id = gimbal_manager_component_id
        self.gimbal_device_id = gimbal_device_id

    @classmethod
    def from_c_struct(cls, c_struct):
        """Convert from C structure to Python object"""
        instance = cls()
        instance.gimbal_id = c_struct.gimbal_id
        # Convert C string to Python string
        instance.vendor_name = c_struct.vendor_name.decode('utf-8')
        # Convert C string to Python string
        instance.model_name = c_struct.model_name.decode('utf-8')
        # Convert C string to Python string
        instance.custom_name = c_struct.custom_name.decode('utf-8')
        instance.gimbal_manager_component_id = c_struct.gimbal_manager_component_id
        instance.gimbal_device_id = c_struct.gimbal_device_id
        return instance

    def to_c_struct(self):
        """Convert to C structure for C library calls"""
        c_struct = GimbalItemCStruct()
        # Check for None values in primitive types
        if self.gimbal_id is None:
            raise ValueError(f"Field 'gimbal_id' must be set before converting to C struct")
        c_struct.gimbal_id = self.gimbal_id
        # Convert Python string to C string (bytes)
        c_struct.vendor_name = self.vendor_name.encode('utf-8')
        # Convert Python string to C string (bytes)
        c_struct.model_name = self.model_name.encode('utf-8')
        # Convert Python string to C string (bytes)
        c_struct.custom_name = self.custom_name.encode('utf-8')
        # Check for None values in primitive types
        if self.gimbal_manager_component_id is None:
            raise ValueError(f"Field 'gimbal_manager_component_id' must be set before converting to C struct")
        c_struct.gimbal_manager_component_id = self.gimbal_manager_component_id
        # Check for None values in primitive types
        if self.gimbal_device_id is None:
            raise ValueError(f"Field 'gimbal_device_id' must be set before converting to C struct")
        c_struct.gimbal_device_id = self.gimbal_device_id
        return c_struct

    def __str__(self):
        fields = []
        fields.append(f"gimbal_id={self.gimbal_id}")
        fields.append(f"vendor_name={self.vendor_name}")
        fields.append(f"model_name={self.model_name}")
        fields.append(f"custom_name={self.custom_name}")
        fields.append(f"gimbal_manager_component_id={self.gimbal_manager_component_id}")
        fields.append(f"gimbal_device_id={self.gimbal_device_id}")
        return f"GimbalItem({', '.join(fields)})"

class GimbalList:
    """
    Gimbal list
    """

    def __init__(self, gimbals=None):
        self.gimbals = gimbals or []

    @classmethod
    def from_c_struct(cls, c_struct):
        """Convert from C structure to Python object"""
        instance = cls()
        # Convert array of C structs to Python objects
        if c_struct.gimbals_size > 0:
            instance.gimbals = [GimbalItem.from_c_struct(c_struct.gimbals[i]) for i in range(c_struct.gimbals_size)]
        else:
            instance.gimbals = []
        return instance

    def to_c_struct(self):
        """Convert to C structure for C library calls"""
        c_struct = GimbalListCStruct()
        # Convert list of Python objects to C array
        if self.gimbals:
            array_type = GimbalItemCStruct * len(self.gimbals)
            c_array = array_type()
            for i, item in enumerate(self.gimbals):
                c_array[i] = item.to_c_struct()
            c_struct.gimbals = ctypes.cast(c_array, ctypes.POINTER(GimbalItemCStruct))
            c_struct.gimbals_size = len(self.gimbals)
        else:
            c_struct.gimbals = None
            c_struct.gimbals_size = 0
        return c_struct

    def __str__(self):
        fields = []
        fields.append(f"gimbals={self.gimbals}")
        return f"GimbalList({', '.join(fields)})"

class ControlStatus:
    """
    Control status
    """

    def __init__(self, gimbal_id=None, control_mode=None, sysid_primary_control=None, compid_primary_control=None, sysid_secondary_control=None, compid_secondary_control=None):
        self.gimbal_id = gimbal_id
        self.control_mode = control_mode
        self.sysid_primary_control = sysid_primary_control
        self.compid_primary_control = compid_primary_control
        self.sysid_secondary_control = sysid_secondary_control
        self.compid_secondary_control = compid_secondary_control

    @classmethod
    def from_c_struct(cls, c_struct):
        """Convert from C structure to Python object"""
        instance = cls()
        instance.gimbal_id = c_struct.gimbal_id
        # Convert C enum to Python enum
        instance.control_mode = ControlMode(c_struct.control_mode)
        instance.sysid_primary_control = c_struct.sysid_primary_control
        instance.compid_primary_control = c_struct.compid_primary_control
        instance.sysid_secondary_control = c_struct.sysid_secondary_control
        instance.compid_secondary_control = c_struct.compid_secondary_control
        return instance

    def to_c_struct(self):
        """Convert to C structure for C library calls"""
        c_struct = ControlStatusCStruct()
        # Check for None values in primitive types
        if self.gimbal_id is None:
            raise ValueError(f"Field 'gimbal_id' must be set before converting to C struct")
        c_struct.gimbal_id = self.gimbal_id
        # Check for None values in enum types
        if self.control_mode is None:
            raise ValueError(f"Field 'control_mode' must be set before converting to C struct")
        c_struct.control_mode = int(self.control_mode)
        # Check for None values in primitive types
        if self.sysid_primary_control is None:
            raise ValueError(f"Field 'sysid_primary_control' must be set before converting to C struct")
        c_struct.sysid_primary_control = self.sysid_primary_control
        # Check for None values in primitive types
        if self.compid_primary_control is None:
            raise ValueError(f"Field 'compid_primary_control' must be set before converting to C struct")
        c_struct.compid_primary_control = self.compid_primary_control
        # Check for None values in primitive types
        if self.sysid_secondary_control is None:
            raise ValueError(f"Field 'sysid_secondary_control' must be set before converting to C struct")
        c_struct.sysid_secondary_control = self.sysid_secondary_control
        # Check for None values in primitive types
        if self.compid_secondary_control is None:
            raise ValueError(f"Field 'compid_secondary_control' must be set before converting to C struct")
        c_struct.compid_secondary_control = self.compid_secondary_control
        return c_struct

    def __str__(self):
        fields = []
        fields.append(f"gimbal_id={self.gimbal_id}")
        fields.append(f"control_mode={self.control_mode}")
        fields.append(f"sysid_primary_control={self.sysid_primary_control}")
        fields.append(f"compid_primary_control={self.compid_primary_control}")
        fields.append(f"sysid_secondary_control={self.sysid_secondary_control}")
        fields.append(f"compid_secondary_control={self.compid_secondary_control}")
        return f"ControlStatus({', '.join(fields)})"


# ===== Callback Types =====
SetAnglesCallback = ctypes.CFUNCTYPE(
    None,
ctypes.c_int,    ctypes.c_void_p
)
SetAngularRatesCallback = ctypes.CFUNCTYPE(
    None,
ctypes.c_int,    ctypes.c_void_p
)
SetRoiLocationCallback = ctypes.CFUNCTYPE(
    None,
ctypes.c_int,    ctypes.c_void_p
)
TakeControlCallback = ctypes.CFUNCTYPE(
    None,
ctypes.c_int,    ctypes.c_void_p
)
ReleaseControlCallback = ctypes.CFUNCTYPE(
    None,
ctypes.c_int,    ctypes.c_void_p
)
GimbalListCallback = ctypes.CFUNCTYPE(
    None,
    GimbalListCStruct,
    ctypes.c_void_p
)
ControlStatusCallback = ctypes.CFUNCTYPE(
    None,
    ControlStatusCStruct,
    ctypes.c_void_p
)
AttitudeCallback = ctypes.CFUNCTYPE(
    None,
    AttitudeCStruct,
    ctypes.c_void_p
)


class Gimbal:
    """Provide control over a gimbal."""

    def __init__(self, system):
        self._lib = _cmavsdk_lib
        self._handle = None
        self._callbacks = []  # Keep references to prevent GC

        self._setup_functions()

        # Validate input parameter
        if system is None:
            raise ValueError("system cannot be None")

        # Extract handle with validation
        if hasattr(system, '_handle'):
            system_handle = system._handle
        elif isinstance(system, ctypes.c_void_p):
            system_handle = system
        else:
            raise ValueError(f"Invalid system type: {type(system)}. Expected MavsdkSystem or c_void_p")

        # Validate handle is not null
        if not system_handle or (isinstance(system_handle, int) and system_handle == 0):
            raise ValueError("system handle is null")

        self._handle = self._lib.mavsdk_gimbal_create(system_handle)

        # Validate plugin creation succeeded
        if not self._handle:
            raise RuntimeError("Failed to create Gimbal plugin - C function returned null handle")

    def _setup_functions(self):
        """Setup C function signatures"""

        # Create/Destroy
        self._lib.mavsdk_gimbal_create.argtypes = [ctypes.c_void_p]
        self._lib.mavsdk_gimbal_create.restype = ctypes.c_void_p

        self._lib.mavsdk_gimbal_destroy.argtypes = [ctypes.c_void_p]
        self._lib.mavsdk_gimbal_destroy.restype = None

        self._lib.mavsdk_gimbal_quaternion_destroy.argtypes = [
            ctypes.POINTER(QuaternionCStruct)
        ]
        self._lib.mavsdk_gimbal_quaternion_destroy.restype = None

        self._lib.mavsdk_gimbal_euler_angle_destroy.argtypes = [
            ctypes.POINTER(EulerAngleCStruct)
        ]
        self._lib.mavsdk_gimbal_euler_angle_destroy.restype = None

        self._lib.mavsdk_gimbal_angular_velocity_body_destroy.argtypes = [
            ctypes.POINTER(AngularVelocityBodyCStruct)
        ]
        self._lib.mavsdk_gimbal_angular_velocity_body_destroy.restype = None

        self._lib.mavsdk_gimbal_attitude_destroy.argtypes = [
            ctypes.POINTER(AttitudeCStruct)
        ]
        self._lib.mavsdk_gimbal_attitude_destroy.restype = None

        self._lib.mavsdk_gimbal_gimbal_item_destroy.argtypes = [
            ctypes.POINTER(GimbalItemCStruct)
        ]
        self._lib.mavsdk_gimbal_gimbal_item_destroy.restype = None

        self._lib.mavsdk_gimbal_gimbal_list_destroy.argtypes = [
            ctypes.POINTER(GimbalListCStruct)
        ]
        self._lib.mavsdk_gimbal_gimbal_list_destroy.restype = None

        self._lib.mavsdk_gimbal_control_status_destroy.argtypes = [
            ctypes.POINTER(ControlStatusCStruct)
        ]
        self._lib.mavsdk_gimbal_control_status_destroy.restype = None


        self._lib.mavsdk_gimbal_set_angles_async.argtypes = [
            ctypes.c_void_p,
            ctypes.c_int32,
            ctypes.c_float,
            ctypes.c_float,
            ctypes.c_float,
            ctypes.c_int,
            ctypes.c_int,
            SetAnglesCallback,
            ctypes.c_void_p
        ]

        self._lib.mavsdk_gimbal_set_angles_async.restype = None

        self._lib.mavsdk_gimbal_set_angles.argtypes = [
            ctypes.c_void_p,
            ctypes.c_int32,
            ctypes.c_float,
            ctypes.c_float,
            ctypes.c_float,
            ctypes.c_int,
            ctypes.c_int,
        ]

        self._lib.mavsdk_gimbal_set_angles.restype = ctypes.c_int
        self._lib.mavsdk_gimbal_set_angular_rates_async.argtypes = [
            ctypes.c_void_p,
            ctypes.c_int32,
            ctypes.c_float,
            ctypes.c_float,
            ctypes.c_float,
            ctypes.c_int,
            ctypes.c_int,
            SetAngularRatesCallback,
            ctypes.c_void_p
        ]

        self._lib.mavsdk_gimbal_set_angular_rates_async.restype = None

        self._lib.mavsdk_gimbal_set_angular_rates.argtypes = [
            ctypes.c_void_p,
            ctypes.c_int32,
            ctypes.c_float,
            ctypes.c_float,
            ctypes.c_float,
            ctypes.c_int,
            ctypes.c_int,
        ]

        self._lib.mavsdk_gimbal_set_angular_rates.restype = ctypes.c_int
        self._lib.mavsdk_gimbal_set_roi_location_async.argtypes = [
            ctypes.c_void_p,
            ctypes.c_int32,
            ctypes.c_double,
            ctypes.c_double,
            ctypes.c_float,
            SetRoiLocationCallback,
            ctypes.c_void_p
        ]

        self._lib.mavsdk_gimbal_set_roi_location_async.restype = None

        self._lib.mavsdk_gimbal_set_roi_location.argtypes = [
            ctypes.c_void_p,
            ctypes.c_int32,
            ctypes.c_double,
            ctypes.c_double,
            ctypes.c_float,
        ]

        self._lib.mavsdk_gimbal_set_roi_location.restype = ctypes.c_int
        self._lib.mavsdk_gimbal_take_control_async.argtypes = [
            ctypes.c_void_p,
            ctypes.c_int32,
            ctypes.c_int,
            TakeControlCallback,
            ctypes.c_void_p
        ]

        self._lib.mavsdk_gimbal_take_control_async.restype = None

        self._lib.mavsdk_gimbal_take_control.argtypes = [
            ctypes.c_void_p,
            ctypes.c_int32,
            ctypes.c_int,
        ]

        self._lib.mavsdk_gimbal_take_control.restype = ctypes.c_int
        self._lib.mavsdk_gimbal_release_control_async.argtypes = [
            ctypes.c_void_p,
            ctypes.c_int32,
            ReleaseControlCallback,
            ctypes.c_void_p
        ]

        self._lib.mavsdk_gimbal_release_control_async.restype = None

        self._lib.mavsdk_gimbal_release_control.argtypes = [
            ctypes.c_void_p,
            ctypes.c_int32,
        ]

        self._lib.mavsdk_gimbal_release_control.restype = ctypes.c_int
        self._lib.mavsdk_gimbal_subscribe_gimbal_list.argtypes = [
            ctypes.c_void_p,
            GimbalListCallback,
            ctypes.c_void_p
        ]

        self._lib.mavsdk_gimbal_subscribe_gimbal_list.restype = ctypes.c_void_p
        # Unsubscribe
        self._lib.mavsdk_gimbal_unsubscribe_gimbal_list.argtypes = [
            ctypes.c_void_p,
            ctypes.c_void_p
        ]

        self._lib.mavsdk_gimbal_unsubscribe_gimbal_list.restype = None

        self._lib.mavsdk_gimbal_gimbal_list.argtypes = [
            ctypes.c_void_p,
            ctypes.POINTER(GimbalListCStruct)
        ]

        self._lib.mavsdk_gimbal_gimbal_list.restype = None
        self._lib.mavsdk_gimbal_subscribe_control_status.argtypes = [
            ctypes.c_void_p,
            ControlStatusCallback,
            ctypes.c_void_p
        ]

        self._lib.mavsdk_gimbal_subscribe_control_status.restype = ctypes.c_void_p
        # Unsubscribe
        self._lib.mavsdk_gimbal_unsubscribe_control_status.argtypes = [
            ctypes.c_void_p,
            ctypes.c_void_p
        ]

        self._lib.mavsdk_gimbal_unsubscribe_control_status.restype = None


        self._lib.mavsdk_gimbal_get_control_status.argtypes = [
            ctypes.c_void_p,
            ctypes.c_int32,
            ctypes.POINTER(ControlStatusCStruct)
        ]

        self._lib.mavsdk_gimbal_get_control_status.restype = ctypes.c_int
        self._lib.mavsdk_gimbal_subscribe_attitude.argtypes = [
            ctypes.c_void_p,
            AttitudeCallback,
            ctypes.c_void_p
        ]

        self._lib.mavsdk_gimbal_subscribe_attitude.restype = ctypes.c_void_p
        # Unsubscribe
        self._lib.mavsdk_gimbal_unsubscribe_attitude.argtypes = [
            ctypes.c_void_p,
            ctypes.c_void_p
        ]

        self._lib.mavsdk_gimbal_unsubscribe_attitude.restype = None


        self._lib.mavsdk_gimbal_get_attitude.argtypes = [
            ctypes.c_void_p,
            ctypes.c_int32,
            ctypes.POINTER(AttitudeCStruct)
        ]

        self._lib.mavsdk_gimbal_get_attitude.restype = ctypes.c_int


    def set_angles_async(self, gimbal_id, roll_deg, pitch_deg, yaw_deg, gimbal_mode, send_mode, callback: Callable, user_data: Any = None):
        """Set gimbal roll, pitch and yaw angles.

 This sets the desired roll, pitch and yaw angles of a gimbal.
 Will return when the command is accepted, however, it might
 take the gimbal longer to actually be set to the new angles.

 Note that the roll angle needs to be set to 0 when send_mode is Once."""

        def c_callback(result, ud):
            try:
                py_result = GimbalResult(result)


                callback(py_result, user_data)

            except Exception as e:
                print(f"Error in set_angles callback: {e}")

        cb = SetAnglesCallback(c_callback)
        self._callbacks.append(cb)

        self._lib.mavsdk_gimbal_set_angles_async(
            self._handle,
            gimbal_id,
            roll_deg,
            pitch_deg,
            yaw_deg,
            gimbal_mode,
            send_mode,
            cb,
            None
        )


    def set_angles(self, gimbal_id, roll_deg, pitch_deg, yaw_deg, gimbal_mode, send_mode):
        """Get set_angles (blocking)"""
        result_code = self._lib.mavsdk_gimbal_set_angles(
            self._handle,
            gimbal_id,             roll_deg,             pitch_deg,             yaw_deg,             gimbal_mode,             send_mode        )
        result = GimbalResult(result_code)
        if result != GimbalResult.SUCCESS:
            raise Exception(f"set_angles failed: {result}")
        return result


    def set_angular_rates_async(self, gimbal_id, roll_rate_deg_s, pitch_rate_deg_s, yaw_rate_deg_s, gimbal_mode, send_mode, callback: Callable, user_data: Any = None):
        """Set gimbal angular rates.

 This sets the desired angular rates around roll, pitch and yaw axes of a gimbal.
 Will return when the command is accepted, however, it might
 take the gimbal longer to actually reach the angular rate.

 Note that the roll angle needs to be set to 0 when send_mode is Once."""

        def c_callback(result, ud):
            try:
                py_result = GimbalResult(result)


                callback(py_result, user_data)

            except Exception as e:
                print(f"Error in set_angular_rates callback: {e}")

        cb = SetAngularRatesCallback(c_callback)
        self._callbacks.append(cb)

        self._lib.mavsdk_gimbal_set_angular_rates_async(
            self._handle,
            gimbal_id,
            roll_rate_deg_s,
            pitch_rate_deg_s,
            yaw_rate_deg_s,
            gimbal_mode,
            send_mode,
            cb,
            None
        )


    def set_angular_rates(self, gimbal_id, roll_rate_deg_s, pitch_rate_deg_s, yaw_rate_deg_s, gimbal_mode, send_mode):
        """Get set_angular_rates (blocking)"""
        result_code = self._lib.mavsdk_gimbal_set_angular_rates(
            self._handle,
            gimbal_id,             roll_rate_deg_s,             pitch_rate_deg_s,             yaw_rate_deg_s,             gimbal_mode,             send_mode        )
        result = GimbalResult(result_code)
        if result != GimbalResult.SUCCESS:
            raise Exception(f"set_angular_rates failed: {result}")
        return result


    def set_roi_location_async(self, gimbal_id, latitude_deg, longitude_deg, altitude_m, callback: Callable, user_data: Any = None):
        """Set gimbal region of interest (ROI).

 This sets a region of interest that the gimbal will point to.
 The gimbal will continue to point to the specified region until it
 receives a new command.
 The function will return when the command is accepted, however, it might
 take the gimbal longer to actually rotate to the ROI."""

        def c_callback(result, ud):
            try:
                py_result = GimbalResult(result)


                callback(py_result, user_data)

            except Exception as e:
                print(f"Error in set_roi_location callback: {e}")

        cb = SetRoiLocationCallback(c_callback)
        self._callbacks.append(cb)

        self._lib.mavsdk_gimbal_set_roi_location_async(
            self._handle,
            gimbal_id,
            latitude_deg,
            longitude_deg,
            altitude_m,
            cb,
            None
        )


    def set_roi_location(self, gimbal_id, latitude_deg, longitude_deg, altitude_m):
        """Get set_roi_location (blocking)"""
        result_code = self._lib.mavsdk_gimbal_set_roi_location(
            self._handle,
            gimbal_id,             latitude_deg,             longitude_deg,             altitude_m        )
        result = GimbalResult(result_code)
        if result != GimbalResult.SUCCESS:
            raise Exception(f"set_roi_location failed: {result}")
        return result


    def take_control_async(self, gimbal_id, control_mode, callback: Callable, user_data: Any = None):
        """Take control.

 There can be only two components in control of a gimbal at any given time.
 One with "primary" control, and one with "secondary" control. The way the
 secondary control is implemented is not specified and hence depends on the
 vehicle.

 Components are expected to be cooperative, which means that they can
 override each other and should therefore do it carefully."""

        def c_callback(result, ud):
            try:
                py_result = GimbalResult(result)


                callback(py_result, user_data)

            except Exception as e:
                print(f"Error in take_control callback: {e}")

        cb = TakeControlCallback(c_callback)
        self._callbacks.append(cb)

        self._lib.mavsdk_gimbal_take_control_async(
            self._handle,
            gimbal_id,
            control_mode,
            cb,
            None
        )


    def take_control(self, gimbal_id, control_mode):
        """Get take_control (blocking)"""
        result_code = self._lib.mavsdk_gimbal_take_control(
            self._handle,
            gimbal_id,             control_mode        )
        result = GimbalResult(result_code)
        if result != GimbalResult.SUCCESS:
            raise Exception(f"take_control failed: {result}")
        return result


    def release_control_async(self, gimbal_id, callback: Callable, user_data: Any = None):
        """Release control.

 Release control, such that other components can control the gimbal."""

        def c_callback(result, ud):
            try:
                py_result = GimbalResult(result)


                callback(py_result, user_data)

            except Exception as e:
                print(f"Error in release_control callback: {e}")

        cb = ReleaseControlCallback(c_callback)
        self._callbacks.append(cb)

        self._lib.mavsdk_gimbal_release_control_async(
            self._handle,
            gimbal_id,
            cb,
            None
        )


    def release_control(self, gimbal_id):
        """Get release_control (blocking)"""
        result_code = self._lib.mavsdk_gimbal_release_control(
            self._handle,
            gimbal_id        )
        result = GimbalResult(result_code)
        if result != GimbalResult.SUCCESS:
            raise Exception(f"release_control failed: {result}")
        return result


    def subscribe_gimbal_list(self, callback: Callable, user_data: Any = None):
        """Subscribe to list of gimbals.

 This allows to find out what gimbals are connected to the system.
 Based on the gimbal ID, we can then address a specific gimbal."""

        def c_callback(c_data, ud):
            try:

                py_data = GimbalList.from_c_struct(c_data)

                self._lib.mavsdk_gimbal_gimbal_list_destroy(ctypes.byref(c_data))

                callback(py_data, user_data)

            except Exception as e:
                print(f"Error in gimbal_list callback: {e}")

        cb = GimbalListCallback(c_callback)
        self._callbacks.append(cb)

        return self._lib.mavsdk_gimbal_subscribe_gimbal_list(
            self._handle,
            cb,
            None
        )

    def unsubscribe_gimbal_list(self, handle: ctypes.c_void_p):
        """Unsubscribe from gimbal_list"""
        self._lib.mavsdk_gimbal_unsubscribe_gimbal_list(
            self._handle, handle
        )

    def gimbal_list(self):
        """Get gimbal_list (blocking)"""
        result_out = GimbalListCStruct()
        self._lib.mavsdk_gimbal_gimbal_list(
            self._handle,
            ctypes.byref(result_out)
        )
        py_result = GimbalList.from_c_struct(result_out)

        self._lib.mavsdk_gimbal_gimbal_list_destroy(ctypes.byref(result_out))

        return py_result


    def subscribe_control_status(self, callback: Callable, user_data: Any = None):
        """Subscribe to control status updates.

 This allows a component to know if it has primary, secondary or
 no control over the gimbal. Also, it gives the system and component ids
 of the other components in control (if any)."""

        def c_callback(c_data, ud):
            try:

                py_data = ControlStatus.from_c_struct(c_data)

                self._lib.mavsdk_gimbal_control_status_destroy(ctypes.byref(c_data))

                callback(py_data, user_data)

            except Exception as e:
                print(f"Error in control_status callback: {e}")

        cb = ControlStatusCallback(c_callback)
        self._callbacks.append(cb)

        return self._lib.mavsdk_gimbal_subscribe_control_status(
            self._handle,
            cb,
            None
        )

    def unsubscribe_control_status(self, handle: ctypes.c_void_p):
        """Unsubscribe from control_status"""
        self._lib.mavsdk_gimbal_unsubscribe_control_status(
            self._handle, handle
        )




    def get_control_status(self, gimbal_id):
        """Get get_control_status (blocking)"""
        result_out = ControlStatusCStruct()
        result_code = self._lib.mavsdk_gimbal_get_control_status(
            self._handle,
            gimbal_id,
            ctypes.byref(result_out)
        )
        result = GimbalResult(result_code)
        if result != GimbalResult.SUCCESS:
            raise Exception(f"get_control_status failed: {result}")
        py_result = ControlStatus.from_c_struct(result_out)

        self._lib.mavsdk_gimbal_control_status_destroy(ctypes.byref(result_out))

        return py_result


    def subscribe_attitude(self, callback: Callable, user_data: Any = None):
        """Subscribe to attitude updates.

 This gets you the gimbal's attitude and angular rate."""

        def c_callback(c_data, ud):
            try:

                py_data = Attitude.from_c_struct(c_data)

                self._lib.mavsdk_gimbal_attitude_destroy(ctypes.byref(c_data))

                callback(py_data, user_data)

            except Exception as e:
                print(f"Error in attitude callback: {e}")

        cb = AttitudeCallback(c_callback)
        self._callbacks.append(cb)

        return self._lib.mavsdk_gimbal_subscribe_attitude(
            self._handle,
            cb,
            None
        )

    def unsubscribe_attitude(self, handle: ctypes.c_void_p):
        """Unsubscribe from attitude"""
        self._lib.mavsdk_gimbal_unsubscribe_attitude(
            self._handle, handle
        )




    def get_attitude(self, gimbal_id):
        """Get get_attitude (blocking)"""
        result_out = AttitudeCStruct()
        result_code = self._lib.mavsdk_gimbal_get_attitude(
            self._handle,
            gimbal_id,
            ctypes.byref(result_out)
        )
        result = GimbalResult(result_code)
        if result != GimbalResult.SUCCESS:
            raise Exception(f"get_attitude failed: {result}")
        py_result = Attitude.from_c_struct(result_out)

        self._lib.mavsdk_gimbal_attitude_destroy(ctypes.byref(result_out))

        return py_result


    def destroy(self):
        """Destroy the plugin instance"""
        if self._handle:
            self._lib.mavsdk_gimbal_destroy(self._handle)
            self._handle = None

    def __del__(self):
        self.destroy()