// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: camera/camera.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_camera_2fcamera_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_camera_2fcamera_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4023000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4023002 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "mavsdk_options.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_camera_2fcamera_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_camera_2fcamera_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_camera_2fcamera_2eproto;
namespace mavsdk {
namespace rpc {
namespace camera {
class CameraResult;
struct CameraResultDefaultTypeInternal;
extern CameraResultDefaultTypeInternal _CameraResult_default_instance_;
class CaptureInfo;
struct CaptureInfoDefaultTypeInternal;
extern CaptureInfoDefaultTypeInternal _CaptureInfo_default_instance_;
class CaptureInfoResponse;
struct CaptureInfoResponseDefaultTypeInternal;
extern CaptureInfoResponseDefaultTypeInternal _CaptureInfoResponse_default_instance_;
class CurrentSettingsResponse;
struct CurrentSettingsResponseDefaultTypeInternal;
extern CurrentSettingsResponseDefaultTypeInternal _CurrentSettingsResponse_default_instance_;
class EulerAngle;
struct EulerAngleDefaultTypeInternal;
extern EulerAngleDefaultTypeInternal _EulerAngle_default_instance_;
class FormatStorageRequest;
struct FormatStorageRequestDefaultTypeInternal;
extern FormatStorageRequestDefaultTypeInternal _FormatStorageRequest_default_instance_;
class FormatStorageResponse;
struct FormatStorageResponseDefaultTypeInternal;
extern FormatStorageResponseDefaultTypeInternal _FormatStorageResponse_default_instance_;
class GetSettingRequest;
struct GetSettingRequestDefaultTypeInternal;
extern GetSettingRequestDefaultTypeInternal _GetSettingRequest_default_instance_;
class GetSettingResponse;
struct GetSettingResponseDefaultTypeInternal;
extern GetSettingResponseDefaultTypeInternal _GetSettingResponse_default_instance_;
class Information;
struct InformationDefaultTypeInternal;
extern InformationDefaultTypeInternal _Information_default_instance_;
class InformationResponse;
struct InformationResponseDefaultTypeInternal;
extern InformationResponseDefaultTypeInternal _InformationResponse_default_instance_;
class ListPhotosRequest;
struct ListPhotosRequestDefaultTypeInternal;
extern ListPhotosRequestDefaultTypeInternal _ListPhotosRequest_default_instance_;
class ListPhotosResponse;
struct ListPhotosResponseDefaultTypeInternal;
extern ListPhotosResponseDefaultTypeInternal _ListPhotosResponse_default_instance_;
class ModeResponse;
struct ModeResponseDefaultTypeInternal;
extern ModeResponseDefaultTypeInternal _ModeResponse_default_instance_;
class Option;
struct OptionDefaultTypeInternal;
extern OptionDefaultTypeInternal _Option_default_instance_;
class Position;
struct PositionDefaultTypeInternal;
extern PositionDefaultTypeInternal _Position_default_instance_;
class PossibleSettingOptionsResponse;
struct PossibleSettingOptionsResponseDefaultTypeInternal;
extern PossibleSettingOptionsResponseDefaultTypeInternal _PossibleSettingOptionsResponse_default_instance_;
class PrepareRequest;
struct PrepareRequestDefaultTypeInternal;
extern PrepareRequestDefaultTypeInternal _PrepareRequest_default_instance_;
class PrepareResponse;
struct PrepareResponseDefaultTypeInternal;
extern PrepareResponseDefaultTypeInternal _PrepareResponse_default_instance_;
class Quaternion;
struct QuaternionDefaultTypeInternal;
extern QuaternionDefaultTypeInternal _Quaternion_default_instance_;
class SelectCameraRequest;
struct SelectCameraRequestDefaultTypeInternal;
extern SelectCameraRequestDefaultTypeInternal _SelectCameraRequest_default_instance_;
class SelectCameraResponse;
struct SelectCameraResponseDefaultTypeInternal;
extern SelectCameraResponseDefaultTypeInternal _SelectCameraResponse_default_instance_;
class SetModeRequest;
struct SetModeRequestDefaultTypeInternal;
extern SetModeRequestDefaultTypeInternal _SetModeRequest_default_instance_;
class SetModeResponse;
struct SetModeResponseDefaultTypeInternal;
extern SetModeResponseDefaultTypeInternal _SetModeResponse_default_instance_;
class SetSettingRequest;
struct SetSettingRequestDefaultTypeInternal;
extern SetSettingRequestDefaultTypeInternal _SetSettingRequest_default_instance_;
class SetSettingResponse;
struct SetSettingResponseDefaultTypeInternal;
extern SetSettingResponseDefaultTypeInternal _SetSettingResponse_default_instance_;
class Setting;
struct SettingDefaultTypeInternal;
extern SettingDefaultTypeInternal _Setting_default_instance_;
class SettingOptions;
struct SettingOptionsDefaultTypeInternal;
extern SettingOptionsDefaultTypeInternal _SettingOptions_default_instance_;
class StartPhotoIntervalRequest;
struct StartPhotoIntervalRequestDefaultTypeInternal;
extern StartPhotoIntervalRequestDefaultTypeInternal _StartPhotoIntervalRequest_default_instance_;
class StartPhotoIntervalResponse;
struct StartPhotoIntervalResponseDefaultTypeInternal;
extern StartPhotoIntervalResponseDefaultTypeInternal _StartPhotoIntervalResponse_default_instance_;
class StartVideoRequest;
struct StartVideoRequestDefaultTypeInternal;
extern StartVideoRequestDefaultTypeInternal _StartVideoRequest_default_instance_;
class StartVideoResponse;
struct StartVideoResponseDefaultTypeInternal;
extern StartVideoResponseDefaultTypeInternal _StartVideoResponse_default_instance_;
class StartVideoStreamingRequest;
struct StartVideoStreamingRequestDefaultTypeInternal;
extern StartVideoStreamingRequestDefaultTypeInternal _StartVideoStreamingRequest_default_instance_;
class StartVideoStreamingResponse;
struct StartVideoStreamingResponseDefaultTypeInternal;
extern StartVideoStreamingResponseDefaultTypeInternal _StartVideoStreamingResponse_default_instance_;
class Status;
struct StatusDefaultTypeInternal;
extern StatusDefaultTypeInternal _Status_default_instance_;
class StatusResponse;
struct StatusResponseDefaultTypeInternal;
extern StatusResponseDefaultTypeInternal _StatusResponse_default_instance_;
class StopPhotoIntervalRequest;
struct StopPhotoIntervalRequestDefaultTypeInternal;
extern StopPhotoIntervalRequestDefaultTypeInternal _StopPhotoIntervalRequest_default_instance_;
class StopPhotoIntervalResponse;
struct StopPhotoIntervalResponseDefaultTypeInternal;
extern StopPhotoIntervalResponseDefaultTypeInternal _StopPhotoIntervalResponse_default_instance_;
class StopVideoRequest;
struct StopVideoRequestDefaultTypeInternal;
extern StopVideoRequestDefaultTypeInternal _StopVideoRequest_default_instance_;
class StopVideoResponse;
struct StopVideoResponseDefaultTypeInternal;
extern StopVideoResponseDefaultTypeInternal _StopVideoResponse_default_instance_;
class StopVideoStreamingRequest;
struct StopVideoStreamingRequestDefaultTypeInternal;
extern StopVideoStreamingRequestDefaultTypeInternal _StopVideoStreamingRequest_default_instance_;
class StopVideoStreamingResponse;
struct StopVideoStreamingResponseDefaultTypeInternal;
extern StopVideoStreamingResponseDefaultTypeInternal _StopVideoStreamingResponse_default_instance_;
class SubscribeCaptureInfoRequest;
struct SubscribeCaptureInfoRequestDefaultTypeInternal;
extern SubscribeCaptureInfoRequestDefaultTypeInternal _SubscribeCaptureInfoRequest_default_instance_;
class SubscribeCurrentSettingsRequest;
struct SubscribeCurrentSettingsRequestDefaultTypeInternal;
extern SubscribeCurrentSettingsRequestDefaultTypeInternal _SubscribeCurrentSettingsRequest_default_instance_;
class SubscribeInformationRequest;
struct SubscribeInformationRequestDefaultTypeInternal;
extern SubscribeInformationRequestDefaultTypeInternal _SubscribeInformationRequest_default_instance_;
class SubscribeModeRequest;
struct SubscribeModeRequestDefaultTypeInternal;
extern SubscribeModeRequestDefaultTypeInternal _SubscribeModeRequest_default_instance_;
class SubscribePossibleSettingOptionsRequest;
struct SubscribePossibleSettingOptionsRequestDefaultTypeInternal;
extern SubscribePossibleSettingOptionsRequestDefaultTypeInternal _SubscribePossibleSettingOptionsRequest_default_instance_;
class SubscribeStatusRequest;
struct SubscribeStatusRequestDefaultTypeInternal;
extern SubscribeStatusRequestDefaultTypeInternal _SubscribeStatusRequest_default_instance_;
class SubscribeVideoStreamInfoRequest;
struct SubscribeVideoStreamInfoRequestDefaultTypeInternal;
extern SubscribeVideoStreamInfoRequestDefaultTypeInternal _SubscribeVideoStreamInfoRequest_default_instance_;
class TakePhotoRequest;
struct TakePhotoRequestDefaultTypeInternal;
extern TakePhotoRequestDefaultTypeInternal _TakePhotoRequest_default_instance_;
class TakePhotoResponse;
struct TakePhotoResponseDefaultTypeInternal;
extern TakePhotoResponseDefaultTypeInternal _TakePhotoResponse_default_instance_;
class VideoStreamInfo;
struct VideoStreamInfoDefaultTypeInternal;
extern VideoStreamInfoDefaultTypeInternal _VideoStreamInfo_default_instance_;
class VideoStreamInfoResponse;
struct VideoStreamInfoResponseDefaultTypeInternal;
extern VideoStreamInfoResponseDefaultTypeInternal _VideoStreamInfoResponse_default_instance_;
class VideoStreamSettings;
struct VideoStreamSettingsDefaultTypeInternal;
extern VideoStreamSettingsDefaultTypeInternal _VideoStreamSettings_default_instance_;
}  // namespace camera
}  // namespace rpc
}  // namespace mavsdk
PROTOBUF_NAMESPACE_OPEN
template <>
::mavsdk::rpc::camera::CameraResult* Arena::CreateMaybeMessage<::mavsdk::rpc::camera::CameraResult>(Arena*);
template <>
::mavsdk::rpc::camera::CaptureInfo* Arena::CreateMaybeMessage<::mavsdk::rpc::camera::CaptureInfo>(Arena*);
template <>
::mavsdk::rpc::camera::CaptureInfoResponse* Arena::CreateMaybeMessage<::mavsdk::rpc::camera::CaptureInfoResponse>(Arena*);
template <>
::mavsdk::rpc::camera::CurrentSettingsResponse* Arena::CreateMaybeMessage<::mavsdk::rpc::camera::CurrentSettingsResponse>(Arena*);
template <>
::mavsdk::rpc::camera::EulerAngle* Arena::CreateMaybeMessage<::mavsdk::rpc::camera::EulerAngle>(Arena*);
template <>
::mavsdk::rpc::camera::FormatStorageRequest* Arena::CreateMaybeMessage<::mavsdk::rpc::camera::FormatStorageRequest>(Arena*);
template <>
::mavsdk::rpc::camera::FormatStorageResponse* Arena::CreateMaybeMessage<::mavsdk::rpc::camera::FormatStorageResponse>(Arena*);
template <>
::mavsdk::rpc::camera::GetSettingRequest* Arena::CreateMaybeMessage<::mavsdk::rpc::camera::GetSettingRequest>(Arena*);
template <>
::mavsdk::rpc::camera::GetSettingResponse* Arena::CreateMaybeMessage<::mavsdk::rpc::camera::GetSettingResponse>(Arena*);
template <>
::mavsdk::rpc::camera::Information* Arena::CreateMaybeMessage<::mavsdk::rpc::camera::Information>(Arena*);
template <>
::mavsdk::rpc::camera::InformationResponse* Arena::CreateMaybeMessage<::mavsdk::rpc::camera::InformationResponse>(Arena*);
template <>
::mavsdk::rpc::camera::ListPhotosRequest* Arena::CreateMaybeMessage<::mavsdk::rpc::camera::ListPhotosRequest>(Arena*);
template <>
::mavsdk::rpc::camera::ListPhotosResponse* Arena::CreateMaybeMessage<::mavsdk::rpc::camera::ListPhotosResponse>(Arena*);
template <>
::mavsdk::rpc::camera::ModeResponse* Arena::CreateMaybeMessage<::mavsdk::rpc::camera::ModeResponse>(Arena*);
template <>
::mavsdk::rpc::camera::Option* Arena::CreateMaybeMessage<::mavsdk::rpc::camera::Option>(Arena*);
template <>
::mavsdk::rpc::camera::Position* Arena::CreateMaybeMessage<::mavsdk::rpc::camera::Position>(Arena*);
template <>
::mavsdk::rpc::camera::PossibleSettingOptionsResponse* Arena::CreateMaybeMessage<::mavsdk::rpc::camera::PossibleSettingOptionsResponse>(Arena*);
template <>
::mavsdk::rpc::camera::PrepareRequest* Arena::CreateMaybeMessage<::mavsdk::rpc::camera::PrepareRequest>(Arena*);
template <>
::mavsdk::rpc::camera::PrepareResponse* Arena::CreateMaybeMessage<::mavsdk::rpc::camera::PrepareResponse>(Arena*);
template <>
::mavsdk::rpc::camera::Quaternion* Arena::CreateMaybeMessage<::mavsdk::rpc::camera::Quaternion>(Arena*);
template <>
::mavsdk::rpc::camera::SelectCameraRequest* Arena::CreateMaybeMessage<::mavsdk::rpc::camera::SelectCameraRequest>(Arena*);
template <>
::mavsdk::rpc::camera::SelectCameraResponse* Arena::CreateMaybeMessage<::mavsdk::rpc::camera::SelectCameraResponse>(Arena*);
template <>
::mavsdk::rpc::camera::SetModeRequest* Arena::CreateMaybeMessage<::mavsdk::rpc::camera::SetModeRequest>(Arena*);
template <>
::mavsdk::rpc::camera::SetModeResponse* Arena::CreateMaybeMessage<::mavsdk::rpc::camera::SetModeResponse>(Arena*);
template <>
::mavsdk::rpc::camera::SetSettingRequest* Arena::CreateMaybeMessage<::mavsdk::rpc::camera::SetSettingRequest>(Arena*);
template <>
::mavsdk::rpc::camera::SetSettingResponse* Arena::CreateMaybeMessage<::mavsdk::rpc::camera::SetSettingResponse>(Arena*);
template <>
::mavsdk::rpc::camera::Setting* Arena::CreateMaybeMessage<::mavsdk::rpc::camera::Setting>(Arena*);
template <>
::mavsdk::rpc::camera::SettingOptions* Arena::CreateMaybeMessage<::mavsdk::rpc::camera::SettingOptions>(Arena*);
template <>
::mavsdk::rpc::camera::StartPhotoIntervalRequest* Arena::CreateMaybeMessage<::mavsdk::rpc::camera::StartPhotoIntervalRequest>(Arena*);
template <>
::mavsdk::rpc::camera::StartPhotoIntervalResponse* Arena::CreateMaybeMessage<::mavsdk::rpc::camera::StartPhotoIntervalResponse>(Arena*);
template <>
::mavsdk::rpc::camera::StartVideoRequest* Arena::CreateMaybeMessage<::mavsdk::rpc::camera::StartVideoRequest>(Arena*);
template <>
::mavsdk::rpc::camera::StartVideoResponse* Arena::CreateMaybeMessage<::mavsdk::rpc::camera::StartVideoResponse>(Arena*);
template <>
::mavsdk::rpc::camera::StartVideoStreamingRequest* Arena::CreateMaybeMessage<::mavsdk::rpc::camera::StartVideoStreamingRequest>(Arena*);
template <>
::mavsdk::rpc::camera::StartVideoStreamingResponse* Arena::CreateMaybeMessage<::mavsdk::rpc::camera::StartVideoStreamingResponse>(Arena*);
template <>
::mavsdk::rpc::camera::Status* Arena::CreateMaybeMessage<::mavsdk::rpc::camera::Status>(Arena*);
template <>
::mavsdk::rpc::camera::StatusResponse* Arena::CreateMaybeMessage<::mavsdk::rpc::camera::StatusResponse>(Arena*);
template <>
::mavsdk::rpc::camera::StopPhotoIntervalRequest* Arena::CreateMaybeMessage<::mavsdk::rpc::camera::StopPhotoIntervalRequest>(Arena*);
template <>
::mavsdk::rpc::camera::StopPhotoIntervalResponse* Arena::CreateMaybeMessage<::mavsdk::rpc::camera::StopPhotoIntervalResponse>(Arena*);
template <>
::mavsdk::rpc::camera::StopVideoRequest* Arena::CreateMaybeMessage<::mavsdk::rpc::camera::StopVideoRequest>(Arena*);
template <>
::mavsdk::rpc::camera::StopVideoResponse* Arena::CreateMaybeMessage<::mavsdk::rpc::camera::StopVideoResponse>(Arena*);
template <>
::mavsdk::rpc::camera::StopVideoStreamingRequest* Arena::CreateMaybeMessage<::mavsdk::rpc::camera::StopVideoStreamingRequest>(Arena*);
template <>
::mavsdk::rpc::camera::StopVideoStreamingResponse* Arena::CreateMaybeMessage<::mavsdk::rpc::camera::StopVideoStreamingResponse>(Arena*);
template <>
::mavsdk::rpc::camera::SubscribeCaptureInfoRequest* Arena::CreateMaybeMessage<::mavsdk::rpc::camera::SubscribeCaptureInfoRequest>(Arena*);
template <>
::mavsdk::rpc::camera::SubscribeCurrentSettingsRequest* Arena::CreateMaybeMessage<::mavsdk::rpc::camera::SubscribeCurrentSettingsRequest>(Arena*);
template <>
::mavsdk::rpc::camera::SubscribeInformationRequest* Arena::CreateMaybeMessage<::mavsdk::rpc::camera::SubscribeInformationRequest>(Arena*);
template <>
::mavsdk::rpc::camera::SubscribeModeRequest* Arena::CreateMaybeMessage<::mavsdk::rpc::camera::SubscribeModeRequest>(Arena*);
template <>
::mavsdk::rpc::camera::SubscribePossibleSettingOptionsRequest* Arena::CreateMaybeMessage<::mavsdk::rpc::camera::SubscribePossibleSettingOptionsRequest>(Arena*);
template <>
::mavsdk::rpc::camera::SubscribeStatusRequest* Arena::CreateMaybeMessage<::mavsdk::rpc::camera::SubscribeStatusRequest>(Arena*);
template <>
::mavsdk::rpc::camera::SubscribeVideoStreamInfoRequest* Arena::CreateMaybeMessage<::mavsdk::rpc::camera::SubscribeVideoStreamInfoRequest>(Arena*);
template <>
::mavsdk::rpc::camera::TakePhotoRequest* Arena::CreateMaybeMessage<::mavsdk::rpc::camera::TakePhotoRequest>(Arena*);
template <>
::mavsdk::rpc::camera::TakePhotoResponse* Arena::CreateMaybeMessage<::mavsdk::rpc::camera::TakePhotoResponse>(Arena*);
template <>
::mavsdk::rpc::camera::VideoStreamInfo* Arena::CreateMaybeMessage<::mavsdk::rpc::camera::VideoStreamInfo>(Arena*);
template <>
::mavsdk::rpc::camera::VideoStreamInfoResponse* Arena::CreateMaybeMessage<::mavsdk::rpc::camera::VideoStreamInfoResponse>(Arena*);
template <>
::mavsdk::rpc::camera::VideoStreamSettings* Arena::CreateMaybeMessage<::mavsdk::rpc::camera::VideoStreamSettings>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

namespace mavsdk {
namespace rpc {
namespace camera {
enum CameraResult_Result : int {
  CameraResult_Result_RESULT_UNKNOWN = 0,
  CameraResult_Result_RESULT_SUCCESS = 1,
  CameraResult_Result_RESULT_IN_PROGRESS = 2,
  CameraResult_Result_RESULT_BUSY = 3,
  CameraResult_Result_RESULT_DENIED = 4,
  CameraResult_Result_RESULT_ERROR = 5,
  CameraResult_Result_RESULT_TIMEOUT = 6,
  CameraResult_Result_RESULT_WRONG_ARGUMENT = 7,
  CameraResult_Result_RESULT_NO_SYSTEM = 8,
  CameraResult_Result_RESULT_PROTOCOL_UNSUPPORTED = 9,
  CameraResult_Result_CameraResult_Result_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  CameraResult_Result_CameraResult_Result_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool CameraResult_Result_IsValid(int value);
constexpr CameraResult_Result CameraResult_Result_Result_MIN = static_cast<CameraResult_Result>(0);
constexpr CameraResult_Result CameraResult_Result_Result_MAX = static_cast<CameraResult_Result>(9);
constexpr int CameraResult_Result_Result_ARRAYSIZE = 9 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
CameraResult_Result_descriptor();
template <typename T>
const std::string& CameraResult_Result_Name(T value) {
  static_assert(std::is_same<T, CameraResult_Result>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Result_Name().");
  return CameraResult_Result_Name(static_cast<CameraResult_Result>(value));
}
template <>
inline const std::string& CameraResult_Result_Name(CameraResult_Result value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<CameraResult_Result_descriptor,
                                                 0, 9>(
      static_cast<int>(value));
}
inline bool CameraResult_Result_Parse(absl::string_view name, CameraResult_Result* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CameraResult_Result>(
      CameraResult_Result_descriptor(), name, value);
}
enum VideoStreamInfo_VideoStreamStatus : int {
  VideoStreamInfo_VideoStreamStatus_VIDEO_STREAM_STATUS_NOT_RUNNING = 0,
  VideoStreamInfo_VideoStreamStatus_VIDEO_STREAM_STATUS_IN_PROGRESS = 1,
  VideoStreamInfo_VideoStreamStatus_VideoStreamInfo_VideoStreamStatus_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  VideoStreamInfo_VideoStreamStatus_VideoStreamInfo_VideoStreamStatus_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool VideoStreamInfo_VideoStreamStatus_IsValid(int value);
constexpr VideoStreamInfo_VideoStreamStatus VideoStreamInfo_VideoStreamStatus_VideoStreamStatus_MIN = static_cast<VideoStreamInfo_VideoStreamStatus>(0);
constexpr VideoStreamInfo_VideoStreamStatus VideoStreamInfo_VideoStreamStatus_VideoStreamStatus_MAX = static_cast<VideoStreamInfo_VideoStreamStatus>(1);
constexpr int VideoStreamInfo_VideoStreamStatus_VideoStreamStatus_ARRAYSIZE = 1 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
VideoStreamInfo_VideoStreamStatus_descriptor();
template <typename T>
const std::string& VideoStreamInfo_VideoStreamStatus_Name(T value) {
  static_assert(std::is_same<T, VideoStreamInfo_VideoStreamStatus>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to VideoStreamStatus_Name().");
  return VideoStreamInfo_VideoStreamStatus_Name(static_cast<VideoStreamInfo_VideoStreamStatus>(value));
}
template <>
inline const std::string& VideoStreamInfo_VideoStreamStatus_Name(VideoStreamInfo_VideoStreamStatus value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<VideoStreamInfo_VideoStreamStatus_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool VideoStreamInfo_VideoStreamStatus_Parse(absl::string_view name, VideoStreamInfo_VideoStreamStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<VideoStreamInfo_VideoStreamStatus>(
      VideoStreamInfo_VideoStreamStatus_descriptor(), name, value);
}
enum VideoStreamInfo_VideoStreamSpectrum : int {
  VideoStreamInfo_VideoStreamSpectrum_VIDEO_STREAM_SPECTRUM_UNKNOWN = 0,
  VideoStreamInfo_VideoStreamSpectrum_VIDEO_STREAM_SPECTRUM_VISIBLE_LIGHT = 1,
  VideoStreamInfo_VideoStreamSpectrum_VIDEO_STREAM_SPECTRUM_INFRARED = 2,
  VideoStreamInfo_VideoStreamSpectrum_VideoStreamInfo_VideoStreamSpectrum_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  VideoStreamInfo_VideoStreamSpectrum_VideoStreamInfo_VideoStreamSpectrum_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool VideoStreamInfo_VideoStreamSpectrum_IsValid(int value);
constexpr VideoStreamInfo_VideoStreamSpectrum VideoStreamInfo_VideoStreamSpectrum_VideoStreamSpectrum_MIN = static_cast<VideoStreamInfo_VideoStreamSpectrum>(0);
constexpr VideoStreamInfo_VideoStreamSpectrum VideoStreamInfo_VideoStreamSpectrum_VideoStreamSpectrum_MAX = static_cast<VideoStreamInfo_VideoStreamSpectrum>(2);
constexpr int VideoStreamInfo_VideoStreamSpectrum_VideoStreamSpectrum_ARRAYSIZE = 2 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
VideoStreamInfo_VideoStreamSpectrum_descriptor();
template <typename T>
const std::string& VideoStreamInfo_VideoStreamSpectrum_Name(T value) {
  static_assert(std::is_same<T, VideoStreamInfo_VideoStreamSpectrum>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to VideoStreamSpectrum_Name().");
  return VideoStreamInfo_VideoStreamSpectrum_Name(static_cast<VideoStreamInfo_VideoStreamSpectrum>(value));
}
template <>
inline const std::string& VideoStreamInfo_VideoStreamSpectrum_Name(VideoStreamInfo_VideoStreamSpectrum value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<VideoStreamInfo_VideoStreamSpectrum_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool VideoStreamInfo_VideoStreamSpectrum_Parse(absl::string_view name, VideoStreamInfo_VideoStreamSpectrum* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<VideoStreamInfo_VideoStreamSpectrum>(
      VideoStreamInfo_VideoStreamSpectrum_descriptor(), name, value);
}
enum Status_StorageStatus : int {
  Status_StorageStatus_STORAGE_STATUS_NOT_AVAILABLE = 0,
  Status_StorageStatus_STORAGE_STATUS_UNFORMATTED = 1,
  Status_StorageStatus_STORAGE_STATUS_FORMATTED = 2,
  Status_StorageStatus_STORAGE_STATUS_NOT_SUPPORTED = 3,
  Status_StorageStatus_Status_StorageStatus_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Status_StorageStatus_Status_StorageStatus_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Status_StorageStatus_IsValid(int value);
constexpr Status_StorageStatus Status_StorageStatus_StorageStatus_MIN = static_cast<Status_StorageStatus>(0);
constexpr Status_StorageStatus Status_StorageStatus_StorageStatus_MAX = static_cast<Status_StorageStatus>(3);
constexpr int Status_StorageStatus_StorageStatus_ARRAYSIZE = 3 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
Status_StorageStatus_descriptor();
template <typename T>
const std::string& Status_StorageStatus_Name(T value) {
  static_assert(std::is_same<T, Status_StorageStatus>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to StorageStatus_Name().");
  return Status_StorageStatus_Name(static_cast<Status_StorageStatus>(value));
}
template <>
inline const std::string& Status_StorageStatus_Name(Status_StorageStatus value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<Status_StorageStatus_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool Status_StorageStatus_Parse(absl::string_view name, Status_StorageStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Status_StorageStatus>(
      Status_StorageStatus_descriptor(), name, value);
}
enum Status_StorageType : int {
  Status_StorageType_STORAGE_TYPE_UNKNOWN = 0,
  Status_StorageType_STORAGE_TYPE_USB_STICK = 1,
  Status_StorageType_STORAGE_TYPE_SD = 2,
  Status_StorageType_STORAGE_TYPE_MICROSD = 3,
  Status_StorageType_STORAGE_TYPE_HD = 7,
  Status_StorageType_STORAGE_TYPE_OTHER = 254,
  Status_StorageType_Status_StorageType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Status_StorageType_Status_StorageType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Status_StorageType_IsValid(int value);
constexpr Status_StorageType Status_StorageType_StorageType_MIN = static_cast<Status_StorageType>(0);
constexpr Status_StorageType Status_StorageType_StorageType_MAX = static_cast<Status_StorageType>(254);
constexpr int Status_StorageType_StorageType_ARRAYSIZE = 254 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
Status_StorageType_descriptor();
template <typename T>
const std::string& Status_StorageType_Name(T value) {
  static_assert(std::is_same<T, Status_StorageType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to StorageType_Name().");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(Status_StorageType_descriptor(), value);
}
inline bool Status_StorageType_Parse(absl::string_view name, Status_StorageType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Status_StorageType>(
      Status_StorageType_descriptor(), name, value);
}
enum Mode : int {
  MODE_UNKNOWN = 0,
  MODE_PHOTO = 1,
  MODE_VIDEO = 2,
  Mode_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Mode_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Mode_IsValid(int value);
constexpr Mode Mode_MIN = static_cast<Mode>(0);
constexpr Mode Mode_MAX = static_cast<Mode>(2);
constexpr int Mode_ARRAYSIZE = 2 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
Mode_descriptor();
template <typename T>
const std::string& Mode_Name(T value) {
  static_assert(std::is_same<T, Mode>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Mode_Name().");
  return Mode_Name(static_cast<Mode>(value));
}
template <>
inline const std::string& Mode_Name(Mode value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<Mode_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool Mode_Parse(absl::string_view name, Mode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Mode>(
      Mode_descriptor(), name, value);
}
enum PhotosRange : int {
  PHOTOS_RANGE_ALL = 0,
  PHOTOS_RANGE_SINCE_CONNECTION = 1,
  PhotosRange_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  PhotosRange_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool PhotosRange_IsValid(int value);
constexpr PhotosRange PhotosRange_MIN = static_cast<PhotosRange>(0);
constexpr PhotosRange PhotosRange_MAX = static_cast<PhotosRange>(1);
constexpr int PhotosRange_ARRAYSIZE = 1 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
PhotosRange_descriptor();
template <typename T>
const std::string& PhotosRange_Name(T value) {
  static_assert(std::is_same<T, PhotosRange>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to PhotosRange_Name().");
  return PhotosRange_Name(static_cast<PhotosRange>(value));
}
template <>
inline const std::string& PhotosRange_Name(PhotosRange value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<PhotosRange_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool PhotosRange_Parse(absl::string_view name, PhotosRange* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PhotosRange>(
      PhotosRange_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class PrepareRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera.PrepareRequest) */ {
 public:
  inline PrepareRequest() : PrepareRequest(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PrepareRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PrepareRequest(const PrepareRequest& from);
  PrepareRequest(PrepareRequest&& from) noexcept
    : PrepareRequest() {
    *this = ::std::move(from);
  }

  inline PrepareRequest& operator=(const PrepareRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PrepareRequest& operator=(PrepareRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PrepareRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PrepareRequest* internal_default_instance() {
    return reinterpret_cast<const PrepareRequest*>(
               &_PrepareRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(PrepareRequest& a, PrepareRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PrepareRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PrepareRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PrepareRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PrepareRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const PrepareRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const PrepareRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mavsdk.rpc.camera.PrepareRequest";
  }
  protected:
  explicit PrepareRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera.PrepareRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_camera_2fcamera_2eproto;
};// -------------------------------------------------------------------

class PrepareResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera.PrepareResponse) */ {
 public:
  inline PrepareResponse() : PrepareResponse(nullptr) {}
  ~PrepareResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PrepareResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PrepareResponse(const PrepareResponse& from);
  PrepareResponse(PrepareResponse&& from) noexcept
    : PrepareResponse() {
    *this = ::std::move(from);
  }

  inline PrepareResponse& operator=(const PrepareResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PrepareResponse& operator=(PrepareResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PrepareResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const PrepareResponse* internal_default_instance() {
    return reinterpret_cast<const PrepareResponse*>(
               &_PrepareResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(PrepareResponse& a, PrepareResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(PrepareResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PrepareResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PrepareResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PrepareResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PrepareResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PrepareResponse& from) {
    PrepareResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PrepareResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mavsdk.rpc.camera.PrepareResponse";
  }
  protected:
  explicit PrepareResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCameraResultFieldNumber = 1,
  };
  // .mavsdk.rpc.camera.CameraResult camera_result = 1;
  bool has_camera_result() const;
  void clear_camera_result() ;
  const ::mavsdk::rpc::camera::CameraResult& camera_result() const;
  PROTOBUF_NODISCARD ::mavsdk::rpc::camera::CameraResult* release_camera_result();
  ::mavsdk::rpc::camera::CameraResult* mutable_camera_result();
  void set_allocated_camera_result(::mavsdk::rpc::camera::CameraResult* camera_result);
  private:
  const ::mavsdk::rpc::camera::CameraResult& _internal_camera_result() const;
  ::mavsdk::rpc::camera::CameraResult* _internal_mutable_camera_result();
  public:
  void unsafe_arena_set_allocated_camera_result(
      ::mavsdk::rpc::camera::CameraResult* camera_result);
  ::mavsdk::rpc::camera::CameraResult* unsafe_arena_release_camera_result();
  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera.PrepareResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::mavsdk::rpc::camera::CameraResult* camera_result_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camera_2fcamera_2eproto;
};// -------------------------------------------------------------------

class TakePhotoRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera.TakePhotoRequest) */ {
 public:
  inline TakePhotoRequest() : TakePhotoRequest(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TakePhotoRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TakePhotoRequest(const TakePhotoRequest& from);
  TakePhotoRequest(TakePhotoRequest&& from) noexcept
    : TakePhotoRequest() {
    *this = ::std::move(from);
  }

  inline TakePhotoRequest& operator=(const TakePhotoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline TakePhotoRequest& operator=(TakePhotoRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TakePhotoRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const TakePhotoRequest* internal_default_instance() {
    return reinterpret_cast<const TakePhotoRequest*>(
               &_TakePhotoRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(TakePhotoRequest& a, TakePhotoRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(TakePhotoRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TakePhotoRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TakePhotoRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TakePhotoRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const TakePhotoRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const TakePhotoRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mavsdk.rpc.camera.TakePhotoRequest";
  }
  protected:
  explicit TakePhotoRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera.TakePhotoRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_camera_2fcamera_2eproto;
};// -------------------------------------------------------------------

class TakePhotoResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera.TakePhotoResponse) */ {
 public:
  inline TakePhotoResponse() : TakePhotoResponse(nullptr) {}
  ~TakePhotoResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TakePhotoResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TakePhotoResponse(const TakePhotoResponse& from);
  TakePhotoResponse(TakePhotoResponse&& from) noexcept
    : TakePhotoResponse() {
    *this = ::std::move(from);
  }

  inline TakePhotoResponse& operator=(const TakePhotoResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline TakePhotoResponse& operator=(TakePhotoResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TakePhotoResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const TakePhotoResponse* internal_default_instance() {
    return reinterpret_cast<const TakePhotoResponse*>(
               &_TakePhotoResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(TakePhotoResponse& a, TakePhotoResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(TakePhotoResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TakePhotoResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TakePhotoResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TakePhotoResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TakePhotoResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TakePhotoResponse& from) {
    TakePhotoResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TakePhotoResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mavsdk.rpc.camera.TakePhotoResponse";
  }
  protected:
  explicit TakePhotoResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCameraResultFieldNumber = 1,
  };
  // .mavsdk.rpc.camera.CameraResult camera_result = 1;
  bool has_camera_result() const;
  void clear_camera_result() ;
  const ::mavsdk::rpc::camera::CameraResult& camera_result() const;
  PROTOBUF_NODISCARD ::mavsdk::rpc::camera::CameraResult* release_camera_result();
  ::mavsdk::rpc::camera::CameraResult* mutable_camera_result();
  void set_allocated_camera_result(::mavsdk::rpc::camera::CameraResult* camera_result);
  private:
  const ::mavsdk::rpc::camera::CameraResult& _internal_camera_result() const;
  ::mavsdk::rpc::camera::CameraResult* _internal_mutable_camera_result();
  public:
  void unsafe_arena_set_allocated_camera_result(
      ::mavsdk::rpc::camera::CameraResult* camera_result);
  ::mavsdk::rpc::camera::CameraResult* unsafe_arena_release_camera_result();
  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera.TakePhotoResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::mavsdk::rpc::camera::CameraResult* camera_result_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camera_2fcamera_2eproto;
};// -------------------------------------------------------------------

class StartPhotoIntervalRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera.StartPhotoIntervalRequest) */ {
 public:
  inline StartPhotoIntervalRequest() : StartPhotoIntervalRequest(nullptr) {}
  ~StartPhotoIntervalRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StartPhotoIntervalRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StartPhotoIntervalRequest(const StartPhotoIntervalRequest& from);
  StartPhotoIntervalRequest(StartPhotoIntervalRequest&& from) noexcept
    : StartPhotoIntervalRequest() {
    *this = ::std::move(from);
  }

  inline StartPhotoIntervalRequest& operator=(const StartPhotoIntervalRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StartPhotoIntervalRequest& operator=(StartPhotoIntervalRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StartPhotoIntervalRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const StartPhotoIntervalRequest* internal_default_instance() {
    return reinterpret_cast<const StartPhotoIntervalRequest*>(
               &_StartPhotoIntervalRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(StartPhotoIntervalRequest& a, StartPhotoIntervalRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(StartPhotoIntervalRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StartPhotoIntervalRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StartPhotoIntervalRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StartPhotoIntervalRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StartPhotoIntervalRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StartPhotoIntervalRequest& from) {
    StartPhotoIntervalRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StartPhotoIntervalRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mavsdk.rpc.camera.StartPhotoIntervalRequest";
  }
  protected:
  explicit StartPhotoIntervalRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIntervalSFieldNumber = 1,
  };
  // float interval_s = 1;
  void clear_interval_s() ;
  float interval_s() const;
  void set_interval_s(float value);

  private:
  float _internal_interval_s() const;
  void _internal_set_interval_s(float value);

  public:
  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera.StartPhotoIntervalRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float interval_s_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camera_2fcamera_2eproto;
};// -------------------------------------------------------------------

class StartPhotoIntervalResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera.StartPhotoIntervalResponse) */ {
 public:
  inline StartPhotoIntervalResponse() : StartPhotoIntervalResponse(nullptr) {}
  ~StartPhotoIntervalResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StartPhotoIntervalResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StartPhotoIntervalResponse(const StartPhotoIntervalResponse& from);
  StartPhotoIntervalResponse(StartPhotoIntervalResponse&& from) noexcept
    : StartPhotoIntervalResponse() {
    *this = ::std::move(from);
  }

  inline StartPhotoIntervalResponse& operator=(const StartPhotoIntervalResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StartPhotoIntervalResponse& operator=(StartPhotoIntervalResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StartPhotoIntervalResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const StartPhotoIntervalResponse* internal_default_instance() {
    return reinterpret_cast<const StartPhotoIntervalResponse*>(
               &_StartPhotoIntervalResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(StartPhotoIntervalResponse& a, StartPhotoIntervalResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(StartPhotoIntervalResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StartPhotoIntervalResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StartPhotoIntervalResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StartPhotoIntervalResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StartPhotoIntervalResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StartPhotoIntervalResponse& from) {
    StartPhotoIntervalResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StartPhotoIntervalResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mavsdk.rpc.camera.StartPhotoIntervalResponse";
  }
  protected:
  explicit StartPhotoIntervalResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCameraResultFieldNumber = 1,
  };
  // .mavsdk.rpc.camera.CameraResult camera_result = 1;
  bool has_camera_result() const;
  void clear_camera_result() ;
  const ::mavsdk::rpc::camera::CameraResult& camera_result() const;
  PROTOBUF_NODISCARD ::mavsdk::rpc::camera::CameraResult* release_camera_result();
  ::mavsdk::rpc::camera::CameraResult* mutable_camera_result();
  void set_allocated_camera_result(::mavsdk::rpc::camera::CameraResult* camera_result);
  private:
  const ::mavsdk::rpc::camera::CameraResult& _internal_camera_result() const;
  ::mavsdk::rpc::camera::CameraResult* _internal_mutable_camera_result();
  public:
  void unsafe_arena_set_allocated_camera_result(
      ::mavsdk::rpc::camera::CameraResult* camera_result);
  ::mavsdk::rpc::camera::CameraResult* unsafe_arena_release_camera_result();
  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera.StartPhotoIntervalResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::mavsdk::rpc::camera::CameraResult* camera_result_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camera_2fcamera_2eproto;
};// -------------------------------------------------------------------

class StopPhotoIntervalRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera.StopPhotoIntervalRequest) */ {
 public:
  inline StopPhotoIntervalRequest() : StopPhotoIntervalRequest(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StopPhotoIntervalRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StopPhotoIntervalRequest(const StopPhotoIntervalRequest& from);
  StopPhotoIntervalRequest(StopPhotoIntervalRequest&& from) noexcept
    : StopPhotoIntervalRequest() {
    *this = ::std::move(from);
  }

  inline StopPhotoIntervalRequest& operator=(const StopPhotoIntervalRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StopPhotoIntervalRequest& operator=(StopPhotoIntervalRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StopPhotoIntervalRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const StopPhotoIntervalRequest* internal_default_instance() {
    return reinterpret_cast<const StopPhotoIntervalRequest*>(
               &_StopPhotoIntervalRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(StopPhotoIntervalRequest& a, StopPhotoIntervalRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(StopPhotoIntervalRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StopPhotoIntervalRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StopPhotoIntervalRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StopPhotoIntervalRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const StopPhotoIntervalRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const StopPhotoIntervalRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mavsdk.rpc.camera.StopPhotoIntervalRequest";
  }
  protected:
  explicit StopPhotoIntervalRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera.StopPhotoIntervalRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_camera_2fcamera_2eproto;
};// -------------------------------------------------------------------

class StopPhotoIntervalResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera.StopPhotoIntervalResponse) */ {
 public:
  inline StopPhotoIntervalResponse() : StopPhotoIntervalResponse(nullptr) {}
  ~StopPhotoIntervalResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StopPhotoIntervalResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StopPhotoIntervalResponse(const StopPhotoIntervalResponse& from);
  StopPhotoIntervalResponse(StopPhotoIntervalResponse&& from) noexcept
    : StopPhotoIntervalResponse() {
    *this = ::std::move(from);
  }

  inline StopPhotoIntervalResponse& operator=(const StopPhotoIntervalResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StopPhotoIntervalResponse& operator=(StopPhotoIntervalResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StopPhotoIntervalResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const StopPhotoIntervalResponse* internal_default_instance() {
    return reinterpret_cast<const StopPhotoIntervalResponse*>(
               &_StopPhotoIntervalResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(StopPhotoIntervalResponse& a, StopPhotoIntervalResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(StopPhotoIntervalResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StopPhotoIntervalResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StopPhotoIntervalResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StopPhotoIntervalResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StopPhotoIntervalResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StopPhotoIntervalResponse& from) {
    StopPhotoIntervalResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StopPhotoIntervalResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mavsdk.rpc.camera.StopPhotoIntervalResponse";
  }
  protected:
  explicit StopPhotoIntervalResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCameraResultFieldNumber = 1,
  };
  // .mavsdk.rpc.camera.CameraResult camera_result = 1;
  bool has_camera_result() const;
  void clear_camera_result() ;
  const ::mavsdk::rpc::camera::CameraResult& camera_result() const;
  PROTOBUF_NODISCARD ::mavsdk::rpc::camera::CameraResult* release_camera_result();
  ::mavsdk::rpc::camera::CameraResult* mutable_camera_result();
  void set_allocated_camera_result(::mavsdk::rpc::camera::CameraResult* camera_result);
  private:
  const ::mavsdk::rpc::camera::CameraResult& _internal_camera_result() const;
  ::mavsdk::rpc::camera::CameraResult* _internal_mutable_camera_result();
  public:
  void unsafe_arena_set_allocated_camera_result(
      ::mavsdk::rpc::camera::CameraResult* camera_result);
  ::mavsdk::rpc::camera::CameraResult* unsafe_arena_release_camera_result();
  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera.StopPhotoIntervalResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::mavsdk::rpc::camera::CameraResult* camera_result_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camera_2fcamera_2eproto;
};// -------------------------------------------------------------------

class StartVideoRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera.StartVideoRequest) */ {
 public:
  inline StartVideoRequest() : StartVideoRequest(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StartVideoRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StartVideoRequest(const StartVideoRequest& from);
  StartVideoRequest(StartVideoRequest&& from) noexcept
    : StartVideoRequest() {
    *this = ::std::move(from);
  }

  inline StartVideoRequest& operator=(const StartVideoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StartVideoRequest& operator=(StartVideoRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StartVideoRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const StartVideoRequest* internal_default_instance() {
    return reinterpret_cast<const StartVideoRequest*>(
               &_StartVideoRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(StartVideoRequest& a, StartVideoRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(StartVideoRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StartVideoRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StartVideoRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StartVideoRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const StartVideoRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const StartVideoRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mavsdk.rpc.camera.StartVideoRequest";
  }
  protected:
  explicit StartVideoRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera.StartVideoRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_camera_2fcamera_2eproto;
};// -------------------------------------------------------------------

class StartVideoResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera.StartVideoResponse) */ {
 public:
  inline StartVideoResponse() : StartVideoResponse(nullptr) {}
  ~StartVideoResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StartVideoResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StartVideoResponse(const StartVideoResponse& from);
  StartVideoResponse(StartVideoResponse&& from) noexcept
    : StartVideoResponse() {
    *this = ::std::move(from);
  }

  inline StartVideoResponse& operator=(const StartVideoResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StartVideoResponse& operator=(StartVideoResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StartVideoResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const StartVideoResponse* internal_default_instance() {
    return reinterpret_cast<const StartVideoResponse*>(
               &_StartVideoResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(StartVideoResponse& a, StartVideoResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(StartVideoResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StartVideoResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StartVideoResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StartVideoResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StartVideoResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StartVideoResponse& from) {
    StartVideoResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StartVideoResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mavsdk.rpc.camera.StartVideoResponse";
  }
  protected:
  explicit StartVideoResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCameraResultFieldNumber = 1,
  };
  // .mavsdk.rpc.camera.CameraResult camera_result = 1;
  bool has_camera_result() const;
  void clear_camera_result() ;
  const ::mavsdk::rpc::camera::CameraResult& camera_result() const;
  PROTOBUF_NODISCARD ::mavsdk::rpc::camera::CameraResult* release_camera_result();
  ::mavsdk::rpc::camera::CameraResult* mutable_camera_result();
  void set_allocated_camera_result(::mavsdk::rpc::camera::CameraResult* camera_result);
  private:
  const ::mavsdk::rpc::camera::CameraResult& _internal_camera_result() const;
  ::mavsdk::rpc::camera::CameraResult* _internal_mutable_camera_result();
  public:
  void unsafe_arena_set_allocated_camera_result(
      ::mavsdk::rpc::camera::CameraResult* camera_result);
  ::mavsdk::rpc::camera::CameraResult* unsafe_arena_release_camera_result();
  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera.StartVideoResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::mavsdk::rpc::camera::CameraResult* camera_result_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camera_2fcamera_2eproto;
};// -------------------------------------------------------------------

class StopVideoRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera.StopVideoRequest) */ {
 public:
  inline StopVideoRequest() : StopVideoRequest(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StopVideoRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StopVideoRequest(const StopVideoRequest& from);
  StopVideoRequest(StopVideoRequest&& from) noexcept
    : StopVideoRequest() {
    *this = ::std::move(from);
  }

  inline StopVideoRequest& operator=(const StopVideoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StopVideoRequest& operator=(StopVideoRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StopVideoRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const StopVideoRequest* internal_default_instance() {
    return reinterpret_cast<const StopVideoRequest*>(
               &_StopVideoRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(StopVideoRequest& a, StopVideoRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(StopVideoRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StopVideoRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StopVideoRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StopVideoRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const StopVideoRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const StopVideoRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mavsdk.rpc.camera.StopVideoRequest";
  }
  protected:
  explicit StopVideoRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera.StopVideoRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_camera_2fcamera_2eproto;
};// -------------------------------------------------------------------

class StopVideoResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera.StopVideoResponse) */ {
 public:
  inline StopVideoResponse() : StopVideoResponse(nullptr) {}
  ~StopVideoResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StopVideoResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StopVideoResponse(const StopVideoResponse& from);
  StopVideoResponse(StopVideoResponse&& from) noexcept
    : StopVideoResponse() {
    *this = ::std::move(from);
  }

  inline StopVideoResponse& operator=(const StopVideoResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StopVideoResponse& operator=(StopVideoResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StopVideoResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const StopVideoResponse* internal_default_instance() {
    return reinterpret_cast<const StopVideoResponse*>(
               &_StopVideoResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(StopVideoResponse& a, StopVideoResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(StopVideoResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StopVideoResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StopVideoResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StopVideoResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StopVideoResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StopVideoResponse& from) {
    StopVideoResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StopVideoResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mavsdk.rpc.camera.StopVideoResponse";
  }
  protected:
  explicit StopVideoResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCameraResultFieldNumber = 1,
  };
  // .mavsdk.rpc.camera.CameraResult camera_result = 1;
  bool has_camera_result() const;
  void clear_camera_result() ;
  const ::mavsdk::rpc::camera::CameraResult& camera_result() const;
  PROTOBUF_NODISCARD ::mavsdk::rpc::camera::CameraResult* release_camera_result();
  ::mavsdk::rpc::camera::CameraResult* mutable_camera_result();
  void set_allocated_camera_result(::mavsdk::rpc::camera::CameraResult* camera_result);
  private:
  const ::mavsdk::rpc::camera::CameraResult& _internal_camera_result() const;
  ::mavsdk::rpc::camera::CameraResult* _internal_mutable_camera_result();
  public:
  void unsafe_arena_set_allocated_camera_result(
      ::mavsdk::rpc::camera::CameraResult* camera_result);
  ::mavsdk::rpc::camera::CameraResult* unsafe_arena_release_camera_result();
  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera.StopVideoResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::mavsdk::rpc::camera::CameraResult* camera_result_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camera_2fcamera_2eproto;
};// -------------------------------------------------------------------

class StartVideoStreamingRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera.StartVideoStreamingRequest) */ {
 public:
  inline StartVideoStreamingRequest() : StartVideoStreamingRequest(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StartVideoStreamingRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StartVideoStreamingRequest(const StartVideoStreamingRequest& from);
  StartVideoStreamingRequest(StartVideoStreamingRequest&& from) noexcept
    : StartVideoStreamingRequest() {
    *this = ::std::move(from);
  }

  inline StartVideoStreamingRequest& operator=(const StartVideoStreamingRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StartVideoStreamingRequest& operator=(StartVideoStreamingRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StartVideoStreamingRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const StartVideoStreamingRequest* internal_default_instance() {
    return reinterpret_cast<const StartVideoStreamingRequest*>(
               &_StartVideoStreamingRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(StartVideoStreamingRequest& a, StartVideoStreamingRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(StartVideoStreamingRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StartVideoStreamingRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StartVideoStreamingRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StartVideoStreamingRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const StartVideoStreamingRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const StartVideoStreamingRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mavsdk.rpc.camera.StartVideoStreamingRequest";
  }
  protected:
  explicit StartVideoStreamingRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera.StartVideoStreamingRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_camera_2fcamera_2eproto;
};// -------------------------------------------------------------------

class StartVideoStreamingResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera.StartVideoStreamingResponse) */ {
 public:
  inline StartVideoStreamingResponse() : StartVideoStreamingResponse(nullptr) {}
  ~StartVideoStreamingResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StartVideoStreamingResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StartVideoStreamingResponse(const StartVideoStreamingResponse& from);
  StartVideoStreamingResponse(StartVideoStreamingResponse&& from) noexcept
    : StartVideoStreamingResponse() {
    *this = ::std::move(from);
  }

  inline StartVideoStreamingResponse& operator=(const StartVideoStreamingResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StartVideoStreamingResponse& operator=(StartVideoStreamingResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StartVideoStreamingResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const StartVideoStreamingResponse* internal_default_instance() {
    return reinterpret_cast<const StartVideoStreamingResponse*>(
               &_StartVideoStreamingResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(StartVideoStreamingResponse& a, StartVideoStreamingResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(StartVideoStreamingResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StartVideoStreamingResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StartVideoStreamingResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StartVideoStreamingResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StartVideoStreamingResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StartVideoStreamingResponse& from) {
    StartVideoStreamingResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StartVideoStreamingResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mavsdk.rpc.camera.StartVideoStreamingResponse";
  }
  protected:
  explicit StartVideoStreamingResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCameraResultFieldNumber = 1,
  };
  // .mavsdk.rpc.camera.CameraResult camera_result = 1;
  bool has_camera_result() const;
  void clear_camera_result() ;
  const ::mavsdk::rpc::camera::CameraResult& camera_result() const;
  PROTOBUF_NODISCARD ::mavsdk::rpc::camera::CameraResult* release_camera_result();
  ::mavsdk::rpc::camera::CameraResult* mutable_camera_result();
  void set_allocated_camera_result(::mavsdk::rpc::camera::CameraResult* camera_result);
  private:
  const ::mavsdk::rpc::camera::CameraResult& _internal_camera_result() const;
  ::mavsdk::rpc::camera::CameraResult* _internal_mutable_camera_result();
  public:
  void unsafe_arena_set_allocated_camera_result(
      ::mavsdk::rpc::camera::CameraResult* camera_result);
  ::mavsdk::rpc::camera::CameraResult* unsafe_arena_release_camera_result();
  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera.StartVideoStreamingResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::mavsdk::rpc::camera::CameraResult* camera_result_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camera_2fcamera_2eproto;
};// -------------------------------------------------------------------

class StopVideoStreamingRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera.StopVideoStreamingRequest) */ {
 public:
  inline StopVideoStreamingRequest() : StopVideoStreamingRequest(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StopVideoStreamingRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StopVideoStreamingRequest(const StopVideoStreamingRequest& from);
  StopVideoStreamingRequest(StopVideoStreamingRequest&& from) noexcept
    : StopVideoStreamingRequest() {
    *this = ::std::move(from);
  }

  inline StopVideoStreamingRequest& operator=(const StopVideoStreamingRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StopVideoStreamingRequest& operator=(StopVideoStreamingRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StopVideoStreamingRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const StopVideoStreamingRequest* internal_default_instance() {
    return reinterpret_cast<const StopVideoStreamingRequest*>(
               &_StopVideoStreamingRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(StopVideoStreamingRequest& a, StopVideoStreamingRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(StopVideoStreamingRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StopVideoStreamingRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StopVideoStreamingRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StopVideoStreamingRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const StopVideoStreamingRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const StopVideoStreamingRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mavsdk.rpc.camera.StopVideoStreamingRequest";
  }
  protected:
  explicit StopVideoStreamingRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera.StopVideoStreamingRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_camera_2fcamera_2eproto;
};// -------------------------------------------------------------------

class StopVideoStreamingResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera.StopVideoStreamingResponse) */ {
 public:
  inline StopVideoStreamingResponse() : StopVideoStreamingResponse(nullptr) {}
  ~StopVideoStreamingResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StopVideoStreamingResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StopVideoStreamingResponse(const StopVideoStreamingResponse& from);
  StopVideoStreamingResponse(StopVideoStreamingResponse&& from) noexcept
    : StopVideoStreamingResponse() {
    *this = ::std::move(from);
  }

  inline StopVideoStreamingResponse& operator=(const StopVideoStreamingResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StopVideoStreamingResponse& operator=(StopVideoStreamingResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StopVideoStreamingResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const StopVideoStreamingResponse* internal_default_instance() {
    return reinterpret_cast<const StopVideoStreamingResponse*>(
               &_StopVideoStreamingResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(StopVideoStreamingResponse& a, StopVideoStreamingResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(StopVideoStreamingResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StopVideoStreamingResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StopVideoStreamingResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StopVideoStreamingResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StopVideoStreamingResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StopVideoStreamingResponse& from) {
    StopVideoStreamingResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StopVideoStreamingResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mavsdk.rpc.camera.StopVideoStreamingResponse";
  }
  protected:
  explicit StopVideoStreamingResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCameraResultFieldNumber = 1,
  };
  // .mavsdk.rpc.camera.CameraResult camera_result = 1;
  bool has_camera_result() const;
  void clear_camera_result() ;
  const ::mavsdk::rpc::camera::CameraResult& camera_result() const;
  PROTOBUF_NODISCARD ::mavsdk::rpc::camera::CameraResult* release_camera_result();
  ::mavsdk::rpc::camera::CameraResult* mutable_camera_result();
  void set_allocated_camera_result(::mavsdk::rpc::camera::CameraResult* camera_result);
  private:
  const ::mavsdk::rpc::camera::CameraResult& _internal_camera_result() const;
  ::mavsdk::rpc::camera::CameraResult* _internal_mutable_camera_result();
  public:
  void unsafe_arena_set_allocated_camera_result(
      ::mavsdk::rpc::camera::CameraResult* camera_result);
  ::mavsdk::rpc::camera::CameraResult* unsafe_arena_release_camera_result();
  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera.StopVideoStreamingResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::mavsdk::rpc::camera::CameraResult* camera_result_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camera_2fcamera_2eproto;
};// -------------------------------------------------------------------

class SetModeRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera.SetModeRequest) */ {
 public:
  inline SetModeRequest() : SetModeRequest(nullptr) {}
  ~SetModeRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SetModeRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetModeRequest(const SetModeRequest& from);
  SetModeRequest(SetModeRequest&& from) noexcept
    : SetModeRequest() {
    *this = ::std::move(from);
  }

  inline SetModeRequest& operator=(const SetModeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetModeRequest& operator=(SetModeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetModeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetModeRequest* internal_default_instance() {
    return reinterpret_cast<const SetModeRequest*>(
               &_SetModeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(SetModeRequest& a, SetModeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SetModeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetModeRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetModeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetModeRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetModeRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetModeRequest& from) {
    SetModeRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetModeRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mavsdk.rpc.camera.SetModeRequest";
  }
  protected:
  explicit SetModeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModeFieldNumber = 1,
  };
  // .mavsdk.rpc.camera.Mode mode = 1;
  void clear_mode() ;
  ::mavsdk::rpc::camera::Mode mode() const;
  void set_mode(::mavsdk::rpc::camera::Mode value);

  private:
  ::mavsdk::rpc::camera::Mode _internal_mode() const;
  void _internal_set_mode(::mavsdk::rpc::camera::Mode value);

  public:
  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera.SetModeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int mode_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camera_2fcamera_2eproto;
};// -------------------------------------------------------------------

class SetModeResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera.SetModeResponse) */ {
 public:
  inline SetModeResponse() : SetModeResponse(nullptr) {}
  ~SetModeResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SetModeResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetModeResponse(const SetModeResponse& from);
  SetModeResponse(SetModeResponse&& from) noexcept
    : SetModeResponse() {
    *this = ::std::move(from);
  }

  inline SetModeResponse& operator=(const SetModeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetModeResponse& operator=(SetModeResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetModeResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetModeResponse* internal_default_instance() {
    return reinterpret_cast<const SetModeResponse*>(
               &_SetModeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(SetModeResponse& a, SetModeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SetModeResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetModeResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetModeResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetModeResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetModeResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetModeResponse& from) {
    SetModeResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetModeResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mavsdk.rpc.camera.SetModeResponse";
  }
  protected:
  explicit SetModeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCameraResultFieldNumber = 1,
  };
  // .mavsdk.rpc.camera.CameraResult camera_result = 1;
  bool has_camera_result() const;
  void clear_camera_result() ;
  const ::mavsdk::rpc::camera::CameraResult& camera_result() const;
  PROTOBUF_NODISCARD ::mavsdk::rpc::camera::CameraResult* release_camera_result();
  ::mavsdk::rpc::camera::CameraResult* mutable_camera_result();
  void set_allocated_camera_result(::mavsdk::rpc::camera::CameraResult* camera_result);
  private:
  const ::mavsdk::rpc::camera::CameraResult& _internal_camera_result() const;
  ::mavsdk::rpc::camera::CameraResult* _internal_mutable_camera_result();
  public:
  void unsafe_arena_set_allocated_camera_result(
      ::mavsdk::rpc::camera::CameraResult* camera_result);
  ::mavsdk::rpc::camera::CameraResult* unsafe_arena_release_camera_result();
  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera.SetModeResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::mavsdk::rpc::camera::CameraResult* camera_result_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camera_2fcamera_2eproto;
};// -------------------------------------------------------------------

class ListPhotosRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera.ListPhotosRequest) */ {
 public:
  inline ListPhotosRequest() : ListPhotosRequest(nullptr) {}
  ~ListPhotosRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ListPhotosRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListPhotosRequest(const ListPhotosRequest& from);
  ListPhotosRequest(ListPhotosRequest&& from) noexcept
    : ListPhotosRequest() {
    *this = ::std::move(from);
  }

  inline ListPhotosRequest& operator=(const ListPhotosRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListPhotosRequest& operator=(ListPhotosRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListPhotosRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListPhotosRequest* internal_default_instance() {
    return reinterpret_cast<const ListPhotosRequest*>(
               &_ListPhotosRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(ListPhotosRequest& a, ListPhotosRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListPhotosRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListPhotosRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListPhotosRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListPhotosRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListPhotosRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListPhotosRequest& from) {
    ListPhotosRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListPhotosRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mavsdk.rpc.camera.ListPhotosRequest";
  }
  protected:
  explicit ListPhotosRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPhotosRangeFieldNumber = 1,
  };
  // .mavsdk.rpc.camera.PhotosRange photos_range = 1;
  void clear_photos_range() ;
  ::mavsdk::rpc::camera::PhotosRange photos_range() const;
  void set_photos_range(::mavsdk::rpc::camera::PhotosRange value);

  private:
  ::mavsdk::rpc::camera::PhotosRange _internal_photos_range() const;
  void _internal_set_photos_range(::mavsdk::rpc::camera::PhotosRange value);

  public:
  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera.ListPhotosRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int photos_range_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camera_2fcamera_2eproto;
};// -------------------------------------------------------------------

class ListPhotosResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera.ListPhotosResponse) */ {
 public:
  inline ListPhotosResponse() : ListPhotosResponse(nullptr) {}
  ~ListPhotosResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ListPhotosResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListPhotosResponse(const ListPhotosResponse& from);
  ListPhotosResponse(ListPhotosResponse&& from) noexcept
    : ListPhotosResponse() {
    *this = ::std::move(from);
  }

  inline ListPhotosResponse& operator=(const ListPhotosResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListPhotosResponse& operator=(ListPhotosResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListPhotosResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListPhotosResponse* internal_default_instance() {
    return reinterpret_cast<const ListPhotosResponse*>(
               &_ListPhotosResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(ListPhotosResponse& a, ListPhotosResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListPhotosResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListPhotosResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListPhotosResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListPhotosResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListPhotosResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListPhotosResponse& from) {
    ListPhotosResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListPhotosResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mavsdk.rpc.camera.ListPhotosResponse";
  }
  protected:
  explicit ListPhotosResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCaptureInfosFieldNumber = 2,
    kCameraResultFieldNumber = 1,
  };
  // repeated .mavsdk.rpc.camera.CaptureInfo capture_infos = 2;
  int capture_infos_size() const;
  private:
  int _internal_capture_infos_size() const;

  public:
  void clear_capture_infos() ;
  ::mavsdk::rpc::camera::CaptureInfo* mutable_capture_infos(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mavsdk::rpc::camera::CaptureInfo >*
      mutable_capture_infos();
  private:
  const ::mavsdk::rpc::camera::CaptureInfo& _internal_capture_infos(int index) const;
  ::mavsdk::rpc::camera::CaptureInfo* _internal_add_capture_infos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::mavsdk::rpc::camera::CaptureInfo>& _internal_capture_infos() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::mavsdk::rpc::camera::CaptureInfo>* _internal_mutable_capture_infos();
  public:
  const ::mavsdk::rpc::camera::CaptureInfo& capture_infos(int index) const;
  ::mavsdk::rpc::camera::CaptureInfo* add_capture_infos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mavsdk::rpc::camera::CaptureInfo >&
      capture_infos() const;
  // .mavsdk.rpc.camera.CameraResult camera_result = 1;
  bool has_camera_result() const;
  void clear_camera_result() ;
  const ::mavsdk::rpc::camera::CameraResult& camera_result() const;
  PROTOBUF_NODISCARD ::mavsdk::rpc::camera::CameraResult* release_camera_result();
  ::mavsdk::rpc::camera::CameraResult* mutable_camera_result();
  void set_allocated_camera_result(::mavsdk::rpc::camera::CameraResult* camera_result);
  private:
  const ::mavsdk::rpc::camera::CameraResult& _internal_camera_result() const;
  ::mavsdk::rpc::camera::CameraResult* _internal_mutable_camera_result();
  public:
  void unsafe_arena_set_allocated_camera_result(
      ::mavsdk::rpc::camera::CameraResult* camera_result);
  ::mavsdk::rpc::camera::CameraResult* unsafe_arena_release_camera_result();
  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera.ListPhotosResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mavsdk::rpc::camera::CaptureInfo > capture_infos_;
    ::mavsdk::rpc::camera::CameraResult* camera_result_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camera_2fcamera_2eproto;
};// -------------------------------------------------------------------

class SubscribeInformationRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera.SubscribeInformationRequest) */ {
 public:
  inline SubscribeInformationRequest() : SubscribeInformationRequest(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SubscribeInformationRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubscribeInformationRequest(const SubscribeInformationRequest& from);
  SubscribeInformationRequest(SubscribeInformationRequest&& from) noexcept
    : SubscribeInformationRequest() {
    *this = ::std::move(from);
  }

  inline SubscribeInformationRequest& operator=(const SubscribeInformationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscribeInformationRequest& operator=(SubscribeInformationRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscribeInformationRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubscribeInformationRequest* internal_default_instance() {
    return reinterpret_cast<const SubscribeInformationRequest*>(
               &_SubscribeInformationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(SubscribeInformationRequest& a, SubscribeInformationRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SubscribeInformationRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscribeInformationRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscribeInformationRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubscribeInformationRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SubscribeInformationRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SubscribeInformationRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mavsdk.rpc.camera.SubscribeInformationRequest";
  }
  protected:
  explicit SubscribeInformationRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera.SubscribeInformationRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_camera_2fcamera_2eproto;
};// -------------------------------------------------------------------

class InformationResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera.InformationResponse) */ {
 public:
  inline InformationResponse() : InformationResponse(nullptr) {}
  ~InformationResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR InformationResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InformationResponse(const InformationResponse& from);
  InformationResponse(InformationResponse&& from) noexcept
    : InformationResponse() {
    *this = ::std::move(from);
  }

  inline InformationResponse& operator=(const InformationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline InformationResponse& operator=(InformationResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InformationResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const InformationResponse* internal_default_instance() {
    return reinterpret_cast<const InformationResponse*>(
               &_InformationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(InformationResponse& a, InformationResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(InformationResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InformationResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InformationResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InformationResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InformationResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InformationResponse& from) {
    InformationResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InformationResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mavsdk.rpc.camera.InformationResponse";
  }
  protected:
  explicit InformationResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInformationFieldNumber = 1,
  };
  // .mavsdk.rpc.camera.Information information = 1;
  bool has_information() const;
  void clear_information() ;
  const ::mavsdk::rpc::camera::Information& information() const;
  PROTOBUF_NODISCARD ::mavsdk::rpc::camera::Information* release_information();
  ::mavsdk::rpc::camera::Information* mutable_information();
  void set_allocated_information(::mavsdk::rpc::camera::Information* information);
  private:
  const ::mavsdk::rpc::camera::Information& _internal_information() const;
  ::mavsdk::rpc::camera::Information* _internal_mutable_information();
  public:
  void unsafe_arena_set_allocated_information(
      ::mavsdk::rpc::camera::Information* information);
  ::mavsdk::rpc::camera::Information* unsafe_arena_release_information();
  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera.InformationResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::mavsdk::rpc::camera::Information* information_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camera_2fcamera_2eproto;
};// -------------------------------------------------------------------

class SubscribeModeRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera.SubscribeModeRequest) */ {
 public:
  inline SubscribeModeRequest() : SubscribeModeRequest(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SubscribeModeRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubscribeModeRequest(const SubscribeModeRequest& from);
  SubscribeModeRequest(SubscribeModeRequest&& from) noexcept
    : SubscribeModeRequest() {
    *this = ::std::move(from);
  }

  inline SubscribeModeRequest& operator=(const SubscribeModeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscribeModeRequest& operator=(SubscribeModeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscribeModeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubscribeModeRequest* internal_default_instance() {
    return reinterpret_cast<const SubscribeModeRequest*>(
               &_SubscribeModeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(SubscribeModeRequest& a, SubscribeModeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SubscribeModeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscribeModeRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscribeModeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubscribeModeRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SubscribeModeRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SubscribeModeRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mavsdk.rpc.camera.SubscribeModeRequest";
  }
  protected:
  explicit SubscribeModeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera.SubscribeModeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_camera_2fcamera_2eproto;
};// -------------------------------------------------------------------

class ModeResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera.ModeResponse) */ {
 public:
  inline ModeResponse() : ModeResponse(nullptr) {}
  ~ModeResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ModeResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModeResponse(const ModeResponse& from);
  ModeResponse(ModeResponse&& from) noexcept
    : ModeResponse() {
    *this = ::std::move(from);
  }

  inline ModeResponse& operator=(const ModeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModeResponse& operator=(ModeResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModeResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModeResponse* internal_default_instance() {
    return reinterpret_cast<const ModeResponse*>(
               &_ModeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(ModeResponse& a, ModeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ModeResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModeResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModeResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModeResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModeResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ModeResponse& from) {
    ModeResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModeResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mavsdk.rpc.camera.ModeResponse";
  }
  protected:
  explicit ModeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModeFieldNumber = 1,
  };
  // .mavsdk.rpc.camera.Mode mode = 1;
  void clear_mode() ;
  ::mavsdk::rpc::camera::Mode mode() const;
  void set_mode(::mavsdk::rpc::camera::Mode value);

  private:
  ::mavsdk::rpc::camera::Mode _internal_mode() const;
  void _internal_set_mode(::mavsdk::rpc::camera::Mode value);

  public:
  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera.ModeResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int mode_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camera_2fcamera_2eproto;
};// -------------------------------------------------------------------

class SubscribeVideoStreamInfoRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera.SubscribeVideoStreamInfoRequest) */ {
 public:
  inline SubscribeVideoStreamInfoRequest() : SubscribeVideoStreamInfoRequest(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SubscribeVideoStreamInfoRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubscribeVideoStreamInfoRequest(const SubscribeVideoStreamInfoRequest& from);
  SubscribeVideoStreamInfoRequest(SubscribeVideoStreamInfoRequest&& from) noexcept
    : SubscribeVideoStreamInfoRequest() {
    *this = ::std::move(from);
  }

  inline SubscribeVideoStreamInfoRequest& operator=(const SubscribeVideoStreamInfoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscribeVideoStreamInfoRequest& operator=(SubscribeVideoStreamInfoRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscribeVideoStreamInfoRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubscribeVideoStreamInfoRequest* internal_default_instance() {
    return reinterpret_cast<const SubscribeVideoStreamInfoRequest*>(
               &_SubscribeVideoStreamInfoRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(SubscribeVideoStreamInfoRequest& a, SubscribeVideoStreamInfoRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SubscribeVideoStreamInfoRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscribeVideoStreamInfoRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscribeVideoStreamInfoRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubscribeVideoStreamInfoRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SubscribeVideoStreamInfoRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SubscribeVideoStreamInfoRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mavsdk.rpc.camera.SubscribeVideoStreamInfoRequest";
  }
  protected:
  explicit SubscribeVideoStreamInfoRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera.SubscribeVideoStreamInfoRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_camera_2fcamera_2eproto;
};// -------------------------------------------------------------------

class VideoStreamInfoResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera.VideoStreamInfoResponse) */ {
 public:
  inline VideoStreamInfoResponse() : VideoStreamInfoResponse(nullptr) {}
  ~VideoStreamInfoResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR VideoStreamInfoResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VideoStreamInfoResponse(const VideoStreamInfoResponse& from);
  VideoStreamInfoResponse(VideoStreamInfoResponse&& from) noexcept
    : VideoStreamInfoResponse() {
    *this = ::std::move(from);
  }

  inline VideoStreamInfoResponse& operator=(const VideoStreamInfoResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline VideoStreamInfoResponse& operator=(VideoStreamInfoResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VideoStreamInfoResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const VideoStreamInfoResponse* internal_default_instance() {
    return reinterpret_cast<const VideoStreamInfoResponse*>(
               &_VideoStreamInfoResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(VideoStreamInfoResponse& a, VideoStreamInfoResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(VideoStreamInfoResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VideoStreamInfoResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VideoStreamInfoResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VideoStreamInfoResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VideoStreamInfoResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VideoStreamInfoResponse& from) {
    VideoStreamInfoResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VideoStreamInfoResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mavsdk.rpc.camera.VideoStreamInfoResponse";
  }
  protected:
  explicit VideoStreamInfoResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVideoStreamInfoFieldNumber = 1,
  };
  // .mavsdk.rpc.camera.VideoStreamInfo video_stream_info = 1;
  bool has_video_stream_info() const;
  void clear_video_stream_info() ;
  const ::mavsdk::rpc::camera::VideoStreamInfo& video_stream_info() const;
  PROTOBUF_NODISCARD ::mavsdk::rpc::camera::VideoStreamInfo* release_video_stream_info();
  ::mavsdk::rpc::camera::VideoStreamInfo* mutable_video_stream_info();
  void set_allocated_video_stream_info(::mavsdk::rpc::camera::VideoStreamInfo* video_stream_info);
  private:
  const ::mavsdk::rpc::camera::VideoStreamInfo& _internal_video_stream_info() const;
  ::mavsdk::rpc::camera::VideoStreamInfo* _internal_mutable_video_stream_info();
  public:
  void unsafe_arena_set_allocated_video_stream_info(
      ::mavsdk::rpc::camera::VideoStreamInfo* video_stream_info);
  ::mavsdk::rpc::camera::VideoStreamInfo* unsafe_arena_release_video_stream_info();
  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera.VideoStreamInfoResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::mavsdk::rpc::camera::VideoStreamInfo* video_stream_info_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camera_2fcamera_2eproto;
};// -------------------------------------------------------------------

class SubscribeCaptureInfoRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera.SubscribeCaptureInfoRequest) */ {
 public:
  inline SubscribeCaptureInfoRequest() : SubscribeCaptureInfoRequest(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SubscribeCaptureInfoRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubscribeCaptureInfoRequest(const SubscribeCaptureInfoRequest& from);
  SubscribeCaptureInfoRequest(SubscribeCaptureInfoRequest&& from) noexcept
    : SubscribeCaptureInfoRequest() {
    *this = ::std::move(from);
  }

  inline SubscribeCaptureInfoRequest& operator=(const SubscribeCaptureInfoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscribeCaptureInfoRequest& operator=(SubscribeCaptureInfoRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscribeCaptureInfoRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubscribeCaptureInfoRequest* internal_default_instance() {
    return reinterpret_cast<const SubscribeCaptureInfoRequest*>(
               &_SubscribeCaptureInfoRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(SubscribeCaptureInfoRequest& a, SubscribeCaptureInfoRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SubscribeCaptureInfoRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscribeCaptureInfoRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscribeCaptureInfoRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubscribeCaptureInfoRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SubscribeCaptureInfoRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SubscribeCaptureInfoRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mavsdk.rpc.camera.SubscribeCaptureInfoRequest";
  }
  protected:
  explicit SubscribeCaptureInfoRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera.SubscribeCaptureInfoRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_camera_2fcamera_2eproto;
};// -------------------------------------------------------------------

class CaptureInfoResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera.CaptureInfoResponse) */ {
 public:
  inline CaptureInfoResponse() : CaptureInfoResponse(nullptr) {}
  ~CaptureInfoResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CaptureInfoResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CaptureInfoResponse(const CaptureInfoResponse& from);
  CaptureInfoResponse(CaptureInfoResponse&& from) noexcept
    : CaptureInfoResponse() {
    *this = ::std::move(from);
  }

  inline CaptureInfoResponse& operator=(const CaptureInfoResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CaptureInfoResponse& operator=(CaptureInfoResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CaptureInfoResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CaptureInfoResponse* internal_default_instance() {
    return reinterpret_cast<const CaptureInfoResponse*>(
               &_CaptureInfoResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(CaptureInfoResponse& a, CaptureInfoResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CaptureInfoResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CaptureInfoResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CaptureInfoResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CaptureInfoResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CaptureInfoResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CaptureInfoResponse& from) {
    CaptureInfoResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CaptureInfoResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mavsdk.rpc.camera.CaptureInfoResponse";
  }
  protected:
  explicit CaptureInfoResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCaptureInfoFieldNumber = 1,
  };
  // .mavsdk.rpc.camera.CaptureInfo capture_info = 1;
  bool has_capture_info() const;
  void clear_capture_info() ;
  const ::mavsdk::rpc::camera::CaptureInfo& capture_info() const;
  PROTOBUF_NODISCARD ::mavsdk::rpc::camera::CaptureInfo* release_capture_info();
  ::mavsdk::rpc::camera::CaptureInfo* mutable_capture_info();
  void set_allocated_capture_info(::mavsdk::rpc::camera::CaptureInfo* capture_info);
  private:
  const ::mavsdk::rpc::camera::CaptureInfo& _internal_capture_info() const;
  ::mavsdk::rpc::camera::CaptureInfo* _internal_mutable_capture_info();
  public:
  void unsafe_arena_set_allocated_capture_info(
      ::mavsdk::rpc::camera::CaptureInfo* capture_info);
  ::mavsdk::rpc::camera::CaptureInfo* unsafe_arena_release_capture_info();
  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera.CaptureInfoResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::mavsdk::rpc::camera::CaptureInfo* capture_info_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camera_2fcamera_2eproto;
};// -------------------------------------------------------------------

class SubscribeStatusRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera.SubscribeStatusRequest) */ {
 public:
  inline SubscribeStatusRequest() : SubscribeStatusRequest(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SubscribeStatusRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubscribeStatusRequest(const SubscribeStatusRequest& from);
  SubscribeStatusRequest(SubscribeStatusRequest&& from) noexcept
    : SubscribeStatusRequest() {
    *this = ::std::move(from);
  }

  inline SubscribeStatusRequest& operator=(const SubscribeStatusRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscribeStatusRequest& operator=(SubscribeStatusRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscribeStatusRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubscribeStatusRequest* internal_default_instance() {
    return reinterpret_cast<const SubscribeStatusRequest*>(
               &_SubscribeStatusRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(SubscribeStatusRequest& a, SubscribeStatusRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SubscribeStatusRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscribeStatusRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscribeStatusRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubscribeStatusRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SubscribeStatusRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SubscribeStatusRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mavsdk.rpc.camera.SubscribeStatusRequest";
  }
  protected:
  explicit SubscribeStatusRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera.SubscribeStatusRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_camera_2fcamera_2eproto;
};// -------------------------------------------------------------------

class StatusResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera.StatusResponse) */ {
 public:
  inline StatusResponse() : StatusResponse(nullptr) {}
  ~StatusResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StatusResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StatusResponse(const StatusResponse& from);
  StatusResponse(StatusResponse&& from) noexcept
    : StatusResponse() {
    *this = ::std::move(from);
  }

  inline StatusResponse& operator=(const StatusResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StatusResponse& operator=(StatusResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StatusResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const StatusResponse* internal_default_instance() {
    return reinterpret_cast<const StatusResponse*>(
               &_StatusResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(StatusResponse& a, StatusResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(StatusResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StatusResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StatusResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StatusResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StatusResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StatusResponse& from) {
    StatusResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StatusResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mavsdk.rpc.camera.StatusResponse";
  }
  protected:
  explicit StatusResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCameraStatusFieldNumber = 1,
  };
  // .mavsdk.rpc.camera.Status camera_status = 1;
  bool has_camera_status() const;
  void clear_camera_status() ;
  const ::mavsdk::rpc::camera::Status& camera_status() const;
  PROTOBUF_NODISCARD ::mavsdk::rpc::camera::Status* release_camera_status();
  ::mavsdk::rpc::camera::Status* mutable_camera_status();
  void set_allocated_camera_status(::mavsdk::rpc::camera::Status* camera_status);
  private:
  const ::mavsdk::rpc::camera::Status& _internal_camera_status() const;
  ::mavsdk::rpc::camera::Status* _internal_mutable_camera_status();
  public:
  void unsafe_arena_set_allocated_camera_status(
      ::mavsdk::rpc::camera::Status* camera_status);
  ::mavsdk::rpc::camera::Status* unsafe_arena_release_camera_status();
  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera.StatusResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::mavsdk::rpc::camera::Status* camera_status_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camera_2fcamera_2eproto;
};// -------------------------------------------------------------------

class SubscribeCurrentSettingsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera.SubscribeCurrentSettingsRequest) */ {
 public:
  inline SubscribeCurrentSettingsRequest() : SubscribeCurrentSettingsRequest(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SubscribeCurrentSettingsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubscribeCurrentSettingsRequest(const SubscribeCurrentSettingsRequest& from);
  SubscribeCurrentSettingsRequest(SubscribeCurrentSettingsRequest&& from) noexcept
    : SubscribeCurrentSettingsRequest() {
    *this = ::std::move(from);
  }

  inline SubscribeCurrentSettingsRequest& operator=(const SubscribeCurrentSettingsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscribeCurrentSettingsRequest& operator=(SubscribeCurrentSettingsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscribeCurrentSettingsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubscribeCurrentSettingsRequest* internal_default_instance() {
    return reinterpret_cast<const SubscribeCurrentSettingsRequest*>(
               &_SubscribeCurrentSettingsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(SubscribeCurrentSettingsRequest& a, SubscribeCurrentSettingsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SubscribeCurrentSettingsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscribeCurrentSettingsRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscribeCurrentSettingsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubscribeCurrentSettingsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SubscribeCurrentSettingsRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SubscribeCurrentSettingsRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mavsdk.rpc.camera.SubscribeCurrentSettingsRequest";
  }
  protected:
  explicit SubscribeCurrentSettingsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera.SubscribeCurrentSettingsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_camera_2fcamera_2eproto;
};// -------------------------------------------------------------------

class CurrentSettingsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera.CurrentSettingsResponse) */ {
 public:
  inline CurrentSettingsResponse() : CurrentSettingsResponse(nullptr) {}
  ~CurrentSettingsResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CurrentSettingsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CurrentSettingsResponse(const CurrentSettingsResponse& from);
  CurrentSettingsResponse(CurrentSettingsResponse&& from) noexcept
    : CurrentSettingsResponse() {
    *this = ::std::move(from);
  }

  inline CurrentSettingsResponse& operator=(const CurrentSettingsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CurrentSettingsResponse& operator=(CurrentSettingsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CurrentSettingsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CurrentSettingsResponse* internal_default_instance() {
    return reinterpret_cast<const CurrentSettingsResponse*>(
               &_CurrentSettingsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(CurrentSettingsResponse& a, CurrentSettingsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CurrentSettingsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CurrentSettingsResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CurrentSettingsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CurrentSettingsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CurrentSettingsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CurrentSettingsResponse& from) {
    CurrentSettingsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CurrentSettingsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mavsdk.rpc.camera.CurrentSettingsResponse";
  }
  protected:
  explicit CurrentSettingsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCurrentSettingsFieldNumber = 1,
  };
  // repeated .mavsdk.rpc.camera.Setting current_settings = 1;
  int current_settings_size() const;
  private:
  int _internal_current_settings_size() const;

  public:
  void clear_current_settings() ;
  ::mavsdk::rpc::camera::Setting* mutable_current_settings(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mavsdk::rpc::camera::Setting >*
      mutable_current_settings();
  private:
  const ::mavsdk::rpc::camera::Setting& _internal_current_settings(int index) const;
  ::mavsdk::rpc::camera::Setting* _internal_add_current_settings();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::mavsdk::rpc::camera::Setting>& _internal_current_settings() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::mavsdk::rpc::camera::Setting>* _internal_mutable_current_settings();
  public:
  const ::mavsdk::rpc::camera::Setting& current_settings(int index) const;
  ::mavsdk::rpc::camera::Setting* add_current_settings();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mavsdk::rpc::camera::Setting >&
      current_settings() const;
  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera.CurrentSettingsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mavsdk::rpc::camera::Setting > current_settings_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camera_2fcamera_2eproto;
};// -------------------------------------------------------------------

class SubscribePossibleSettingOptionsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera.SubscribePossibleSettingOptionsRequest) */ {
 public:
  inline SubscribePossibleSettingOptionsRequest() : SubscribePossibleSettingOptionsRequest(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SubscribePossibleSettingOptionsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubscribePossibleSettingOptionsRequest(const SubscribePossibleSettingOptionsRequest& from);
  SubscribePossibleSettingOptionsRequest(SubscribePossibleSettingOptionsRequest&& from) noexcept
    : SubscribePossibleSettingOptionsRequest() {
    *this = ::std::move(from);
  }

  inline SubscribePossibleSettingOptionsRequest& operator=(const SubscribePossibleSettingOptionsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscribePossibleSettingOptionsRequest& operator=(SubscribePossibleSettingOptionsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscribePossibleSettingOptionsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubscribePossibleSettingOptionsRequest* internal_default_instance() {
    return reinterpret_cast<const SubscribePossibleSettingOptionsRequest*>(
               &_SubscribePossibleSettingOptionsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(SubscribePossibleSettingOptionsRequest& a, SubscribePossibleSettingOptionsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SubscribePossibleSettingOptionsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscribePossibleSettingOptionsRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscribePossibleSettingOptionsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubscribePossibleSettingOptionsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SubscribePossibleSettingOptionsRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SubscribePossibleSettingOptionsRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mavsdk.rpc.camera.SubscribePossibleSettingOptionsRequest";
  }
  protected:
  explicit SubscribePossibleSettingOptionsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera.SubscribePossibleSettingOptionsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_camera_2fcamera_2eproto;
};// -------------------------------------------------------------------

class PossibleSettingOptionsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera.PossibleSettingOptionsResponse) */ {
 public:
  inline PossibleSettingOptionsResponse() : PossibleSettingOptionsResponse(nullptr) {}
  ~PossibleSettingOptionsResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PossibleSettingOptionsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PossibleSettingOptionsResponse(const PossibleSettingOptionsResponse& from);
  PossibleSettingOptionsResponse(PossibleSettingOptionsResponse&& from) noexcept
    : PossibleSettingOptionsResponse() {
    *this = ::std::move(from);
  }

  inline PossibleSettingOptionsResponse& operator=(const PossibleSettingOptionsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PossibleSettingOptionsResponse& operator=(PossibleSettingOptionsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PossibleSettingOptionsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const PossibleSettingOptionsResponse* internal_default_instance() {
    return reinterpret_cast<const PossibleSettingOptionsResponse*>(
               &_PossibleSettingOptionsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(PossibleSettingOptionsResponse& a, PossibleSettingOptionsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(PossibleSettingOptionsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PossibleSettingOptionsResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PossibleSettingOptionsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PossibleSettingOptionsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PossibleSettingOptionsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PossibleSettingOptionsResponse& from) {
    PossibleSettingOptionsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PossibleSettingOptionsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mavsdk.rpc.camera.PossibleSettingOptionsResponse";
  }
  protected:
  explicit PossibleSettingOptionsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSettingOptionsFieldNumber = 1,
  };
  // repeated .mavsdk.rpc.camera.SettingOptions setting_options = 1;
  int setting_options_size() const;
  private:
  int _internal_setting_options_size() const;

  public:
  void clear_setting_options() ;
  ::mavsdk::rpc::camera::SettingOptions* mutable_setting_options(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mavsdk::rpc::camera::SettingOptions >*
      mutable_setting_options();
  private:
  const ::mavsdk::rpc::camera::SettingOptions& _internal_setting_options(int index) const;
  ::mavsdk::rpc::camera::SettingOptions* _internal_add_setting_options();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::mavsdk::rpc::camera::SettingOptions>& _internal_setting_options() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::mavsdk::rpc::camera::SettingOptions>* _internal_mutable_setting_options();
  public:
  const ::mavsdk::rpc::camera::SettingOptions& setting_options(int index) const;
  ::mavsdk::rpc::camera::SettingOptions* add_setting_options();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mavsdk::rpc::camera::SettingOptions >&
      setting_options() const;
  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera.PossibleSettingOptionsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mavsdk::rpc::camera::SettingOptions > setting_options_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camera_2fcamera_2eproto;
};// -------------------------------------------------------------------

class SetSettingRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera.SetSettingRequest) */ {
 public:
  inline SetSettingRequest() : SetSettingRequest(nullptr) {}
  ~SetSettingRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SetSettingRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetSettingRequest(const SetSettingRequest& from);
  SetSettingRequest(SetSettingRequest&& from) noexcept
    : SetSettingRequest() {
    *this = ::std::move(from);
  }

  inline SetSettingRequest& operator=(const SetSettingRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetSettingRequest& operator=(SetSettingRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetSettingRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetSettingRequest* internal_default_instance() {
    return reinterpret_cast<const SetSettingRequest*>(
               &_SetSettingRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(SetSettingRequest& a, SetSettingRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SetSettingRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetSettingRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetSettingRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetSettingRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetSettingRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetSettingRequest& from) {
    SetSettingRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetSettingRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mavsdk.rpc.camera.SetSettingRequest";
  }
  protected:
  explicit SetSettingRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSettingFieldNumber = 1,
  };
  // .mavsdk.rpc.camera.Setting setting = 1;
  bool has_setting() const;
  void clear_setting() ;
  const ::mavsdk::rpc::camera::Setting& setting() const;
  PROTOBUF_NODISCARD ::mavsdk::rpc::camera::Setting* release_setting();
  ::mavsdk::rpc::camera::Setting* mutable_setting();
  void set_allocated_setting(::mavsdk::rpc::camera::Setting* setting);
  private:
  const ::mavsdk::rpc::camera::Setting& _internal_setting() const;
  ::mavsdk::rpc::camera::Setting* _internal_mutable_setting();
  public:
  void unsafe_arena_set_allocated_setting(
      ::mavsdk::rpc::camera::Setting* setting);
  ::mavsdk::rpc::camera::Setting* unsafe_arena_release_setting();
  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera.SetSettingRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::mavsdk::rpc::camera::Setting* setting_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camera_2fcamera_2eproto;
};// -------------------------------------------------------------------

class SetSettingResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera.SetSettingResponse) */ {
 public:
  inline SetSettingResponse() : SetSettingResponse(nullptr) {}
  ~SetSettingResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SetSettingResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetSettingResponse(const SetSettingResponse& from);
  SetSettingResponse(SetSettingResponse&& from) noexcept
    : SetSettingResponse() {
    *this = ::std::move(from);
  }

  inline SetSettingResponse& operator=(const SetSettingResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetSettingResponse& operator=(SetSettingResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetSettingResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetSettingResponse* internal_default_instance() {
    return reinterpret_cast<const SetSettingResponse*>(
               &_SetSettingResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(SetSettingResponse& a, SetSettingResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SetSettingResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetSettingResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetSettingResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetSettingResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetSettingResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetSettingResponse& from) {
    SetSettingResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetSettingResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mavsdk.rpc.camera.SetSettingResponse";
  }
  protected:
  explicit SetSettingResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCameraResultFieldNumber = 1,
  };
  // .mavsdk.rpc.camera.CameraResult camera_result = 1;
  bool has_camera_result() const;
  void clear_camera_result() ;
  const ::mavsdk::rpc::camera::CameraResult& camera_result() const;
  PROTOBUF_NODISCARD ::mavsdk::rpc::camera::CameraResult* release_camera_result();
  ::mavsdk::rpc::camera::CameraResult* mutable_camera_result();
  void set_allocated_camera_result(::mavsdk::rpc::camera::CameraResult* camera_result);
  private:
  const ::mavsdk::rpc::camera::CameraResult& _internal_camera_result() const;
  ::mavsdk::rpc::camera::CameraResult* _internal_mutable_camera_result();
  public:
  void unsafe_arena_set_allocated_camera_result(
      ::mavsdk::rpc::camera::CameraResult* camera_result);
  ::mavsdk::rpc::camera::CameraResult* unsafe_arena_release_camera_result();
  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera.SetSettingResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::mavsdk::rpc::camera::CameraResult* camera_result_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camera_2fcamera_2eproto;
};// -------------------------------------------------------------------

class GetSettingRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera.GetSettingRequest) */ {
 public:
  inline GetSettingRequest() : GetSettingRequest(nullptr) {}
  ~GetSettingRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetSettingRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetSettingRequest(const GetSettingRequest& from);
  GetSettingRequest(GetSettingRequest&& from) noexcept
    : GetSettingRequest() {
    *this = ::std::move(from);
  }

  inline GetSettingRequest& operator=(const GetSettingRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetSettingRequest& operator=(GetSettingRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetSettingRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetSettingRequest* internal_default_instance() {
    return reinterpret_cast<const GetSettingRequest*>(
               &_GetSettingRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(GetSettingRequest& a, GetSettingRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetSettingRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetSettingRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetSettingRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetSettingRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetSettingRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetSettingRequest& from) {
    GetSettingRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetSettingRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mavsdk.rpc.camera.GetSettingRequest";
  }
  protected:
  explicit GetSettingRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSettingFieldNumber = 1,
  };
  // .mavsdk.rpc.camera.Setting setting = 1;
  bool has_setting() const;
  void clear_setting() ;
  const ::mavsdk::rpc::camera::Setting& setting() const;
  PROTOBUF_NODISCARD ::mavsdk::rpc::camera::Setting* release_setting();
  ::mavsdk::rpc::camera::Setting* mutable_setting();
  void set_allocated_setting(::mavsdk::rpc::camera::Setting* setting);
  private:
  const ::mavsdk::rpc::camera::Setting& _internal_setting() const;
  ::mavsdk::rpc::camera::Setting* _internal_mutable_setting();
  public:
  void unsafe_arena_set_allocated_setting(
      ::mavsdk::rpc::camera::Setting* setting);
  ::mavsdk::rpc::camera::Setting* unsafe_arena_release_setting();
  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera.GetSettingRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::mavsdk::rpc::camera::Setting* setting_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camera_2fcamera_2eproto;
};// -------------------------------------------------------------------

class GetSettingResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera.GetSettingResponse) */ {
 public:
  inline GetSettingResponse() : GetSettingResponse(nullptr) {}
  ~GetSettingResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetSettingResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetSettingResponse(const GetSettingResponse& from);
  GetSettingResponse(GetSettingResponse&& from) noexcept
    : GetSettingResponse() {
    *this = ::std::move(from);
  }

  inline GetSettingResponse& operator=(const GetSettingResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetSettingResponse& operator=(GetSettingResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetSettingResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetSettingResponse* internal_default_instance() {
    return reinterpret_cast<const GetSettingResponse*>(
               &_GetSettingResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(GetSettingResponse& a, GetSettingResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetSettingResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetSettingResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetSettingResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetSettingResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetSettingResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetSettingResponse& from) {
    GetSettingResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetSettingResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mavsdk.rpc.camera.GetSettingResponse";
  }
  protected:
  explicit GetSettingResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCameraResultFieldNumber = 1,
    kSettingFieldNumber = 2,
  };
  // .mavsdk.rpc.camera.CameraResult camera_result = 1;
  bool has_camera_result() const;
  void clear_camera_result() ;
  const ::mavsdk::rpc::camera::CameraResult& camera_result() const;
  PROTOBUF_NODISCARD ::mavsdk::rpc::camera::CameraResult* release_camera_result();
  ::mavsdk::rpc::camera::CameraResult* mutable_camera_result();
  void set_allocated_camera_result(::mavsdk::rpc::camera::CameraResult* camera_result);
  private:
  const ::mavsdk::rpc::camera::CameraResult& _internal_camera_result() const;
  ::mavsdk::rpc::camera::CameraResult* _internal_mutable_camera_result();
  public:
  void unsafe_arena_set_allocated_camera_result(
      ::mavsdk::rpc::camera::CameraResult* camera_result);
  ::mavsdk::rpc::camera::CameraResult* unsafe_arena_release_camera_result();
  // .mavsdk.rpc.camera.Setting setting = 2;
  bool has_setting() const;
  void clear_setting() ;
  const ::mavsdk::rpc::camera::Setting& setting() const;
  PROTOBUF_NODISCARD ::mavsdk::rpc::camera::Setting* release_setting();
  ::mavsdk::rpc::camera::Setting* mutable_setting();
  void set_allocated_setting(::mavsdk::rpc::camera::Setting* setting);
  private:
  const ::mavsdk::rpc::camera::Setting& _internal_setting() const;
  ::mavsdk::rpc::camera::Setting* _internal_mutable_setting();
  public:
  void unsafe_arena_set_allocated_setting(
      ::mavsdk::rpc::camera::Setting* setting);
  ::mavsdk::rpc::camera::Setting* unsafe_arena_release_setting();
  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera.GetSettingResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::mavsdk::rpc::camera::CameraResult* camera_result_;
    ::mavsdk::rpc::camera::Setting* setting_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camera_2fcamera_2eproto;
};// -------------------------------------------------------------------

class FormatStorageRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera.FormatStorageRequest) */ {
 public:
  inline FormatStorageRequest() : FormatStorageRequest(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR FormatStorageRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FormatStorageRequest(const FormatStorageRequest& from);
  FormatStorageRequest(FormatStorageRequest&& from) noexcept
    : FormatStorageRequest() {
    *this = ::std::move(from);
  }

  inline FormatStorageRequest& operator=(const FormatStorageRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline FormatStorageRequest& operator=(FormatStorageRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FormatStorageRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const FormatStorageRequest* internal_default_instance() {
    return reinterpret_cast<const FormatStorageRequest*>(
               &_FormatStorageRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(FormatStorageRequest& a, FormatStorageRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(FormatStorageRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FormatStorageRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FormatStorageRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FormatStorageRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const FormatStorageRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const FormatStorageRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mavsdk.rpc.camera.FormatStorageRequest";
  }
  protected:
  explicit FormatStorageRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera.FormatStorageRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_camera_2fcamera_2eproto;
};// -------------------------------------------------------------------

class FormatStorageResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera.FormatStorageResponse) */ {
 public:
  inline FormatStorageResponse() : FormatStorageResponse(nullptr) {}
  ~FormatStorageResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR FormatStorageResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FormatStorageResponse(const FormatStorageResponse& from);
  FormatStorageResponse(FormatStorageResponse&& from) noexcept
    : FormatStorageResponse() {
    *this = ::std::move(from);
  }

  inline FormatStorageResponse& operator=(const FormatStorageResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline FormatStorageResponse& operator=(FormatStorageResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FormatStorageResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const FormatStorageResponse* internal_default_instance() {
    return reinterpret_cast<const FormatStorageResponse*>(
               &_FormatStorageResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(FormatStorageResponse& a, FormatStorageResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(FormatStorageResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FormatStorageResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FormatStorageResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FormatStorageResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FormatStorageResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FormatStorageResponse& from) {
    FormatStorageResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FormatStorageResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mavsdk.rpc.camera.FormatStorageResponse";
  }
  protected:
  explicit FormatStorageResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCameraResultFieldNumber = 1,
  };
  // .mavsdk.rpc.camera.CameraResult camera_result = 1;
  bool has_camera_result() const;
  void clear_camera_result() ;
  const ::mavsdk::rpc::camera::CameraResult& camera_result() const;
  PROTOBUF_NODISCARD ::mavsdk::rpc::camera::CameraResult* release_camera_result();
  ::mavsdk::rpc::camera::CameraResult* mutable_camera_result();
  void set_allocated_camera_result(::mavsdk::rpc::camera::CameraResult* camera_result);
  private:
  const ::mavsdk::rpc::camera::CameraResult& _internal_camera_result() const;
  ::mavsdk::rpc::camera::CameraResult* _internal_mutable_camera_result();
  public:
  void unsafe_arena_set_allocated_camera_result(
      ::mavsdk::rpc::camera::CameraResult* camera_result);
  ::mavsdk::rpc::camera::CameraResult* unsafe_arena_release_camera_result();
  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera.FormatStorageResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::mavsdk::rpc::camera::CameraResult* camera_result_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camera_2fcamera_2eproto;
};// -------------------------------------------------------------------

class SelectCameraResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera.SelectCameraResponse) */ {
 public:
  inline SelectCameraResponse() : SelectCameraResponse(nullptr) {}
  ~SelectCameraResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SelectCameraResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SelectCameraResponse(const SelectCameraResponse& from);
  SelectCameraResponse(SelectCameraResponse&& from) noexcept
    : SelectCameraResponse() {
    *this = ::std::move(from);
  }

  inline SelectCameraResponse& operator=(const SelectCameraResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SelectCameraResponse& operator=(SelectCameraResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SelectCameraResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SelectCameraResponse* internal_default_instance() {
    return reinterpret_cast<const SelectCameraResponse*>(
               &_SelectCameraResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(SelectCameraResponse& a, SelectCameraResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SelectCameraResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SelectCameraResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SelectCameraResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SelectCameraResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SelectCameraResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SelectCameraResponse& from) {
    SelectCameraResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SelectCameraResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mavsdk.rpc.camera.SelectCameraResponse";
  }
  protected:
  explicit SelectCameraResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCameraResultFieldNumber = 1,
  };
  // .mavsdk.rpc.camera.CameraResult camera_result = 1;
  bool has_camera_result() const;
  void clear_camera_result() ;
  const ::mavsdk::rpc::camera::CameraResult& camera_result() const;
  PROTOBUF_NODISCARD ::mavsdk::rpc::camera::CameraResult* release_camera_result();
  ::mavsdk::rpc::camera::CameraResult* mutable_camera_result();
  void set_allocated_camera_result(::mavsdk::rpc::camera::CameraResult* camera_result);
  private:
  const ::mavsdk::rpc::camera::CameraResult& _internal_camera_result() const;
  ::mavsdk::rpc::camera::CameraResult* _internal_mutable_camera_result();
  public:
  void unsafe_arena_set_allocated_camera_result(
      ::mavsdk::rpc::camera::CameraResult* camera_result);
  ::mavsdk::rpc::camera::CameraResult* unsafe_arena_release_camera_result();
  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera.SelectCameraResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::mavsdk::rpc::camera::CameraResult* camera_result_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camera_2fcamera_2eproto;
};// -------------------------------------------------------------------

class SelectCameraRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera.SelectCameraRequest) */ {
 public:
  inline SelectCameraRequest() : SelectCameraRequest(nullptr) {}
  ~SelectCameraRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SelectCameraRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SelectCameraRequest(const SelectCameraRequest& from);
  SelectCameraRequest(SelectCameraRequest&& from) noexcept
    : SelectCameraRequest() {
    *this = ::std::move(from);
  }

  inline SelectCameraRequest& operator=(const SelectCameraRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SelectCameraRequest& operator=(SelectCameraRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SelectCameraRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SelectCameraRequest* internal_default_instance() {
    return reinterpret_cast<const SelectCameraRequest*>(
               &_SelectCameraRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(SelectCameraRequest& a, SelectCameraRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SelectCameraRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SelectCameraRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SelectCameraRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SelectCameraRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SelectCameraRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SelectCameraRequest& from) {
    SelectCameraRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SelectCameraRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mavsdk.rpc.camera.SelectCameraRequest";
  }
  protected:
  explicit SelectCameraRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCameraIdFieldNumber = 1,
  };
  // int32 camera_id = 1;
  void clear_camera_id() ;
  ::int32_t camera_id() const;
  void set_camera_id(::int32_t value);

  private:
  ::int32_t _internal_camera_id() const;
  void _internal_set_camera_id(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera.SelectCameraRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::int32_t camera_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camera_2fcamera_2eproto;
};// -------------------------------------------------------------------

class CameraResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera.CameraResult) */ {
 public:
  inline CameraResult() : CameraResult(nullptr) {}
  ~CameraResult() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CameraResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CameraResult(const CameraResult& from);
  CameraResult(CameraResult&& from) noexcept
    : CameraResult() {
    *this = ::std::move(from);
  }

  inline CameraResult& operator=(const CameraResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline CameraResult& operator=(CameraResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CameraResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const CameraResult* internal_default_instance() {
    return reinterpret_cast<const CameraResult*>(
               &_CameraResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(CameraResult& a, CameraResult& b) {
    a.Swap(&b);
  }
  inline void Swap(CameraResult* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CameraResult* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CameraResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CameraResult>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CameraResult& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CameraResult& from) {
    CameraResult::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CameraResult* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mavsdk.rpc.camera.CameraResult";
  }
  protected:
  explicit CameraResult(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Result = CameraResult_Result;
  static constexpr Result RESULT_UNKNOWN = CameraResult_Result_RESULT_UNKNOWN;
  static constexpr Result RESULT_SUCCESS = CameraResult_Result_RESULT_SUCCESS;
  static constexpr Result RESULT_IN_PROGRESS = CameraResult_Result_RESULT_IN_PROGRESS;
  static constexpr Result RESULT_BUSY = CameraResult_Result_RESULT_BUSY;
  static constexpr Result RESULT_DENIED = CameraResult_Result_RESULT_DENIED;
  static constexpr Result RESULT_ERROR = CameraResult_Result_RESULT_ERROR;
  static constexpr Result RESULT_TIMEOUT = CameraResult_Result_RESULT_TIMEOUT;
  static constexpr Result RESULT_WRONG_ARGUMENT = CameraResult_Result_RESULT_WRONG_ARGUMENT;
  static constexpr Result RESULT_NO_SYSTEM = CameraResult_Result_RESULT_NO_SYSTEM;
  static constexpr Result RESULT_PROTOCOL_UNSUPPORTED = CameraResult_Result_RESULT_PROTOCOL_UNSUPPORTED;
  static inline bool Result_IsValid(int value) {
    return CameraResult_Result_IsValid(value);
  }
  static constexpr Result Result_MIN = CameraResult_Result_Result_MIN;
  static constexpr Result Result_MAX = CameraResult_Result_Result_MAX;
  static constexpr int Result_ARRAYSIZE = CameraResult_Result_Result_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Result_descriptor() {
    return CameraResult_Result_descriptor();
  }
  template <typename T>
  static inline const std::string& Result_Name(T value) {
    return CameraResult_Result_Name(value);
  }
  static inline bool Result_Parse(absl::string_view name, Result* value) {
    return CameraResult_Result_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kResultStrFieldNumber = 2,
    kResultFieldNumber = 1,
  };
  // string result_str = 2;
  void clear_result_str() ;
  const std::string& result_str() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_result_str(Arg_&& arg, Args_... args);
  std::string* mutable_result_str();
  PROTOBUF_NODISCARD std::string* release_result_str();
  void set_allocated_result_str(std::string* ptr);

  private:
  const std::string& _internal_result_str() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_result_str(
      const std::string& value);
  std::string* _internal_mutable_result_str();

  public:
  // .mavsdk.rpc.camera.CameraResult.Result result = 1;
  void clear_result() ;
  ::mavsdk::rpc::camera::CameraResult_Result result() const;
  void set_result(::mavsdk::rpc::camera::CameraResult_Result value);

  private:
  ::mavsdk::rpc::camera::CameraResult_Result _internal_result() const;
  void _internal_set_result(::mavsdk::rpc::camera::CameraResult_Result value);

  public:
  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera.CameraResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr result_str_;
    int result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camera_2fcamera_2eproto;
};// -------------------------------------------------------------------

class Position final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera.Position) */ {
 public:
  inline Position() : Position(nullptr) {}
  ~Position() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Position(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Position(const Position& from);
  Position(Position&& from) noexcept
    : Position() {
    *this = ::std::move(from);
  }

  inline Position& operator=(const Position& from) {
    CopyFrom(from);
    return *this;
  }
  inline Position& operator=(Position&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Position& default_instance() {
    return *internal_default_instance();
  }
  static inline const Position* internal_default_instance() {
    return reinterpret_cast<const Position*>(
               &_Position_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(Position& a, Position& b) {
    a.Swap(&b);
  }
  inline void Swap(Position* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Position* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Position* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Position>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Position& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Position& from) {
    Position::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Position* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mavsdk.rpc.camera.Position";
  }
  protected:
  explicit Position(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLatitudeDegFieldNumber = 1,
    kLongitudeDegFieldNumber = 2,
    kAbsoluteAltitudeMFieldNumber = 3,
    kRelativeAltitudeMFieldNumber = 4,
  };
  // double latitude_deg = 1;
  void clear_latitude_deg() ;
  double latitude_deg() const;
  void set_latitude_deg(double value);

  private:
  double _internal_latitude_deg() const;
  void _internal_set_latitude_deg(double value);

  public:
  // double longitude_deg = 2;
  void clear_longitude_deg() ;
  double longitude_deg() const;
  void set_longitude_deg(double value);

  private:
  double _internal_longitude_deg() const;
  void _internal_set_longitude_deg(double value);

  public:
  // float absolute_altitude_m = 3;
  void clear_absolute_altitude_m() ;
  float absolute_altitude_m() const;
  void set_absolute_altitude_m(float value);

  private:
  float _internal_absolute_altitude_m() const;
  void _internal_set_absolute_altitude_m(float value);

  public:
  // float relative_altitude_m = 4;
  void clear_relative_altitude_m() ;
  float relative_altitude_m() const;
  void set_relative_altitude_m(float value);

  private:
  float _internal_relative_altitude_m() const;
  void _internal_set_relative_altitude_m(float value);

  public:
  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera.Position)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    double latitude_deg_;
    double longitude_deg_;
    float absolute_altitude_m_;
    float relative_altitude_m_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camera_2fcamera_2eproto;
};// -------------------------------------------------------------------

class Quaternion final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera.Quaternion) */ {
 public:
  inline Quaternion() : Quaternion(nullptr) {}
  ~Quaternion() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Quaternion(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Quaternion(const Quaternion& from);
  Quaternion(Quaternion&& from) noexcept
    : Quaternion() {
    *this = ::std::move(from);
  }

  inline Quaternion& operator=(const Quaternion& from) {
    CopyFrom(from);
    return *this;
  }
  inline Quaternion& operator=(Quaternion&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Quaternion& default_instance() {
    return *internal_default_instance();
  }
  static inline const Quaternion* internal_default_instance() {
    return reinterpret_cast<const Quaternion*>(
               &_Quaternion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(Quaternion& a, Quaternion& b) {
    a.Swap(&b);
  }
  inline void Swap(Quaternion* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Quaternion* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Quaternion* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Quaternion>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Quaternion& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Quaternion& from) {
    Quaternion::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Quaternion* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mavsdk.rpc.camera.Quaternion";
  }
  protected:
  explicit Quaternion(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWFieldNumber = 1,
    kXFieldNumber = 2,
    kYFieldNumber = 3,
    kZFieldNumber = 4,
  };
  // float w = 1;
  void clear_w() ;
  float w() const;
  void set_w(float value);

  private:
  float _internal_w() const;
  void _internal_set_w(float value);

  public:
  // float x = 2;
  void clear_x() ;
  float x() const;
  void set_x(float value);

  private:
  float _internal_x() const;
  void _internal_set_x(float value);

  public:
  // float y = 3;
  void clear_y() ;
  float y() const;
  void set_y(float value);

  private:
  float _internal_y() const;
  void _internal_set_y(float value);

  public:
  // float z = 4;
  void clear_z() ;
  float z() const;
  void set_z(float value);

  private:
  float _internal_z() const;
  void _internal_set_z(float value);

  public:
  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera.Quaternion)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float w_;
    float x_;
    float y_;
    float z_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camera_2fcamera_2eproto;
};// -------------------------------------------------------------------

class EulerAngle final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera.EulerAngle) */ {
 public:
  inline EulerAngle() : EulerAngle(nullptr) {}
  ~EulerAngle() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EulerAngle(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EulerAngle(const EulerAngle& from);
  EulerAngle(EulerAngle&& from) noexcept
    : EulerAngle() {
    *this = ::std::move(from);
  }

  inline EulerAngle& operator=(const EulerAngle& from) {
    CopyFrom(from);
    return *this;
  }
  inline EulerAngle& operator=(EulerAngle&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EulerAngle& default_instance() {
    return *internal_default_instance();
  }
  static inline const EulerAngle* internal_default_instance() {
    return reinterpret_cast<const EulerAngle*>(
               &_EulerAngle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(EulerAngle& a, EulerAngle& b) {
    a.Swap(&b);
  }
  inline void Swap(EulerAngle* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EulerAngle* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EulerAngle* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EulerAngle>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EulerAngle& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EulerAngle& from) {
    EulerAngle::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EulerAngle* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mavsdk.rpc.camera.EulerAngle";
  }
  protected:
  explicit EulerAngle(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRollDegFieldNumber = 1,
    kPitchDegFieldNumber = 2,
    kYawDegFieldNumber = 3,
  };
  // float roll_deg = 1;
  void clear_roll_deg() ;
  float roll_deg() const;
  void set_roll_deg(float value);

  private:
  float _internal_roll_deg() const;
  void _internal_set_roll_deg(float value);

  public:
  // float pitch_deg = 2;
  void clear_pitch_deg() ;
  float pitch_deg() const;
  void set_pitch_deg(float value);

  private:
  float _internal_pitch_deg() const;
  void _internal_set_pitch_deg(float value);

  public:
  // float yaw_deg = 3;
  void clear_yaw_deg() ;
  float yaw_deg() const;
  void set_yaw_deg(float value);

  private:
  float _internal_yaw_deg() const;
  void _internal_set_yaw_deg(float value);

  public:
  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera.EulerAngle)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float roll_deg_;
    float pitch_deg_;
    float yaw_deg_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camera_2fcamera_2eproto;
};// -------------------------------------------------------------------

class CaptureInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera.CaptureInfo) */ {
 public:
  inline CaptureInfo() : CaptureInfo(nullptr) {}
  ~CaptureInfo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CaptureInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CaptureInfo(const CaptureInfo& from);
  CaptureInfo(CaptureInfo&& from) noexcept
    : CaptureInfo() {
    *this = ::std::move(from);
  }

  inline CaptureInfo& operator=(const CaptureInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline CaptureInfo& operator=(CaptureInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CaptureInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const CaptureInfo* internal_default_instance() {
    return reinterpret_cast<const CaptureInfo*>(
               &_CaptureInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  friend void swap(CaptureInfo& a, CaptureInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(CaptureInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CaptureInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CaptureInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CaptureInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CaptureInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CaptureInfo& from) {
    CaptureInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CaptureInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mavsdk.rpc.camera.CaptureInfo";
  }
  protected:
  explicit CaptureInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFileUrlFieldNumber = 7,
    kPositionFieldNumber = 1,
    kAttitudeQuaternionFieldNumber = 2,
    kAttitudeEulerAngleFieldNumber = 3,
    kTimeUtcUsFieldNumber = 4,
    kIsSuccessFieldNumber = 5,
    kIndexFieldNumber = 6,
  };
  // string file_url = 7;
  void clear_file_url() ;
  const std::string& file_url() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_file_url(Arg_&& arg, Args_... args);
  std::string* mutable_file_url();
  PROTOBUF_NODISCARD std::string* release_file_url();
  void set_allocated_file_url(std::string* ptr);

  private:
  const std::string& _internal_file_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_url(
      const std::string& value);
  std::string* _internal_mutable_file_url();

  public:
  // .mavsdk.rpc.camera.Position position = 1;
  bool has_position() const;
  void clear_position() ;
  const ::mavsdk::rpc::camera::Position& position() const;
  PROTOBUF_NODISCARD ::mavsdk::rpc::camera::Position* release_position();
  ::mavsdk::rpc::camera::Position* mutable_position();
  void set_allocated_position(::mavsdk::rpc::camera::Position* position);
  private:
  const ::mavsdk::rpc::camera::Position& _internal_position() const;
  ::mavsdk::rpc::camera::Position* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::mavsdk::rpc::camera::Position* position);
  ::mavsdk::rpc::camera::Position* unsafe_arena_release_position();
  // .mavsdk.rpc.camera.Quaternion attitude_quaternion = 2;
  bool has_attitude_quaternion() const;
  void clear_attitude_quaternion() ;
  const ::mavsdk::rpc::camera::Quaternion& attitude_quaternion() const;
  PROTOBUF_NODISCARD ::mavsdk::rpc::camera::Quaternion* release_attitude_quaternion();
  ::mavsdk::rpc::camera::Quaternion* mutable_attitude_quaternion();
  void set_allocated_attitude_quaternion(::mavsdk::rpc::camera::Quaternion* attitude_quaternion);
  private:
  const ::mavsdk::rpc::camera::Quaternion& _internal_attitude_quaternion() const;
  ::mavsdk::rpc::camera::Quaternion* _internal_mutable_attitude_quaternion();
  public:
  void unsafe_arena_set_allocated_attitude_quaternion(
      ::mavsdk::rpc::camera::Quaternion* attitude_quaternion);
  ::mavsdk::rpc::camera::Quaternion* unsafe_arena_release_attitude_quaternion();
  // .mavsdk.rpc.camera.EulerAngle attitude_euler_angle = 3;
  bool has_attitude_euler_angle() const;
  void clear_attitude_euler_angle() ;
  const ::mavsdk::rpc::camera::EulerAngle& attitude_euler_angle() const;
  PROTOBUF_NODISCARD ::mavsdk::rpc::camera::EulerAngle* release_attitude_euler_angle();
  ::mavsdk::rpc::camera::EulerAngle* mutable_attitude_euler_angle();
  void set_allocated_attitude_euler_angle(::mavsdk::rpc::camera::EulerAngle* attitude_euler_angle);
  private:
  const ::mavsdk::rpc::camera::EulerAngle& _internal_attitude_euler_angle() const;
  ::mavsdk::rpc::camera::EulerAngle* _internal_mutable_attitude_euler_angle();
  public:
  void unsafe_arena_set_allocated_attitude_euler_angle(
      ::mavsdk::rpc::camera::EulerAngle* attitude_euler_angle);
  ::mavsdk::rpc::camera::EulerAngle* unsafe_arena_release_attitude_euler_angle();
  // uint64 time_utc_us = 4;
  void clear_time_utc_us() ;
  ::uint64_t time_utc_us() const;
  void set_time_utc_us(::uint64_t value);

  private:
  ::uint64_t _internal_time_utc_us() const;
  void _internal_set_time_utc_us(::uint64_t value);

  public:
  // bool is_success = 5;
  void clear_is_success() ;
  bool is_success() const;
  void set_is_success(bool value);

  private:
  bool _internal_is_success() const;
  void _internal_set_is_success(bool value);

  public:
  // int32 index = 6;
  void clear_index() ;
  ::int32_t index() const;
  void set_index(::int32_t value);

  private:
  ::int32_t _internal_index() const;
  void _internal_set_index(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera.CaptureInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_url_;
    ::mavsdk::rpc::camera::Position* position_;
    ::mavsdk::rpc::camera::Quaternion* attitude_quaternion_;
    ::mavsdk::rpc::camera::EulerAngle* attitude_euler_angle_;
    ::uint64_t time_utc_us_;
    bool is_success_;
    ::int32_t index_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camera_2fcamera_2eproto;
};// -------------------------------------------------------------------

class VideoStreamSettings final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera.VideoStreamSettings) */ {
 public:
  inline VideoStreamSettings() : VideoStreamSettings(nullptr) {}
  ~VideoStreamSettings() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR VideoStreamSettings(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VideoStreamSettings(const VideoStreamSettings& from);
  VideoStreamSettings(VideoStreamSettings&& from) noexcept
    : VideoStreamSettings() {
    *this = ::std::move(from);
  }

  inline VideoStreamSettings& operator=(const VideoStreamSettings& from) {
    CopyFrom(from);
    return *this;
  }
  inline VideoStreamSettings& operator=(VideoStreamSettings&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VideoStreamSettings& default_instance() {
    return *internal_default_instance();
  }
  static inline const VideoStreamSettings* internal_default_instance() {
    return reinterpret_cast<const VideoStreamSettings*>(
               &_VideoStreamSettings_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  friend void swap(VideoStreamSettings& a, VideoStreamSettings& b) {
    a.Swap(&b);
  }
  inline void Swap(VideoStreamSettings* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VideoStreamSettings* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VideoStreamSettings* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VideoStreamSettings>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VideoStreamSettings& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VideoStreamSettings& from) {
    VideoStreamSettings::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VideoStreamSettings* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mavsdk.rpc.camera.VideoStreamSettings";
  }
  protected:
  explicit VideoStreamSettings(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUriFieldNumber = 6,
    kFrameRateHzFieldNumber = 1,
    kHorizontalResolutionPixFieldNumber = 2,
    kVerticalResolutionPixFieldNumber = 3,
    kBitRateBSFieldNumber = 4,
    kRotationDegFieldNumber = 5,
    kHorizontalFovDegFieldNumber = 7,
  };
  // string uri = 6;
  void clear_uri() ;
  const std::string& uri() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_uri(Arg_&& arg, Args_... args);
  std::string* mutable_uri();
  PROTOBUF_NODISCARD std::string* release_uri();
  void set_allocated_uri(std::string* ptr);

  private:
  const std::string& _internal_uri() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uri(
      const std::string& value);
  std::string* _internal_mutable_uri();

  public:
  // float frame_rate_hz = 1;
  void clear_frame_rate_hz() ;
  float frame_rate_hz() const;
  void set_frame_rate_hz(float value);

  private:
  float _internal_frame_rate_hz() const;
  void _internal_set_frame_rate_hz(float value);

  public:
  // uint32 horizontal_resolution_pix = 2;
  void clear_horizontal_resolution_pix() ;
  ::uint32_t horizontal_resolution_pix() const;
  void set_horizontal_resolution_pix(::uint32_t value);

  private:
  ::uint32_t _internal_horizontal_resolution_pix() const;
  void _internal_set_horizontal_resolution_pix(::uint32_t value);

  public:
  // uint32 vertical_resolution_pix = 3;
  void clear_vertical_resolution_pix() ;
  ::uint32_t vertical_resolution_pix() const;
  void set_vertical_resolution_pix(::uint32_t value);

  private:
  ::uint32_t _internal_vertical_resolution_pix() const;
  void _internal_set_vertical_resolution_pix(::uint32_t value);

  public:
  // uint32 bit_rate_b_s = 4;
  void clear_bit_rate_b_s() ;
  ::uint32_t bit_rate_b_s() const;
  void set_bit_rate_b_s(::uint32_t value);

  private:
  ::uint32_t _internal_bit_rate_b_s() const;
  void _internal_set_bit_rate_b_s(::uint32_t value);

  public:
  // uint32 rotation_deg = 5;
  void clear_rotation_deg() ;
  ::uint32_t rotation_deg() const;
  void set_rotation_deg(::uint32_t value);

  private:
  ::uint32_t _internal_rotation_deg() const;
  void _internal_set_rotation_deg(::uint32_t value);

  public:
  // float horizontal_fov_deg = 7;
  void clear_horizontal_fov_deg() ;
  float horizontal_fov_deg() const;
  void set_horizontal_fov_deg(float value);

  private:
  float _internal_horizontal_fov_deg() const;
  void _internal_set_horizontal_fov_deg(float value);

  public:
  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera.VideoStreamSettings)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uri_;
    float frame_rate_hz_;
    ::uint32_t horizontal_resolution_pix_;
    ::uint32_t vertical_resolution_pix_;
    ::uint32_t bit_rate_b_s_;
    ::uint32_t rotation_deg_;
    float horizontal_fov_deg_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camera_2fcamera_2eproto;
};// -------------------------------------------------------------------

class VideoStreamInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera.VideoStreamInfo) */ {
 public:
  inline VideoStreamInfo() : VideoStreamInfo(nullptr) {}
  ~VideoStreamInfo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR VideoStreamInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VideoStreamInfo(const VideoStreamInfo& from);
  VideoStreamInfo(VideoStreamInfo&& from) noexcept
    : VideoStreamInfo() {
    *this = ::std::move(from);
  }

  inline VideoStreamInfo& operator=(const VideoStreamInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline VideoStreamInfo& operator=(VideoStreamInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VideoStreamInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const VideoStreamInfo* internal_default_instance() {
    return reinterpret_cast<const VideoStreamInfo*>(
               &_VideoStreamInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  friend void swap(VideoStreamInfo& a, VideoStreamInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(VideoStreamInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VideoStreamInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VideoStreamInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VideoStreamInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VideoStreamInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VideoStreamInfo& from) {
    VideoStreamInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VideoStreamInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mavsdk.rpc.camera.VideoStreamInfo";
  }
  protected:
  explicit VideoStreamInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using VideoStreamStatus = VideoStreamInfo_VideoStreamStatus;
  static constexpr VideoStreamStatus VIDEO_STREAM_STATUS_NOT_RUNNING = VideoStreamInfo_VideoStreamStatus_VIDEO_STREAM_STATUS_NOT_RUNNING;
  static constexpr VideoStreamStatus VIDEO_STREAM_STATUS_IN_PROGRESS = VideoStreamInfo_VideoStreamStatus_VIDEO_STREAM_STATUS_IN_PROGRESS;
  static inline bool VideoStreamStatus_IsValid(int value) {
    return VideoStreamInfo_VideoStreamStatus_IsValid(value);
  }
  static constexpr VideoStreamStatus VideoStreamStatus_MIN = VideoStreamInfo_VideoStreamStatus_VideoStreamStatus_MIN;
  static constexpr VideoStreamStatus VideoStreamStatus_MAX = VideoStreamInfo_VideoStreamStatus_VideoStreamStatus_MAX;
  static constexpr int VideoStreamStatus_ARRAYSIZE = VideoStreamInfo_VideoStreamStatus_VideoStreamStatus_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* VideoStreamStatus_descriptor() {
    return VideoStreamInfo_VideoStreamStatus_descriptor();
  }
  template <typename T>
  static inline const std::string& VideoStreamStatus_Name(T value) {
    return VideoStreamInfo_VideoStreamStatus_Name(value);
  }
  static inline bool VideoStreamStatus_Parse(absl::string_view name, VideoStreamStatus* value) {
    return VideoStreamInfo_VideoStreamStatus_Parse(name, value);
  }

  using VideoStreamSpectrum = VideoStreamInfo_VideoStreamSpectrum;
  static constexpr VideoStreamSpectrum VIDEO_STREAM_SPECTRUM_UNKNOWN = VideoStreamInfo_VideoStreamSpectrum_VIDEO_STREAM_SPECTRUM_UNKNOWN;
  static constexpr VideoStreamSpectrum VIDEO_STREAM_SPECTRUM_VISIBLE_LIGHT = VideoStreamInfo_VideoStreamSpectrum_VIDEO_STREAM_SPECTRUM_VISIBLE_LIGHT;
  static constexpr VideoStreamSpectrum VIDEO_STREAM_SPECTRUM_INFRARED = VideoStreamInfo_VideoStreamSpectrum_VIDEO_STREAM_SPECTRUM_INFRARED;
  static inline bool VideoStreamSpectrum_IsValid(int value) {
    return VideoStreamInfo_VideoStreamSpectrum_IsValid(value);
  }
  static constexpr VideoStreamSpectrum VideoStreamSpectrum_MIN = VideoStreamInfo_VideoStreamSpectrum_VideoStreamSpectrum_MIN;
  static constexpr VideoStreamSpectrum VideoStreamSpectrum_MAX = VideoStreamInfo_VideoStreamSpectrum_VideoStreamSpectrum_MAX;
  static constexpr int VideoStreamSpectrum_ARRAYSIZE = VideoStreamInfo_VideoStreamSpectrum_VideoStreamSpectrum_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* VideoStreamSpectrum_descriptor() {
    return VideoStreamInfo_VideoStreamSpectrum_descriptor();
  }
  template <typename T>
  static inline const std::string& VideoStreamSpectrum_Name(T value) {
    return VideoStreamInfo_VideoStreamSpectrum_Name(value);
  }
  static inline bool VideoStreamSpectrum_Parse(absl::string_view name, VideoStreamSpectrum* value) {
    return VideoStreamInfo_VideoStreamSpectrum_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kSettingsFieldNumber = 1,
    kStatusFieldNumber = 2,
    kSpectrumFieldNumber = 3,
  };
  // .mavsdk.rpc.camera.VideoStreamSettings settings = 1;
  bool has_settings() const;
  void clear_settings() ;
  const ::mavsdk::rpc::camera::VideoStreamSettings& settings() const;
  PROTOBUF_NODISCARD ::mavsdk::rpc::camera::VideoStreamSettings* release_settings();
  ::mavsdk::rpc::camera::VideoStreamSettings* mutable_settings();
  void set_allocated_settings(::mavsdk::rpc::camera::VideoStreamSettings* settings);
  private:
  const ::mavsdk::rpc::camera::VideoStreamSettings& _internal_settings() const;
  ::mavsdk::rpc::camera::VideoStreamSettings* _internal_mutable_settings();
  public:
  void unsafe_arena_set_allocated_settings(
      ::mavsdk::rpc::camera::VideoStreamSettings* settings);
  ::mavsdk::rpc::camera::VideoStreamSettings* unsafe_arena_release_settings();
  // .mavsdk.rpc.camera.VideoStreamInfo.VideoStreamStatus status = 2;
  void clear_status() ;
  ::mavsdk::rpc::camera::VideoStreamInfo_VideoStreamStatus status() const;
  void set_status(::mavsdk::rpc::camera::VideoStreamInfo_VideoStreamStatus value);

  private:
  ::mavsdk::rpc::camera::VideoStreamInfo_VideoStreamStatus _internal_status() const;
  void _internal_set_status(::mavsdk::rpc::camera::VideoStreamInfo_VideoStreamStatus value);

  public:
  // .mavsdk.rpc.camera.VideoStreamInfo.VideoStreamSpectrum spectrum = 3;
  void clear_spectrum() ;
  ::mavsdk::rpc::camera::VideoStreamInfo_VideoStreamSpectrum spectrum() const;
  void set_spectrum(::mavsdk::rpc::camera::VideoStreamInfo_VideoStreamSpectrum value);

  private:
  ::mavsdk::rpc::camera::VideoStreamInfo_VideoStreamSpectrum _internal_spectrum() const;
  void _internal_set_spectrum(::mavsdk::rpc::camera::VideoStreamInfo_VideoStreamSpectrum value);

  public:
  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera.VideoStreamInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::mavsdk::rpc::camera::VideoStreamSettings* settings_;
    int status_;
    int spectrum_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camera_2fcamera_2eproto;
};// -------------------------------------------------------------------

class Status final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera.Status) */ {
 public:
  inline Status() : Status(nullptr) {}
  ~Status() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Status(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Status(const Status& from);
  Status(Status&& from) noexcept
    : Status() {
    *this = ::std::move(from);
  }

  inline Status& operator=(const Status& from) {
    CopyFrom(from);
    return *this;
  }
  inline Status& operator=(Status&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Status& default_instance() {
    return *internal_default_instance();
  }
  static inline const Status* internal_default_instance() {
    return reinterpret_cast<const Status*>(
               &_Status_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    49;

  friend void swap(Status& a, Status& b) {
    a.Swap(&b);
  }
  inline void Swap(Status* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Status* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Status* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Status>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Status& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Status& from) {
    Status::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Status* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mavsdk.rpc.camera.Status";
  }
  protected:
  explicit Status(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using StorageStatus = Status_StorageStatus;
  static constexpr StorageStatus STORAGE_STATUS_NOT_AVAILABLE = Status_StorageStatus_STORAGE_STATUS_NOT_AVAILABLE;
  static constexpr StorageStatus STORAGE_STATUS_UNFORMATTED = Status_StorageStatus_STORAGE_STATUS_UNFORMATTED;
  static constexpr StorageStatus STORAGE_STATUS_FORMATTED = Status_StorageStatus_STORAGE_STATUS_FORMATTED;
  static constexpr StorageStatus STORAGE_STATUS_NOT_SUPPORTED = Status_StorageStatus_STORAGE_STATUS_NOT_SUPPORTED;
  static inline bool StorageStatus_IsValid(int value) {
    return Status_StorageStatus_IsValid(value);
  }
  static constexpr StorageStatus StorageStatus_MIN = Status_StorageStatus_StorageStatus_MIN;
  static constexpr StorageStatus StorageStatus_MAX = Status_StorageStatus_StorageStatus_MAX;
  static constexpr int StorageStatus_ARRAYSIZE = Status_StorageStatus_StorageStatus_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* StorageStatus_descriptor() {
    return Status_StorageStatus_descriptor();
  }
  template <typename T>
  static inline const std::string& StorageStatus_Name(T value) {
    return Status_StorageStatus_Name(value);
  }
  static inline bool StorageStatus_Parse(absl::string_view name, StorageStatus* value) {
    return Status_StorageStatus_Parse(name, value);
  }

  using StorageType = Status_StorageType;
  static constexpr StorageType STORAGE_TYPE_UNKNOWN = Status_StorageType_STORAGE_TYPE_UNKNOWN;
  static constexpr StorageType STORAGE_TYPE_USB_STICK = Status_StorageType_STORAGE_TYPE_USB_STICK;
  static constexpr StorageType STORAGE_TYPE_SD = Status_StorageType_STORAGE_TYPE_SD;
  static constexpr StorageType STORAGE_TYPE_MICROSD = Status_StorageType_STORAGE_TYPE_MICROSD;
  static constexpr StorageType STORAGE_TYPE_HD = Status_StorageType_STORAGE_TYPE_HD;
  static constexpr StorageType STORAGE_TYPE_OTHER = Status_StorageType_STORAGE_TYPE_OTHER;
  static inline bool StorageType_IsValid(int value) {
    return Status_StorageType_IsValid(value);
  }
  static constexpr StorageType StorageType_MIN = Status_StorageType_StorageType_MIN;
  static constexpr StorageType StorageType_MAX = Status_StorageType_StorageType_MAX;
  static constexpr int StorageType_ARRAYSIZE = Status_StorageType_StorageType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* StorageType_descriptor() {
    return Status_StorageType_descriptor();
  }
  template <typename T>
  static inline const std::string& StorageType_Name(T value) {
    return Status_StorageType_Name(value);
  }
  static inline bool StorageType_Parse(absl::string_view name, StorageType* value) {
    return Status_StorageType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kMediaFolderNameFieldNumber = 7,
    kVideoOnFieldNumber = 1,
    kPhotoIntervalOnFieldNumber = 2,
    kUsedStorageMibFieldNumber = 3,
    kAvailableStorageMibFieldNumber = 4,
    kTotalStorageMibFieldNumber = 5,
    kRecordingTimeSFieldNumber = 6,
    kStorageStatusFieldNumber = 8,
    kStorageIdFieldNumber = 9,
    kStorageTypeFieldNumber = 10,
  };
  // string media_folder_name = 7;
  void clear_media_folder_name() ;
  const std::string& media_folder_name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_media_folder_name(Arg_&& arg, Args_... args);
  std::string* mutable_media_folder_name();
  PROTOBUF_NODISCARD std::string* release_media_folder_name();
  void set_allocated_media_folder_name(std::string* ptr);

  private:
  const std::string& _internal_media_folder_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_media_folder_name(
      const std::string& value);
  std::string* _internal_mutable_media_folder_name();

  public:
  // bool video_on = 1;
  void clear_video_on() ;
  bool video_on() const;
  void set_video_on(bool value);

  private:
  bool _internal_video_on() const;
  void _internal_set_video_on(bool value);

  public:
  // bool photo_interval_on = 2;
  void clear_photo_interval_on() ;
  bool photo_interval_on() const;
  void set_photo_interval_on(bool value);

  private:
  bool _internal_photo_interval_on() const;
  void _internal_set_photo_interval_on(bool value);

  public:
  // float used_storage_mib = 3;
  void clear_used_storage_mib() ;
  float used_storage_mib() const;
  void set_used_storage_mib(float value);

  private:
  float _internal_used_storage_mib() const;
  void _internal_set_used_storage_mib(float value);

  public:
  // float available_storage_mib = 4;
  void clear_available_storage_mib() ;
  float available_storage_mib() const;
  void set_available_storage_mib(float value);

  private:
  float _internal_available_storage_mib() const;
  void _internal_set_available_storage_mib(float value);

  public:
  // float total_storage_mib = 5;
  void clear_total_storage_mib() ;
  float total_storage_mib() const;
  void set_total_storage_mib(float value);

  private:
  float _internal_total_storage_mib() const;
  void _internal_set_total_storage_mib(float value);

  public:
  // float recording_time_s = 6;
  void clear_recording_time_s() ;
  float recording_time_s() const;
  void set_recording_time_s(float value);

  private:
  float _internal_recording_time_s() const;
  void _internal_set_recording_time_s(float value);

  public:
  // .mavsdk.rpc.camera.Status.StorageStatus storage_status = 8;
  void clear_storage_status() ;
  ::mavsdk::rpc::camera::Status_StorageStatus storage_status() const;
  void set_storage_status(::mavsdk::rpc::camera::Status_StorageStatus value);

  private:
  ::mavsdk::rpc::camera::Status_StorageStatus _internal_storage_status() const;
  void _internal_set_storage_status(::mavsdk::rpc::camera::Status_StorageStatus value);

  public:
  // uint32 storage_id = 9;
  void clear_storage_id() ;
  ::uint32_t storage_id() const;
  void set_storage_id(::uint32_t value);

  private:
  ::uint32_t _internal_storage_id() const;
  void _internal_set_storage_id(::uint32_t value);

  public:
  // .mavsdk.rpc.camera.Status.StorageType storage_type = 10;
  void clear_storage_type() ;
  ::mavsdk::rpc::camera::Status_StorageType storage_type() const;
  void set_storage_type(::mavsdk::rpc::camera::Status_StorageType value);

  private:
  ::mavsdk::rpc::camera::Status_StorageType _internal_storage_type() const;
  void _internal_set_storage_type(::mavsdk::rpc::camera::Status_StorageType value);

  public:
  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera.Status)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr media_folder_name_;
    bool video_on_;
    bool photo_interval_on_;
    float used_storage_mib_;
    float available_storage_mib_;
    float total_storage_mib_;
    float recording_time_s_;
    int storage_status_;
    ::uint32_t storage_id_;
    int storage_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camera_2fcamera_2eproto;
};// -------------------------------------------------------------------

class Option final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera.Option) */ {
 public:
  inline Option() : Option(nullptr) {}
  ~Option() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Option(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Option(const Option& from);
  Option(Option&& from) noexcept
    : Option() {
    *this = ::std::move(from);
  }

  inline Option& operator=(const Option& from) {
    CopyFrom(from);
    return *this;
  }
  inline Option& operator=(Option&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Option& default_instance() {
    return *internal_default_instance();
  }
  static inline const Option* internal_default_instance() {
    return reinterpret_cast<const Option*>(
               &_Option_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    50;

  friend void swap(Option& a, Option& b) {
    a.Swap(&b);
  }
  inline void Swap(Option* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Option* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Option* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Option>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Option& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Option& from) {
    Option::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Option* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mavsdk.rpc.camera.Option";
  }
  protected:
  explicit Option(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOptionIdFieldNumber = 1,
    kOptionDescriptionFieldNumber = 2,
  };
  // string option_id = 1;
  void clear_option_id() ;
  const std::string& option_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_option_id(Arg_&& arg, Args_... args);
  std::string* mutable_option_id();
  PROTOBUF_NODISCARD std::string* release_option_id();
  void set_allocated_option_id(std::string* ptr);

  private:
  const std::string& _internal_option_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_option_id(
      const std::string& value);
  std::string* _internal_mutable_option_id();

  public:
  // string option_description = 2;
  void clear_option_description() ;
  const std::string& option_description() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_option_description(Arg_&& arg, Args_... args);
  std::string* mutable_option_description();
  PROTOBUF_NODISCARD std::string* release_option_description();
  void set_allocated_option_description(std::string* ptr);

  private:
  const std::string& _internal_option_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_option_description(
      const std::string& value);
  std::string* _internal_mutable_option_description();

  public:
  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera.Option)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr option_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr option_description_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camera_2fcamera_2eproto;
};// -------------------------------------------------------------------

class Setting final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera.Setting) */ {
 public:
  inline Setting() : Setting(nullptr) {}
  ~Setting() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Setting(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Setting(const Setting& from);
  Setting(Setting&& from) noexcept
    : Setting() {
    *this = ::std::move(from);
  }

  inline Setting& operator=(const Setting& from) {
    CopyFrom(from);
    return *this;
  }
  inline Setting& operator=(Setting&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Setting& default_instance() {
    return *internal_default_instance();
  }
  static inline const Setting* internal_default_instance() {
    return reinterpret_cast<const Setting*>(
               &_Setting_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    51;

  friend void swap(Setting& a, Setting& b) {
    a.Swap(&b);
  }
  inline void Swap(Setting* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Setting* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Setting* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Setting>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Setting& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Setting& from) {
    Setting::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Setting* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mavsdk.rpc.camera.Setting";
  }
  protected:
  explicit Setting(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSettingIdFieldNumber = 1,
    kSettingDescriptionFieldNumber = 2,
    kOptionFieldNumber = 3,
    kIsRangeFieldNumber = 4,
  };
  // string setting_id = 1;
  void clear_setting_id() ;
  const std::string& setting_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_setting_id(Arg_&& arg, Args_... args);
  std::string* mutable_setting_id();
  PROTOBUF_NODISCARD std::string* release_setting_id();
  void set_allocated_setting_id(std::string* ptr);

  private:
  const std::string& _internal_setting_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_setting_id(
      const std::string& value);
  std::string* _internal_mutable_setting_id();

  public:
  // string setting_description = 2;
  void clear_setting_description() ;
  const std::string& setting_description() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_setting_description(Arg_&& arg, Args_... args);
  std::string* mutable_setting_description();
  PROTOBUF_NODISCARD std::string* release_setting_description();
  void set_allocated_setting_description(std::string* ptr);

  private:
  const std::string& _internal_setting_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_setting_description(
      const std::string& value);
  std::string* _internal_mutable_setting_description();

  public:
  // .mavsdk.rpc.camera.Option option = 3;
  bool has_option() const;
  void clear_option() ;
  const ::mavsdk::rpc::camera::Option& option() const;
  PROTOBUF_NODISCARD ::mavsdk::rpc::camera::Option* release_option();
  ::mavsdk::rpc::camera::Option* mutable_option();
  void set_allocated_option(::mavsdk::rpc::camera::Option* option);
  private:
  const ::mavsdk::rpc::camera::Option& _internal_option() const;
  ::mavsdk::rpc::camera::Option* _internal_mutable_option();
  public:
  void unsafe_arena_set_allocated_option(
      ::mavsdk::rpc::camera::Option* option);
  ::mavsdk::rpc::camera::Option* unsafe_arena_release_option();
  // bool is_range = 4;
  void clear_is_range() ;
  bool is_range() const;
  void set_is_range(bool value);

  private:
  bool _internal_is_range() const;
  void _internal_set_is_range(bool value);

  public:
  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera.Setting)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr setting_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr setting_description_;
    ::mavsdk::rpc::camera::Option* option_;
    bool is_range_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camera_2fcamera_2eproto;
};// -------------------------------------------------------------------

class SettingOptions final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera.SettingOptions) */ {
 public:
  inline SettingOptions() : SettingOptions(nullptr) {}
  ~SettingOptions() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SettingOptions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SettingOptions(const SettingOptions& from);
  SettingOptions(SettingOptions&& from) noexcept
    : SettingOptions() {
    *this = ::std::move(from);
  }

  inline SettingOptions& operator=(const SettingOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline SettingOptions& operator=(SettingOptions&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SettingOptions& default_instance() {
    return *internal_default_instance();
  }
  static inline const SettingOptions* internal_default_instance() {
    return reinterpret_cast<const SettingOptions*>(
               &_SettingOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    52;

  friend void swap(SettingOptions& a, SettingOptions& b) {
    a.Swap(&b);
  }
  inline void Swap(SettingOptions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SettingOptions* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SettingOptions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SettingOptions>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SettingOptions& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SettingOptions& from) {
    SettingOptions::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SettingOptions* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mavsdk.rpc.camera.SettingOptions";
  }
  protected:
  explicit SettingOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOptionsFieldNumber = 3,
    kSettingIdFieldNumber = 1,
    kSettingDescriptionFieldNumber = 2,
    kIsRangeFieldNumber = 4,
  };
  // repeated .mavsdk.rpc.camera.Option options = 3;
  int options_size() const;
  private:
  int _internal_options_size() const;

  public:
  void clear_options() ;
  ::mavsdk::rpc::camera::Option* mutable_options(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mavsdk::rpc::camera::Option >*
      mutable_options();
  private:
  const ::mavsdk::rpc::camera::Option& _internal_options(int index) const;
  ::mavsdk::rpc::camera::Option* _internal_add_options();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::mavsdk::rpc::camera::Option>& _internal_options() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::mavsdk::rpc::camera::Option>* _internal_mutable_options();
  public:
  const ::mavsdk::rpc::camera::Option& options(int index) const;
  ::mavsdk::rpc::camera::Option* add_options();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mavsdk::rpc::camera::Option >&
      options() const;
  // string setting_id = 1;
  void clear_setting_id() ;
  const std::string& setting_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_setting_id(Arg_&& arg, Args_... args);
  std::string* mutable_setting_id();
  PROTOBUF_NODISCARD std::string* release_setting_id();
  void set_allocated_setting_id(std::string* ptr);

  private:
  const std::string& _internal_setting_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_setting_id(
      const std::string& value);
  std::string* _internal_mutable_setting_id();

  public:
  // string setting_description = 2;
  void clear_setting_description() ;
  const std::string& setting_description() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_setting_description(Arg_&& arg, Args_... args);
  std::string* mutable_setting_description();
  PROTOBUF_NODISCARD std::string* release_setting_description();
  void set_allocated_setting_description(std::string* ptr);

  private:
  const std::string& _internal_setting_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_setting_description(
      const std::string& value);
  std::string* _internal_mutable_setting_description();

  public:
  // bool is_range = 4;
  void clear_is_range() ;
  bool is_range() const;
  void set_is_range(bool value);

  private:
  bool _internal_is_range() const;
  void _internal_set_is_range(bool value);

  public:
  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera.SettingOptions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mavsdk::rpc::camera::Option > options_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr setting_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr setting_description_;
    bool is_range_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camera_2fcamera_2eproto;
};// -------------------------------------------------------------------

class Information final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mavsdk.rpc.camera.Information) */ {
 public:
  inline Information() : Information(nullptr) {}
  ~Information() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Information(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Information(const Information& from);
  Information(Information&& from) noexcept
    : Information() {
    *this = ::std::move(from);
  }

  inline Information& operator=(const Information& from) {
    CopyFrom(from);
    return *this;
  }
  inline Information& operator=(Information&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Information& default_instance() {
    return *internal_default_instance();
  }
  static inline const Information* internal_default_instance() {
    return reinterpret_cast<const Information*>(
               &_Information_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    53;

  friend void swap(Information& a, Information& b) {
    a.Swap(&b);
  }
  inline void Swap(Information* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Information* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Information* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Information>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Information& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Information& from) {
    Information::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Information* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mavsdk.rpc.camera.Information";
  }
  protected:
  explicit Information(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVendorNameFieldNumber = 1,
    kModelNameFieldNumber = 2,
    kFocalLengthMmFieldNumber = 3,
    kHorizontalSensorSizeMmFieldNumber = 4,
    kVerticalSensorSizeMmFieldNumber = 5,
    kHorizontalResolutionPxFieldNumber = 6,
    kVerticalResolutionPxFieldNumber = 7,
  };
  // string vendor_name = 1;
  void clear_vendor_name() ;
  const std::string& vendor_name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_vendor_name(Arg_&& arg, Args_... args);
  std::string* mutable_vendor_name();
  PROTOBUF_NODISCARD std::string* release_vendor_name();
  void set_allocated_vendor_name(std::string* ptr);

  private:
  const std::string& _internal_vendor_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vendor_name(
      const std::string& value);
  std::string* _internal_mutable_vendor_name();

  public:
  // string model_name = 2;
  void clear_model_name() ;
  const std::string& model_name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_model_name(Arg_&& arg, Args_... args);
  std::string* mutable_model_name();
  PROTOBUF_NODISCARD std::string* release_model_name();
  void set_allocated_model_name(std::string* ptr);

  private:
  const std::string& _internal_model_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model_name(
      const std::string& value);
  std::string* _internal_mutable_model_name();

  public:
  // float focal_length_mm = 3;
  void clear_focal_length_mm() ;
  float focal_length_mm() const;
  void set_focal_length_mm(float value);

  private:
  float _internal_focal_length_mm() const;
  void _internal_set_focal_length_mm(float value);

  public:
  // float horizontal_sensor_size_mm = 4;
  void clear_horizontal_sensor_size_mm() ;
  float horizontal_sensor_size_mm() const;
  void set_horizontal_sensor_size_mm(float value);

  private:
  float _internal_horizontal_sensor_size_mm() const;
  void _internal_set_horizontal_sensor_size_mm(float value);

  public:
  // float vertical_sensor_size_mm = 5;
  void clear_vertical_sensor_size_mm() ;
  float vertical_sensor_size_mm() const;
  void set_vertical_sensor_size_mm(float value);

  private:
  float _internal_vertical_sensor_size_mm() const;
  void _internal_set_vertical_sensor_size_mm(float value);

  public:
  // uint32 horizontal_resolution_px = 6;
  void clear_horizontal_resolution_px() ;
  ::uint32_t horizontal_resolution_px() const;
  void set_horizontal_resolution_px(::uint32_t value);

  private:
  ::uint32_t _internal_horizontal_resolution_px() const;
  void _internal_set_horizontal_resolution_px(::uint32_t value);

  public:
  // uint32 vertical_resolution_px = 7;
  void clear_vertical_resolution_px() ;
  ::uint32_t vertical_resolution_px() const;
  void set_vertical_resolution_px(::uint32_t value);

  private:
  ::uint32_t _internal_vertical_resolution_px() const;
  void _internal_set_vertical_resolution_px(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:mavsdk.rpc.camera.Information)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vendor_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_name_;
    float focal_length_mm_;
    float horizontal_sensor_size_mm_;
    float vertical_sensor_size_mm_;
    ::uint32_t horizontal_resolution_px_;
    ::uint32_t vertical_resolution_px_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camera_2fcamera_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// PrepareRequest

// -------------------------------------------------------------------

// PrepareResponse

// .mavsdk.rpc.camera.CameraResult camera_result = 1;
inline bool PrepareResponse::has_camera_result() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.camera_result_ != nullptr);
  return value;
}
inline void PrepareResponse::clear_camera_result() {
  if (_impl_.camera_result_ != nullptr) _impl_.camera_result_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::mavsdk::rpc::camera::CameraResult& PrepareResponse::_internal_camera_result() const {
  const ::mavsdk::rpc::camera::CameraResult* p = _impl_.camera_result_;
  return p != nullptr ? *p : reinterpret_cast<const ::mavsdk::rpc::camera::CameraResult&>(
      ::mavsdk::rpc::camera::_CameraResult_default_instance_);
}
inline const ::mavsdk::rpc::camera::CameraResult& PrepareResponse::camera_result() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera.PrepareResponse.camera_result)
  return _internal_camera_result();
}
inline void PrepareResponse::unsafe_arena_set_allocated_camera_result(
    ::mavsdk::rpc::camera::CameraResult* camera_result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.camera_result_);
  }
  _impl_.camera_result_ = camera_result;
  if (camera_result) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mavsdk.rpc.camera.PrepareResponse.camera_result)
}
inline ::mavsdk::rpc::camera::CameraResult* PrepareResponse::release_camera_result() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::mavsdk::rpc::camera::CameraResult* temp = _impl_.camera_result_;
  _impl_.camera_result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mavsdk::rpc::camera::CameraResult* PrepareResponse::unsafe_arena_release_camera_result() {
  // @@protoc_insertion_point(field_release:mavsdk.rpc.camera.PrepareResponse.camera_result)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::mavsdk::rpc::camera::CameraResult* temp = _impl_.camera_result_;
  _impl_.camera_result_ = nullptr;
  return temp;
}
inline ::mavsdk::rpc::camera::CameraResult* PrepareResponse::_internal_mutable_camera_result() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.camera_result_ == nullptr) {
    auto* p = CreateMaybeMessage<::mavsdk::rpc::camera::CameraResult>(GetArenaForAllocation());
    _impl_.camera_result_ = p;
  }
  return _impl_.camera_result_;
}
inline ::mavsdk::rpc::camera::CameraResult* PrepareResponse::mutable_camera_result() {
  ::mavsdk::rpc::camera::CameraResult* _msg = _internal_mutable_camera_result();
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.camera.PrepareResponse.camera_result)
  return _msg;
}
inline void PrepareResponse::set_allocated_camera_result(::mavsdk::rpc::camera::CameraResult* camera_result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.camera_result_;
  }
  if (camera_result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(camera_result);
    if (message_arena != submessage_arena) {
      camera_result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, camera_result, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.camera_result_ = camera_result;
  // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.camera.PrepareResponse.camera_result)
}

// -------------------------------------------------------------------

// TakePhotoRequest

// -------------------------------------------------------------------

// TakePhotoResponse

// .mavsdk.rpc.camera.CameraResult camera_result = 1;
inline bool TakePhotoResponse::has_camera_result() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.camera_result_ != nullptr);
  return value;
}
inline void TakePhotoResponse::clear_camera_result() {
  if (_impl_.camera_result_ != nullptr) _impl_.camera_result_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::mavsdk::rpc::camera::CameraResult& TakePhotoResponse::_internal_camera_result() const {
  const ::mavsdk::rpc::camera::CameraResult* p = _impl_.camera_result_;
  return p != nullptr ? *p : reinterpret_cast<const ::mavsdk::rpc::camera::CameraResult&>(
      ::mavsdk::rpc::camera::_CameraResult_default_instance_);
}
inline const ::mavsdk::rpc::camera::CameraResult& TakePhotoResponse::camera_result() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera.TakePhotoResponse.camera_result)
  return _internal_camera_result();
}
inline void TakePhotoResponse::unsafe_arena_set_allocated_camera_result(
    ::mavsdk::rpc::camera::CameraResult* camera_result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.camera_result_);
  }
  _impl_.camera_result_ = camera_result;
  if (camera_result) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mavsdk.rpc.camera.TakePhotoResponse.camera_result)
}
inline ::mavsdk::rpc::camera::CameraResult* TakePhotoResponse::release_camera_result() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::mavsdk::rpc::camera::CameraResult* temp = _impl_.camera_result_;
  _impl_.camera_result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mavsdk::rpc::camera::CameraResult* TakePhotoResponse::unsafe_arena_release_camera_result() {
  // @@protoc_insertion_point(field_release:mavsdk.rpc.camera.TakePhotoResponse.camera_result)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::mavsdk::rpc::camera::CameraResult* temp = _impl_.camera_result_;
  _impl_.camera_result_ = nullptr;
  return temp;
}
inline ::mavsdk::rpc::camera::CameraResult* TakePhotoResponse::_internal_mutable_camera_result() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.camera_result_ == nullptr) {
    auto* p = CreateMaybeMessage<::mavsdk::rpc::camera::CameraResult>(GetArenaForAllocation());
    _impl_.camera_result_ = p;
  }
  return _impl_.camera_result_;
}
inline ::mavsdk::rpc::camera::CameraResult* TakePhotoResponse::mutable_camera_result() {
  ::mavsdk::rpc::camera::CameraResult* _msg = _internal_mutable_camera_result();
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.camera.TakePhotoResponse.camera_result)
  return _msg;
}
inline void TakePhotoResponse::set_allocated_camera_result(::mavsdk::rpc::camera::CameraResult* camera_result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.camera_result_;
  }
  if (camera_result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(camera_result);
    if (message_arena != submessage_arena) {
      camera_result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, camera_result, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.camera_result_ = camera_result;
  // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.camera.TakePhotoResponse.camera_result)
}

// -------------------------------------------------------------------

// StartPhotoIntervalRequest

// float interval_s = 1;
inline void StartPhotoIntervalRequest::clear_interval_s() {
  _impl_.interval_s_ = 0;
}
inline float StartPhotoIntervalRequest::interval_s() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera.StartPhotoIntervalRequest.interval_s)
  return _internal_interval_s();
}
inline void StartPhotoIntervalRequest::set_interval_s(float value) {
  _internal_set_interval_s(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera.StartPhotoIntervalRequest.interval_s)
}
inline float StartPhotoIntervalRequest::_internal_interval_s() const {
  return _impl_.interval_s_;
}
inline void StartPhotoIntervalRequest::_internal_set_interval_s(float value) {
  ;
  _impl_.interval_s_ = value;
}

// -------------------------------------------------------------------

// StartPhotoIntervalResponse

// .mavsdk.rpc.camera.CameraResult camera_result = 1;
inline bool StartPhotoIntervalResponse::has_camera_result() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.camera_result_ != nullptr);
  return value;
}
inline void StartPhotoIntervalResponse::clear_camera_result() {
  if (_impl_.camera_result_ != nullptr) _impl_.camera_result_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::mavsdk::rpc::camera::CameraResult& StartPhotoIntervalResponse::_internal_camera_result() const {
  const ::mavsdk::rpc::camera::CameraResult* p = _impl_.camera_result_;
  return p != nullptr ? *p : reinterpret_cast<const ::mavsdk::rpc::camera::CameraResult&>(
      ::mavsdk::rpc::camera::_CameraResult_default_instance_);
}
inline const ::mavsdk::rpc::camera::CameraResult& StartPhotoIntervalResponse::camera_result() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera.StartPhotoIntervalResponse.camera_result)
  return _internal_camera_result();
}
inline void StartPhotoIntervalResponse::unsafe_arena_set_allocated_camera_result(
    ::mavsdk::rpc::camera::CameraResult* camera_result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.camera_result_);
  }
  _impl_.camera_result_ = camera_result;
  if (camera_result) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mavsdk.rpc.camera.StartPhotoIntervalResponse.camera_result)
}
inline ::mavsdk::rpc::camera::CameraResult* StartPhotoIntervalResponse::release_camera_result() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::mavsdk::rpc::camera::CameraResult* temp = _impl_.camera_result_;
  _impl_.camera_result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mavsdk::rpc::camera::CameraResult* StartPhotoIntervalResponse::unsafe_arena_release_camera_result() {
  // @@protoc_insertion_point(field_release:mavsdk.rpc.camera.StartPhotoIntervalResponse.camera_result)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::mavsdk::rpc::camera::CameraResult* temp = _impl_.camera_result_;
  _impl_.camera_result_ = nullptr;
  return temp;
}
inline ::mavsdk::rpc::camera::CameraResult* StartPhotoIntervalResponse::_internal_mutable_camera_result() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.camera_result_ == nullptr) {
    auto* p = CreateMaybeMessage<::mavsdk::rpc::camera::CameraResult>(GetArenaForAllocation());
    _impl_.camera_result_ = p;
  }
  return _impl_.camera_result_;
}
inline ::mavsdk::rpc::camera::CameraResult* StartPhotoIntervalResponse::mutable_camera_result() {
  ::mavsdk::rpc::camera::CameraResult* _msg = _internal_mutable_camera_result();
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.camera.StartPhotoIntervalResponse.camera_result)
  return _msg;
}
inline void StartPhotoIntervalResponse::set_allocated_camera_result(::mavsdk::rpc::camera::CameraResult* camera_result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.camera_result_;
  }
  if (camera_result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(camera_result);
    if (message_arena != submessage_arena) {
      camera_result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, camera_result, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.camera_result_ = camera_result;
  // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.camera.StartPhotoIntervalResponse.camera_result)
}

// -------------------------------------------------------------------

// StopPhotoIntervalRequest

// -------------------------------------------------------------------

// StopPhotoIntervalResponse

// .mavsdk.rpc.camera.CameraResult camera_result = 1;
inline bool StopPhotoIntervalResponse::has_camera_result() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.camera_result_ != nullptr);
  return value;
}
inline void StopPhotoIntervalResponse::clear_camera_result() {
  if (_impl_.camera_result_ != nullptr) _impl_.camera_result_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::mavsdk::rpc::camera::CameraResult& StopPhotoIntervalResponse::_internal_camera_result() const {
  const ::mavsdk::rpc::camera::CameraResult* p = _impl_.camera_result_;
  return p != nullptr ? *p : reinterpret_cast<const ::mavsdk::rpc::camera::CameraResult&>(
      ::mavsdk::rpc::camera::_CameraResult_default_instance_);
}
inline const ::mavsdk::rpc::camera::CameraResult& StopPhotoIntervalResponse::camera_result() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera.StopPhotoIntervalResponse.camera_result)
  return _internal_camera_result();
}
inline void StopPhotoIntervalResponse::unsafe_arena_set_allocated_camera_result(
    ::mavsdk::rpc::camera::CameraResult* camera_result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.camera_result_);
  }
  _impl_.camera_result_ = camera_result;
  if (camera_result) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mavsdk.rpc.camera.StopPhotoIntervalResponse.camera_result)
}
inline ::mavsdk::rpc::camera::CameraResult* StopPhotoIntervalResponse::release_camera_result() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::mavsdk::rpc::camera::CameraResult* temp = _impl_.camera_result_;
  _impl_.camera_result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mavsdk::rpc::camera::CameraResult* StopPhotoIntervalResponse::unsafe_arena_release_camera_result() {
  // @@protoc_insertion_point(field_release:mavsdk.rpc.camera.StopPhotoIntervalResponse.camera_result)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::mavsdk::rpc::camera::CameraResult* temp = _impl_.camera_result_;
  _impl_.camera_result_ = nullptr;
  return temp;
}
inline ::mavsdk::rpc::camera::CameraResult* StopPhotoIntervalResponse::_internal_mutable_camera_result() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.camera_result_ == nullptr) {
    auto* p = CreateMaybeMessage<::mavsdk::rpc::camera::CameraResult>(GetArenaForAllocation());
    _impl_.camera_result_ = p;
  }
  return _impl_.camera_result_;
}
inline ::mavsdk::rpc::camera::CameraResult* StopPhotoIntervalResponse::mutable_camera_result() {
  ::mavsdk::rpc::camera::CameraResult* _msg = _internal_mutable_camera_result();
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.camera.StopPhotoIntervalResponse.camera_result)
  return _msg;
}
inline void StopPhotoIntervalResponse::set_allocated_camera_result(::mavsdk::rpc::camera::CameraResult* camera_result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.camera_result_;
  }
  if (camera_result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(camera_result);
    if (message_arena != submessage_arena) {
      camera_result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, camera_result, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.camera_result_ = camera_result;
  // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.camera.StopPhotoIntervalResponse.camera_result)
}

// -------------------------------------------------------------------

// StartVideoRequest

// -------------------------------------------------------------------

// StartVideoResponse

// .mavsdk.rpc.camera.CameraResult camera_result = 1;
inline bool StartVideoResponse::has_camera_result() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.camera_result_ != nullptr);
  return value;
}
inline void StartVideoResponse::clear_camera_result() {
  if (_impl_.camera_result_ != nullptr) _impl_.camera_result_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::mavsdk::rpc::camera::CameraResult& StartVideoResponse::_internal_camera_result() const {
  const ::mavsdk::rpc::camera::CameraResult* p = _impl_.camera_result_;
  return p != nullptr ? *p : reinterpret_cast<const ::mavsdk::rpc::camera::CameraResult&>(
      ::mavsdk::rpc::camera::_CameraResult_default_instance_);
}
inline const ::mavsdk::rpc::camera::CameraResult& StartVideoResponse::camera_result() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera.StartVideoResponse.camera_result)
  return _internal_camera_result();
}
inline void StartVideoResponse::unsafe_arena_set_allocated_camera_result(
    ::mavsdk::rpc::camera::CameraResult* camera_result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.camera_result_);
  }
  _impl_.camera_result_ = camera_result;
  if (camera_result) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mavsdk.rpc.camera.StartVideoResponse.camera_result)
}
inline ::mavsdk::rpc::camera::CameraResult* StartVideoResponse::release_camera_result() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::mavsdk::rpc::camera::CameraResult* temp = _impl_.camera_result_;
  _impl_.camera_result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mavsdk::rpc::camera::CameraResult* StartVideoResponse::unsafe_arena_release_camera_result() {
  // @@protoc_insertion_point(field_release:mavsdk.rpc.camera.StartVideoResponse.camera_result)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::mavsdk::rpc::camera::CameraResult* temp = _impl_.camera_result_;
  _impl_.camera_result_ = nullptr;
  return temp;
}
inline ::mavsdk::rpc::camera::CameraResult* StartVideoResponse::_internal_mutable_camera_result() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.camera_result_ == nullptr) {
    auto* p = CreateMaybeMessage<::mavsdk::rpc::camera::CameraResult>(GetArenaForAllocation());
    _impl_.camera_result_ = p;
  }
  return _impl_.camera_result_;
}
inline ::mavsdk::rpc::camera::CameraResult* StartVideoResponse::mutable_camera_result() {
  ::mavsdk::rpc::camera::CameraResult* _msg = _internal_mutable_camera_result();
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.camera.StartVideoResponse.camera_result)
  return _msg;
}
inline void StartVideoResponse::set_allocated_camera_result(::mavsdk::rpc::camera::CameraResult* camera_result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.camera_result_;
  }
  if (camera_result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(camera_result);
    if (message_arena != submessage_arena) {
      camera_result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, camera_result, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.camera_result_ = camera_result;
  // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.camera.StartVideoResponse.camera_result)
}

// -------------------------------------------------------------------

// StopVideoRequest

// -------------------------------------------------------------------

// StopVideoResponse

// .mavsdk.rpc.camera.CameraResult camera_result = 1;
inline bool StopVideoResponse::has_camera_result() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.camera_result_ != nullptr);
  return value;
}
inline void StopVideoResponse::clear_camera_result() {
  if (_impl_.camera_result_ != nullptr) _impl_.camera_result_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::mavsdk::rpc::camera::CameraResult& StopVideoResponse::_internal_camera_result() const {
  const ::mavsdk::rpc::camera::CameraResult* p = _impl_.camera_result_;
  return p != nullptr ? *p : reinterpret_cast<const ::mavsdk::rpc::camera::CameraResult&>(
      ::mavsdk::rpc::camera::_CameraResult_default_instance_);
}
inline const ::mavsdk::rpc::camera::CameraResult& StopVideoResponse::camera_result() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera.StopVideoResponse.camera_result)
  return _internal_camera_result();
}
inline void StopVideoResponse::unsafe_arena_set_allocated_camera_result(
    ::mavsdk::rpc::camera::CameraResult* camera_result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.camera_result_);
  }
  _impl_.camera_result_ = camera_result;
  if (camera_result) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mavsdk.rpc.camera.StopVideoResponse.camera_result)
}
inline ::mavsdk::rpc::camera::CameraResult* StopVideoResponse::release_camera_result() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::mavsdk::rpc::camera::CameraResult* temp = _impl_.camera_result_;
  _impl_.camera_result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mavsdk::rpc::camera::CameraResult* StopVideoResponse::unsafe_arena_release_camera_result() {
  // @@protoc_insertion_point(field_release:mavsdk.rpc.camera.StopVideoResponse.camera_result)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::mavsdk::rpc::camera::CameraResult* temp = _impl_.camera_result_;
  _impl_.camera_result_ = nullptr;
  return temp;
}
inline ::mavsdk::rpc::camera::CameraResult* StopVideoResponse::_internal_mutable_camera_result() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.camera_result_ == nullptr) {
    auto* p = CreateMaybeMessage<::mavsdk::rpc::camera::CameraResult>(GetArenaForAllocation());
    _impl_.camera_result_ = p;
  }
  return _impl_.camera_result_;
}
inline ::mavsdk::rpc::camera::CameraResult* StopVideoResponse::mutable_camera_result() {
  ::mavsdk::rpc::camera::CameraResult* _msg = _internal_mutable_camera_result();
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.camera.StopVideoResponse.camera_result)
  return _msg;
}
inline void StopVideoResponse::set_allocated_camera_result(::mavsdk::rpc::camera::CameraResult* camera_result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.camera_result_;
  }
  if (camera_result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(camera_result);
    if (message_arena != submessage_arena) {
      camera_result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, camera_result, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.camera_result_ = camera_result;
  // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.camera.StopVideoResponse.camera_result)
}

// -------------------------------------------------------------------

// StartVideoStreamingRequest

// -------------------------------------------------------------------

// StartVideoStreamingResponse

// .mavsdk.rpc.camera.CameraResult camera_result = 1;
inline bool StartVideoStreamingResponse::has_camera_result() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.camera_result_ != nullptr);
  return value;
}
inline void StartVideoStreamingResponse::clear_camera_result() {
  if (_impl_.camera_result_ != nullptr) _impl_.camera_result_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::mavsdk::rpc::camera::CameraResult& StartVideoStreamingResponse::_internal_camera_result() const {
  const ::mavsdk::rpc::camera::CameraResult* p = _impl_.camera_result_;
  return p != nullptr ? *p : reinterpret_cast<const ::mavsdk::rpc::camera::CameraResult&>(
      ::mavsdk::rpc::camera::_CameraResult_default_instance_);
}
inline const ::mavsdk::rpc::camera::CameraResult& StartVideoStreamingResponse::camera_result() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera.StartVideoStreamingResponse.camera_result)
  return _internal_camera_result();
}
inline void StartVideoStreamingResponse::unsafe_arena_set_allocated_camera_result(
    ::mavsdk::rpc::camera::CameraResult* camera_result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.camera_result_);
  }
  _impl_.camera_result_ = camera_result;
  if (camera_result) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mavsdk.rpc.camera.StartVideoStreamingResponse.camera_result)
}
inline ::mavsdk::rpc::camera::CameraResult* StartVideoStreamingResponse::release_camera_result() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::mavsdk::rpc::camera::CameraResult* temp = _impl_.camera_result_;
  _impl_.camera_result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mavsdk::rpc::camera::CameraResult* StartVideoStreamingResponse::unsafe_arena_release_camera_result() {
  // @@protoc_insertion_point(field_release:mavsdk.rpc.camera.StartVideoStreamingResponse.camera_result)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::mavsdk::rpc::camera::CameraResult* temp = _impl_.camera_result_;
  _impl_.camera_result_ = nullptr;
  return temp;
}
inline ::mavsdk::rpc::camera::CameraResult* StartVideoStreamingResponse::_internal_mutable_camera_result() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.camera_result_ == nullptr) {
    auto* p = CreateMaybeMessage<::mavsdk::rpc::camera::CameraResult>(GetArenaForAllocation());
    _impl_.camera_result_ = p;
  }
  return _impl_.camera_result_;
}
inline ::mavsdk::rpc::camera::CameraResult* StartVideoStreamingResponse::mutable_camera_result() {
  ::mavsdk::rpc::camera::CameraResult* _msg = _internal_mutable_camera_result();
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.camera.StartVideoStreamingResponse.camera_result)
  return _msg;
}
inline void StartVideoStreamingResponse::set_allocated_camera_result(::mavsdk::rpc::camera::CameraResult* camera_result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.camera_result_;
  }
  if (camera_result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(camera_result);
    if (message_arena != submessage_arena) {
      camera_result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, camera_result, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.camera_result_ = camera_result;
  // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.camera.StartVideoStreamingResponse.camera_result)
}

// -------------------------------------------------------------------

// StopVideoStreamingRequest

// -------------------------------------------------------------------

// StopVideoStreamingResponse

// .mavsdk.rpc.camera.CameraResult camera_result = 1;
inline bool StopVideoStreamingResponse::has_camera_result() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.camera_result_ != nullptr);
  return value;
}
inline void StopVideoStreamingResponse::clear_camera_result() {
  if (_impl_.camera_result_ != nullptr) _impl_.camera_result_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::mavsdk::rpc::camera::CameraResult& StopVideoStreamingResponse::_internal_camera_result() const {
  const ::mavsdk::rpc::camera::CameraResult* p = _impl_.camera_result_;
  return p != nullptr ? *p : reinterpret_cast<const ::mavsdk::rpc::camera::CameraResult&>(
      ::mavsdk::rpc::camera::_CameraResult_default_instance_);
}
inline const ::mavsdk::rpc::camera::CameraResult& StopVideoStreamingResponse::camera_result() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera.StopVideoStreamingResponse.camera_result)
  return _internal_camera_result();
}
inline void StopVideoStreamingResponse::unsafe_arena_set_allocated_camera_result(
    ::mavsdk::rpc::camera::CameraResult* camera_result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.camera_result_);
  }
  _impl_.camera_result_ = camera_result;
  if (camera_result) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mavsdk.rpc.camera.StopVideoStreamingResponse.camera_result)
}
inline ::mavsdk::rpc::camera::CameraResult* StopVideoStreamingResponse::release_camera_result() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::mavsdk::rpc::camera::CameraResult* temp = _impl_.camera_result_;
  _impl_.camera_result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mavsdk::rpc::camera::CameraResult* StopVideoStreamingResponse::unsafe_arena_release_camera_result() {
  // @@protoc_insertion_point(field_release:mavsdk.rpc.camera.StopVideoStreamingResponse.camera_result)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::mavsdk::rpc::camera::CameraResult* temp = _impl_.camera_result_;
  _impl_.camera_result_ = nullptr;
  return temp;
}
inline ::mavsdk::rpc::camera::CameraResult* StopVideoStreamingResponse::_internal_mutable_camera_result() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.camera_result_ == nullptr) {
    auto* p = CreateMaybeMessage<::mavsdk::rpc::camera::CameraResult>(GetArenaForAllocation());
    _impl_.camera_result_ = p;
  }
  return _impl_.camera_result_;
}
inline ::mavsdk::rpc::camera::CameraResult* StopVideoStreamingResponse::mutable_camera_result() {
  ::mavsdk::rpc::camera::CameraResult* _msg = _internal_mutable_camera_result();
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.camera.StopVideoStreamingResponse.camera_result)
  return _msg;
}
inline void StopVideoStreamingResponse::set_allocated_camera_result(::mavsdk::rpc::camera::CameraResult* camera_result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.camera_result_;
  }
  if (camera_result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(camera_result);
    if (message_arena != submessage_arena) {
      camera_result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, camera_result, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.camera_result_ = camera_result;
  // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.camera.StopVideoStreamingResponse.camera_result)
}

// -------------------------------------------------------------------

// SetModeRequest

// .mavsdk.rpc.camera.Mode mode = 1;
inline void SetModeRequest::clear_mode() {
  _impl_.mode_ = 0;
}
inline ::mavsdk::rpc::camera::Mode SetModeRequest::mode() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera.SetModeRequest.mode)
  return _internal_mode();
}
inline void SetModeRequest::set_mode(::mavsdk::rpc::camera::Mode value) {
   _internal_set_mode(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera.SetModeRequest.mode)
}
inline ::mavsdk::rpc::camera::Mode SetModeRequest::_internal_mode() const {
  return static_cast<::mavsdk::rpc::camera::Mode>(_impl_.mode_);
}
inline void SetModeRequest::_internal_set_mode(::mavsdk::rpc::camera::Mode value) {
  ;
  _impl_.mode_ = value;
}

// -------------------------------------------------------------------

// SetModeResponse

// .mavsdk.rpc.camera.CameraResult camera_result = 1;
inline bool SetModeResponse::has_camera_result() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.camera_result_ != nullptr);
  return value;
}
inline void SetModeResponse::clear_camera_result() {
  if (_impl_.camera_result_ != nullptr) _impl_.camera_result_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::mavsdk::rpc::camera::CameraResult& SetModeResponse::_internal_camera_result() const {
  const ::mavsdk::rpc::camera::CameraResult* p = _impl_.camera_result_;
  return p != nullptr ? *p : reinterpret_cast<const ::mavsdk::rpc::camera::CameraResult&>(
      ::mavsdk::rpc::camera::_CameraResult_default_instance_);
}
inline const ::mavsdk::rpc::camera::CameraResult& SetModeResponse::camera_result() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera.SetModeResponse.camera_result)
  return _internal_camera_result();
}
inline void SetModeResponse::unsafe_arena_set_allocated_camera_result(
    ::mavsdk::rpc::camera::CameraResult* camera_result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.camera_result_);
  }
  _impl_.camera_result_ = camera_result;
  if (camera_result) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mavsdk.rpc.camera.SetModeResponse.camera_result)
}
inline ::mavsdk::rpc::camera::CameraResult* SetModeResponse::release_camera_result() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::mavsdk::rpc::camera::CameraResult* temp = _impl_.camera_result_;
  _impl_.camera_result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mavsdk::rpc::camera::CameraResult* SetModeResponse::unsafe_arena_release_camera_result() {
  // @@protoc_insertion_point(field_release:mavsdk.rpc.camera.SetModeResponse.camera_result)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::mavsdk::rpc::camera::CameraResult* temp = _impl_.camera_result_;
  _impl_.camera_result_ = nullptr;
  return temp;
}
inline ::mavsdk::rpc::camera::CameraResult* SetModeResponse::_internal_mutable_camera_result() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.camera_result_ == nullptr) {
    auto* p = CreateMaybeMessage<::mavsdk::rpc::camera::CameraResult>(GetArenaForAllocation());
    _impl_.camera_result_ = p;
  }
  return _impl_.camera_result_;
}
inline ::mavsdk::rpc::camera::CameraResult* SetModeResponse::mutable_camera_result() {
  ::mavsdk::rpc::camera::CameraResult* _msg = _internal_mutable_camera_result();
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.camera.SetModeResponse.camera_result)
  return _msg;
}
inline void SetModeResponse::set_allocated_camera_result(::mavsdk::rpc::camera::CameraResult* camera_result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.camera_result_;
  }
  if (camera_result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(camera_result);
    if (message_arena != submessage_arena) {
      camera_result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, camera_result, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.camera_result_ = camera_result;
  // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.camera.SetModeResponse.camera_result)
}

// -------------------------------------------------------------------

// ListPhotosRequest

// .mavsdk.rpc.camera.PhotosRange photos_range = 1;
inline void ListPhotosRequest::clear_photos_range() {
  _impl_.photos_range_ = 0;
}
inline ::mavsdk::rpc::camera::PhotosRange ListPhotosRequest::photos_range() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera.ListPhotosRequest.photos_range)
  return _internal_photos_range();
}
inline void ListPhotosRequest::set_photos_range(::mavsdk::rpc::camera::PhotosRange value) {
   _internal_set_photos_range(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera.ListPhotosRequest.photos_range)
}
inline ::mavsdk::rpc::camera::PhotosRange ListPhotosRequest::_internal_photos_range() const {
  return static_cast<::mavsdk::rpc::camera::PhotosRange>(_impl_.photos_range_);
}
inline void ListPhotosRequest::_internal_set_photos_range(::mavsdk::rpc::camera::PhotosRange value) {
  ;
  _impl_.photos_range_ = value;
}

// -------------------------------------------------------------------

// ListPhotosResponse

// .mavsdk.rpc.camera.CameraResult camera_result = 1;
inline bool ListPhotosResponse::has_camera_result() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.camera_result_ != nullptr);
  return value;
}
inline void ListPhotosResponse::clear_camera_result() {
  if (_impl_.camera_result_ != nullptr) _impl_.camera_result_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::mavsdk::rpc::camera::CameraResult& ListPhotosResponse::_internal_camera_result() const {
  const ::mavsdk::rpc::camera::CameraResult* p = _impl_.camera_result_;
  return p != nullptr ? *p : reinterpret_cast<const ::mavsdk::rpc::camera::CameraResult&>(
      ::mavsdk::rpc::camera::_CameraResult_default_instance_);
}
inline const ::mavsdk::rpc::camera::CameraResult& ListPhotosResponse::camera_result() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera.ListPhotosResponse.camera_result)
  return _internal_camera_result();
}
inline void ListPhotosResponse::unsafe_arena_set_allocated_camera_result(
    ::mavsdk::rpc::camera::CameraResult* camera_result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.camera_result_);
  }
  _impl_.camera_result_ = camera_result;
  if (camera_result) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mavsdk.rpc.camera.ListPhotosResponse.camera_result)
}
inline ::mavsdk::rpc::camera::CameraResult* ListPhotosResponse::release_camera_result() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::mavsdk::rpc::camera::CameraResult* temp = _impl_.camera_result_;
  _impl_.camera_result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mavsdk::rpc::camera::CameraResult* ListPhotosResponse::unsafe_arena_release_camera_result() {
  // @@protoc_insertion_point(field_release:mavsdk.rpc.camera.ListPhotosResponse.camera_result)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::mavsdk::rpc::camera::CameraResult* temp = _impl_.camera_result_;
  _impl_.camera_result_ = nullptr;
  return temp;
}
inline ::mavsdk::rpc::camera::CameraResult* ListPhotosResponse::_internal_mutable_camera_result() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.camera_result_ == nullptr) {
    auto* p = CreateMaybeMessage<::mavsdk::rpc::camera::CameraResult>(GetArenaForAllocation());
    _impl_.camera_result_ = p;
  }
  return _impl_.camera_result_;
}
inline ::mavsdk::rpc::camera::CameraResult* ListPhotosResponse::mutable_camera_result() {
  ::mavsdk::rpc::camera::CameraResult* _msg = _internal_mutable_camera_result();
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.camera.ListPhotosResponse.camera_result)
  return _msg;
}
inline void ListPhotosResponse::set_allocated_camera_result(::mavsdk::rpc::camera::CameraResult* camera_result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.camera_result_;
  }
  if (camera_result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(camera_result);
    if (message_arena != submessage_arena) {
      camera_result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, camera_result, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.camera_result_ = camera_result;
  // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.camera.ListPhotosResponse.camera_result)
}

// repeated .mavsdk.rpc.camera.CaptureInfo capture_infos = 2;
inline int ListPhotosResponse::_internal_capture_infos_size() const {
  return _impl_.capture_infos_.size();
}
inline int ListPhotosResponse::capture_infos_size() const {
  return _internal_capture_infos_size();
}
inline void ListPhotosResponse::clear_capture_infos() {
  _internal_mutable_capture_infos()->Clear();
}
inline ::mavsdk::rpc::camera::CaptureInfo* ListPhotosResponse::mutable_capture_infos(int index) {
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.camera.ListPhotosResponse.capture_infos)
  return _internal_mutable_capture_infos()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mavsdk::rpc::camera::CaptureInfo >*
ListPhotosResponse::mutable_capture_infos() {
  // @@protoc_insertion_point(field_mutable_list:mavsdk.rpc.camera.ListPhotosResponse.capture_infos)
  return _internal_mutable_capture_infos();
}
inline const ::mavsdk::rpc::camera::CaptureInfo& ListPhotosResponse::_internal_capture_infos(int index) const {
  return _internal_capture_infos().Get(index);
}
inline const ::mavsdk::rpc::camera::CaptureInfo& ListPhotosResponse::capture_infos(int index) const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera.ListPhotosResponse.capture_infos)
  return _internal_capture_infos(index);
}
inline ::mavsdk::rpc::camera::CaptureInfo* ListPhotosResponse::_internal_add_capture_infos() {
  return _internal_mutable_capture_infos()->Add();
}
inline ::mavsdk::rpc::camera::CaptureInfo* ListPhotosResponse::add_capture_infos() {
  ::mavsdk::rpc::camera::CaptureInfo* _add = _internal_add_capture_infos();
  // @@protoc_insertion_point(field_add:mavsdk.rpc.camera.ListPhotosResponse.capture_infos)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mavsdk::rpc::camera::CaptureInfo >&
ListPhotosResponse::capture_infos() const {
  // @@protoc_insertion_point(field_list:mavsdk.rpc.camera.ListPhotosResponse.capture_infos)
  return _internal_capture_infos();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::mavsdk::rpc::camera::CaptureInfo>&
ListPhotosResponse::_internal_capture_infos() const {
  return _impl_.capture_infos_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::mavsdk::rpc::camera::CaptureInfo>*
ListPhotosResponse::_internal_mutable_capture_infos() {
  return &_impl_.capture_infos_;
}

// -------------------------------------------------------------------

// SubscribeInformationRequest

// -------------------------------------------------------------------

// InformationResponse

// .mavsdk.rpc.camera.Information information = 1;
inline bool InformationResponse::has_information() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.information_ != nullptr);
  return value;
}
inline void InformationResponse::clear_information() {
  if (_impl_.information_ != nullptr) _impl_.information_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::mavsdk::rpc::camera::Information& InformationResponse::_internal_information() const {
  const ::mavsdk::rpc::camera::Information* p = _impl_.information_;
  return p != nullptr ? *p : reinterpret_cast<const ::mavsdk::rpc::camera::Information&>(
      ::mavsdk::rpc::camera::_Information_default_instance_);
}
inline const ::mavsdk::rpc::camera::Information& InformationResponse::information() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera.InformationResponse.information)
  return _internal_information();
}
inline void InformationResponse::unsafe_arena_set_allocated_information(
    ::mavsdk::rpc::camera::Information* information) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.information_);
  }
  _impl_.information_ = information;
  if (information) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mavsdk.rpc.camera.InformationResponse.information)
}
inline ::mavsdk::rpc::camera::Information* InformationResponse::release_information() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::mavsdk::rpc::camera::Information* temp = _impl_.information_;
  _impl_.information_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mavsdk::rpc::camera::Information* InformationResponse::unsafe_arena_release_information() {
  // @@protoc_insertion_point(field_release:mavsdk.rpc.camera.InformationResponse.information)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::mavsdk::rpc::camera::Information* temp = _impl_.information_;
  _impl_.information_ = nullptr;
  return temp;
}
inline ::mavsdk::rpc::camera::Information* InformationResponse::_internal_mutable_information() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.information_ == nullptr) {
    auto* p = CreateMaybeMessage<::mavsdk::rpc::camera::Information>(GetArenaForAllocation());
    _impl_.information_ = p;
  }
  return _impl_.information_;
}
inline ::mavsdk::rpc::camera::Information* InformationResponse::mutable_information() {
  ::mavsdk::rpc::camera::Information* _msg = _internal_mutable_information();
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.camera.InformationResponse.information)
  return _msg;
}
inline void InformationResponse::set_allocated_information(::mavsdk::rpc::camera::Information* information) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.information_;
  }
  if (information) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(information);
    if (message_arena != submessage_arena) {
      information = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, information, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.information_ = information;
  // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.camera.InformationResponse.information)
}

// -------------------------------------------------------------------

// SubscribeModeRequest

// -------------------------------------------------------------------

// ModeResponse

// .mavsdk.rpc.camera.Mode mode = 1;
inline void ModeResponse::clear_mode() {
  _impl_.mode_ = 0;
}
inline ::mavsdk::rpc::camera::Mode ModeResponse::mode() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera.ModeResponse.mode)
  return _internal_mode();
}
inline void ModeResponse::set_mode(::mavsdk::rpc::camera::Mode value) {
   _internal_set_mode(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera.ModeResponse.mode)
}
inline ::mavsdk::rpc::camera::Mode ModeResponse::_internal_mode() const {
  return static_cast<::mavsdk::rpc::camera::Mode>(_impl_.mode_);
}
inline void ModeResponse::_internal_set_mode(::mavsdk::rpc::camera::Mode value) {
  ;
  _impl_.mode_ = value;
}

// -------------------------------------------------------------------

// SubscribeVideoStreamInfoRequest

// -------------------------------------------------------------------

// VideoStreamInfoResponse

// .mavsdk.rpc.camera.VideoStreamInfo video_stream_info = 1;
inline bool VideoStreamInfoResponse::has_video_stream_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.video_stream_info_ != nullptr);
  return value;
}
inline void VideoStreamInfoResponse::clear_video_stream_info() {
  if (_impl_.video_stream_info_ != nullptr) _impl_.video_stream_info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::mavsdk::rpc::camera::VideoStreamInfo& VideoStreamInfoResponse::_internal_video_stream_info() const {
  const ::mavsdk::rpc::camera::VideoStreamInfo* p = _impl_.video_stream_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::mavsdk::rpc::camera::VideoStreamInfo&>(
      ::mavsdk::rpc::camera::_VideoStreamInfo_default_instance_);
}
inline const ::mavsdk::rpc::camera::VideoStreamInfo& VideoStreamInfoResponse::video_stream_info() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera.VideoStreamInfoResponse.video_stream_info)
  return _internal_video_stream_info();
}
inline void VideoStreamInfoResponse::unsafe_arena_set_allocated_video_stream_info(
    ::mavsdk::rpc::camera::VideoStreamInfo* video_stream_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.video_stream_info_);
  }
  _impl_.video_stream_info_ = video_stream_info;
  if (video_stream_info) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mavsdk.rpc.camera.VideoStreamInfoResponse.video_stream_info)
}
inline ::mavsdk::rpc::camera::VideoStreamInfo* VideoStreamInfoResponse::release_video_stream_info() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::mavsdk::rpc::camera::VideoStreamInfo* temp = _impl_.video_stream_info_;
  _impl_.video_stream_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mavsdk::rpc::camera::VideoStreamInfo* VideoStreamInfoResponse::unsafe_arena_release_video_stream_info() {
  // @@protoc_insertion_point(field_release:mavsdk.rpc.camera.VideoStreamInfoResponse.video_stream_info)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::mavsdk::rpc::camera::VideoStreamInfo* temp = _impl_.video_stream_info_;
  _impl_.video_stream_info_ = nullptr;
  return temp;
}
inline ::mavsdk::rpc::camera::VideoStreamInfo* VideoStreamInfoResponse::_internal_mutable_video_stream_info() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.video_stream_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::mavsdk::rpc::camera::VideoStreamInfo>(GetArenaForAllocation());
    _impl_.video_stream_info_ = p;
  }
  return _impl_.video_stream_info_;
}
inline ::mavsdk::rpc::camera::VideoStreamInfo* VideoStreamInfoResponse::mutable_video_stream_info() {
  ::mavsdk::rpc::camera::VideoStreamInfo* _msg = _internal_mutable_video_stream_info();
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.camera.VideoStreamInfoResponse.video_stream_info)
  return _msg;
}
inline void VideoStreamInfoResponse::set_allocated_video_stream_info(::mavsdk::rpc::camera::VideoStreamInfo* video_stream_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.video_stream_info_;
  }
  if (video_stream_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(video_stream_info);
    if (message_arena != submessage_arena) {
      video_stream_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, video_stream_info, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.video_stream_info_ = video_stream_info;
  // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.camera.VideoStreamInfoResponse.video_stream_info)
}

// -------------------------------------------------------------------

// SubscribeCaptureInfoRequest

// -------------------------------------------------------------------

// CaptureInfoResponse

// .mavsdk.rpc.camera.CaptureInfo capture_info = 1;
inline bool CaptureInfoResponse::has_capture_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.capture_info_ != nullptr);
  return value;
}
inline void CaptureInfoResponse::clear_capture_info() {
  if (_impl_.capture_info_ != nullptr) _impl_.capture_info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::mavsdk::rpc::camera::CaptureInfo& CaptureInfoResponse::_internal_capture_info() const {
  const ::mavsdk::rpc::camera::CaptureInfo* p = _impl_.capture_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::mavsdk::rpc::camera::CaptureInfo&>(
      ::mavsdk::rpc::camera::_CaptureInfo_default_instance_);
}
inline const ::mavsdk::rpc::camera::CaptureInfo& CaptureInfoResponse::capture_info() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera.CaptureInfoResponse.capture_info)
  return _internal_capture_info();
}
inline void CaptureInfoResponse::unsafe_arena_set_allocated_capture_info(
    ::mavsdk::rpc::camera::CaptureInfo* capture_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.capture_info_);
  }
  _impl_.capture_info_ = capture_info;
  if (capture_info) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mavsdk.rpc.camera.CaptureInfoResponse.capture_info)
}
inline ::mavsdk::rpc::camera::CaptureInfo* CaptureInfoResponse::release_capture_info() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::mavsdk::rpc::camera::CaptureInfo* temp = _impl_.capture_info_;
  _impl_.capture_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mavsdk::rpc::camera::CaptureInfo* CaptureInfoResponse::unsafe_arena_release_capture_info() {
  // @@protoc_insertion_point(field_release:mavsdk.rpc.camera.CaptureInfoResponse.capture_info)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::mavsdk::rpc::camera::CaptureInfo* temp = _impl_.capture_info_;
  _impl_.capture_info_ = nullptr;
  return temp;
}
inline ::mavsdk::rpc::camera::CaptureInfo* CaptureInfoResponse::_internal_mutable_capture_info() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.capture_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::mavsdk::rpc::camera::CaptureInfo>(GetArenaForAllocation());
    _impl_.capture_info_ = p;
  }
  return _impl_.capture_info_;
}
inline ::mavsdk::rpc::camera::CaptureInfo* CaptureInfoResponse::mutable_capture_info() {
  ::mavsdk::rpc::camera::CaptureInfo* _msg = _internal_mutable_capture_info();
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.camera.CaptureInfoResponse.capture_info)
  return _msg;
}
inline void CaptureInfoResponse::set_allocated_capture_info(::mavsdk::rpc::camera::CaptureInfo* capture_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.capture_info_;
  }
  if (capture_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(capture_info);
    if (message_arena != submessage_arena) {
      capture_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, capture_info, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.capture_info_ = capture_info;
  // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.camera.CaptureInfoResponse.capture_info)
}

// -------------------------------------------------------------------

// SubscribeStatusRequest

// -------------------------------------------------------------------

// StatusResponse

// .mavsdk.rpc.camera.Status camera_status = 1;
inline bool StatusResponse::has_camera_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.camera_status_ != nullptr);
  return value;
}
inline void StatusResponse::clear_camera_status() {
  if (_impl_.camera_status_ != nullptr) _impl_.camera_status_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::mavsdk::rpc::camera::Status& StatusResponse::_internal_camera_status() const {
  const ::mavsdk::rpc::camera::Status* p = _impl_.camera_status_;
  return p != nullptr ? *p : reinterpret_cast<const ::mavsdk::rpc::camera::Status&>(
      ::mavsdk::rpc::camera::_Status_default_instance_);
}
inline const ::mavsdk::rpc::camera::Status& StatusResponse::camera_status() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera.StatusResponse.camera_status)
  return _internal_camera_status();
}
inline void StatusResponse::unsafe_arena_set_allocated_camera_status(
    ::mavsdk::rpc::camera::Status* camera_status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.camera_status_);
  }
  _impl_.camera_status_ = camera_status;
  if (camera_status) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mavsdk.rpc.camera.StatusResponse.camera_status)
}
inline ::mavsdk::rpc::camera::Status* StatusResponse::release_camera_status() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::mavsdk::rpc::camera::Status* temp = _impl_.camera_status_;
  _impl_.camera_status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mavsdk::rpc::camera::Status* StatusResponse::unsafe_arena_release_camera_status() {
  // @@protoc_insertion_point(field_release:mavsdk.rpc.camera.StatusResponse.camera_status)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::mavsdk::rpc::camera::Status* temp = _impl_.camera_status_;
  _impl_.camera_status_ = nullptr;
  return temp;
}
inline ::mavsdk::rpc::camera::Status* StatusResponse::_internal_mutable_camera_status() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.camera_status_ == nullptr) {
    auto* p = CreateMaybeMessage<::mavsdk::rpc::camera::Status>(GetArenaForAllocation());
    _impl_.camera_status_ = p;
  }
  return _impl_.camera_status_;
}
inline ::mavsdk::rpc::camera::Status* StatusResponse::mutable_camera_status() {
  ::mavsdk::rpc::camera::Status* _msg = _internal_mutable_camera_status();
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.camera.StatusResponse.camera_status)
  return _msg;
}
inline void StatusResponse::set_allocated_camera_status(::mavsdk::rpc::camera::Status* camera_status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.camera_status_;
  }
  if (camera_status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(camera_status);
    if (message_arena != submessage_arena) {
      camera_status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, camera_status, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.camera_status_ = camera_status;
  // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.camera.StatusResponse.camera_status)
}

// -------------------------------------------------------------------

// SubscribeCurrentSettingsRequest

// -------------------------------------------------------------------

// CurrentSettingsResponse

// repeated .mavsdk.rpc.camera.Setting current_settings = 1;
inline int CurrentSettingsResponse::_internal_current_settings_size() const {
  return _impl_.current_settings_.size();
}
inline int CurrentSettingsResponse::current_settings_size() const {
  return _internal_current_settings_size();
}
inline void CurrentSettingsResponse::clear_current_settings() {
  _internal_mutable_current_settings()->Clear();
}
inline ::mavsdk::rpc::camera::Setting* CurrentSettingsResponse::mutable_current_settings(int index) {
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.camera.CurrentSettingsResponse.current_settings)
  return _internal_mutable_current_settings()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mavsdk::rpc::camera::Setting >*
CurrentSettingsResponse::mutable_current_settings() {
  // @@protoc_insertion_point(field_mutable_list:mavsdk.rpc.camera.CurrentSettingsResponse.current_settings)
  return _internal_mutable_current_settings();
}
inline const ::mavsdk::rpc::camera::Setting& CurrentSettingsResponse::_internal_current_settings(int index) const {
  return _internal_current_settings().Get(index);
}
inline const ::mavsdk::rpc::camera::Setting& CurrentSettingsResponse::current_settings(int index) const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera.CurrentSettingsResponse.current_settings)
  return _internal_current_settings(index);
}
inline ::mavsdk::rpc::camera::Setting* CurrentSettingsResponse::_internal_add_current_settings() {
  return _internal_mutable_current_settings()->Add();
}
inline ::mavsdk::rpc::camera::Setting* CurrentSettingsResponse::add_current_settings() {
  ::mavsdk::rpc::camera::Setting* _add = _internal_add_current_settings();
  // @@protoc_insertion_point(field_add:mavsdk.rpc.camera.CurrentSettingsResponse.current_settings)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mavsdk::rpc::camera::Setting >&
CurrentSettingsResponse::current_settings() const {
  // @@protoc_insertion_point(field_list:mavsdk.rpc.camera.CurrentSettingsResponse.current_settings)
  return _internal_current_settings();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::mavsdk::rpc::camera::Setting>&
CurrentSettingsResponse::_internal_current_settings() const {
  return _impl_.current_settings_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::mavsdk::rpc::camera::Setting>*
CurrentSettingsResponse::_internal_mutable_current_settings() {
  return &_impl_.current_settings_;
}

// -------------------------------------------------------------------

// SubscribePossibleSettingOptionsRequest

// -------------------------------------------------------------------

// PossibleSettingOptionsResponse

// repeated .mavsdk.rpc.camera.SettingOptions setting_options = 1;
inline int PossibleSettingOptionsResponse::_internal_setting_options_size() const {
  return _impl_.setting_options_.size();
}
inline int PossibleSettingOptionsResponse::setting_options_size() const {
  return _internal_setting_options_size();
}
inline void PossibleSettingOptionsResponse::clear_setting_options() {
  _internal_mutable_setting_options()->Clear();
}
inline ::mavsdk::rpc::camera::SettingOptions* PossibleSettingOptionsResponse::mutable_setting_options(int index) {
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.camera.PossibleSettingOptionsResponse.setting_options)
  return _internal_mutable_setting_options()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mavsdk::rpc::camera::SettingOptions >*
PossibleSettingOptionsResponse::mutable_setting_options() {
  // @@protoc_insertion_point(field_mutable_list:mavsdk.rpc.camera.PossibleSettingOptionsResponse.setting_options)
  return _internal_mutable_setting_options();
}
inline const ::mavsdk::rpc::camera::SettingOptions& PossibleSettingOptionsResponse::_internal_setting_options(int index) const {
  return _internal_setting_options().Get(index);
}
inline const ::mavsdk::rpc::camera::SettingOptions& PossibleSettingOptionsResponse::setting_options(int index) const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera.PossibleSettingOptionsResponse.setting_options)
  return _internal_setting_options(index);
}
inline ::mavsdk::rpc::camera::SettingOptions* PossibleSettingOptionsResponse::_internal_add_setting_options() {
  return _internal_mutable_setting_options()->Add();
}
inline ::mavsdk::rpc::camera::SettingOptions* PossibleSettingOptionsResponse::add_setting_options() {
  ::mavsdk::rpc::camera::SettingOptions* _add = _internal_add_setting_options();
  // @@protoc_insertion_point(field_add:mavsdk.rpc.camera.PossibleSettingOptionsResponse.setting_options)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mavsdk::rpc::camera::SettingOptions >&
PossibleSettingOptionsResponse::setting_options() const {
  // @@protoc_insertion_point(field_list:mavsdk.rpc.camera.PossibleSettingOptionsResponse.setting_options)
  return _internal_setting_options();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::mavsdk::rpc::camera::SettingOptions>&
PossibleSettingOptionsResponse::_internal_setting_options() const {
  return _impl_.setting_options_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::mavsdk::rpc::camera::SettingOptions>*
PossibleSettingOptionsResponse::_internal_mutable_setting_options() {
  return &_impl_.setting_options_;
}

// -------------------------------------------------------------------

// SetSettingRequest

// .mavsdk.rpc.camera.Setting setting = 1;
inline bool SetSettingRequest::has_setting() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.setting_ != nullptr);
  return value;
}
inline void SetSettingRequest::clear_setting() {
  if (_impl_.setting_ != nullptr) _impl_.setting_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::mavsdk::rpc::camera::Setting& SetSettingRequest::_internal_setting() const {
  const ::mavsdk::rpc::camera::Setting* p = _impl_.setting_;
  return p != nullptr ? *p : reinterpret_cast<const ::mavsdk::rpc::camera::Setting&>(
      ::mavsdk::rpc::camera::_Setting_default_instance_);
}
inline const ::mavsdk::rpc::camera::Setting& SetSettingRequest::setting() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera.SetSettingRequest.setting)
  return _internal_setting();
}
inline void SetSettingRequest::unsafe_arena_set_allocated_setting(
    ::mavsdk::rpc::camera::Setting* setting) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.setting_);
  }
  _impl_.setting_ = setting;
  if (setting) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mavsdk.rpc.camera.SetSettingRequest.setting)
}
inline ::mavsdk::rpc::camera::Setting* SetSettingRequest::release_setting() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::mavsdk::rpc::camera::Setting* temp = _impl_.setting_;
  _impl_.setting_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mavsdk::rpc::camera::Setting* SetSettingRequest::unsafe_arena_release_setting() {
  // @@protoc_insertion_point(field_release:mavsdk.rpc.camera.SetSettingRequest.setting)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::mavsdk::rpc::camera::Setting* temp = _impl_.setting_;
  _impl_.setting_ = nullptr;
  return temp;
}
inline ::mavsdk::rpc::camera::Setting* SetSettingRequest::_internal_mutable_setting() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.setting_ == nullptr) {
    auto* p = CreateMaybeMessage<::mavsdk::rpc::camera::Setting>(GetArenaForAllocation());
    _impl_.setting_ = p;
  }
  return _impl_.setting_;
}
inline ::mavsdk::rpc::camera::Setting* SetSettingRequest::mutable_setting() {
  ::mavsdk::rpc::camera::Setting* _msg = _internal_mutable_setting();
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.camera.SetSettingRequest.setting)
  return _msg;
}
inline void SetSettingRequest::set_allocated_setting(::mavsdk::rpc::camera::Setting* setting) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.setting_;
  }
  if (setting) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(setting);
    if (message_arena != submessage_arena) {
      setting = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, setting, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.setting_ = setting;
  // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.camera.SetSettingRequest.setting)
}

// -------------------------------------------------------------------

// SetSettingResponse

// .mavsdk.rpc.camera.CameraResult camera_result = 1;
inline bool SetSettingResponse::has_camera_result() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.camera_result_ != nullptr);
  return value;
}
inline void SetSettingResponse::clear_camera_result() {
  if (_impl_.camera_result_ != nullptr) _impl_.camera_result_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::mavsdk::rpc::camera::CameraResult& SetSettingResponse::_internal_camera_result() const {
  const ::mavsdk::rpc::camera::CameraResult* p = _impl_.camera_result_;
  return p != nullptr ? *p : reinterpret_cast<const ::mavsdk::rpc::camera::CameraResult&>(
      ::mavsdk::rpc::camera::_CameraResult_default_instance_);
}
inline const ::mavsdk::rpc::camera::CameraResult& SetSettingResponse::camera_result() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera.SetSettingResponse.camera_result)
  return _internal_camera_result();
}
inline void SetSettingResponse::unsafe_arena_set_allocated_camera_result(
    ::mavsdk::rpc::camera::CameraResult* camera_result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.camera_result_);
  }
  _impl_.camera_result_ = camera_result;
  if (camera_result) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mavsdk.rpc.camera.SetSettingResponse.camera_result)
}
inline ::mavsdk::rpc::camera::CameraResult* SetSettingResponse::release_camera_result() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::mavsdk::rpc::camera::CameraResult* temp = _impl_.camera_result_;
  _impl_.camera_result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mavsdk::rpc::camera::CameraResult* SetSettingResponse::unsafe_arena_release_camera_result() {
  // @@protoc_insertion_point(field_release:mavsdk.rpc.camera.SetSettingResponse.camera_result)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::mavsdk::rpc::camera::CameraResult* temp = _impl_.camera_result_;
  _impl_.camera_result_ = nullptr;
  return temp;
}
inline ::mavsdk::rpc::camera::CameraResult* SetSettingResponse::_internal_mutable_camera_result() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.camera_result_ == nullptr) {
    auto* p = CreateMaybeMessage<::mavsdk::rpc::camera::CameraResult>(GetArenaForAllocation());
    _impl_.camera_result_ = p;
  }
  return _impl_.camera_result_;
}
inline ::mavsdk::rpc::camera::CameraResult* SetSettingResponse::mutable_camera_result() {
  ::mavsdk::rpc::camera::CameraResult* _msg = _internal_mutable_camera_result();
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.camera.SetSettingResponse.camera_result)
  return _msg;
}
inline void SetSettingResponse::set_allocated_camera_result(::mavsdk::rpc::camera::CameraResult* camera_result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.camera_result_;
  }
  if (camera_result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(camera_result);
    if (message_arena != submessage_arena) {
      camera_result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, camera_result, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.camera_result_ = camera_result;
  // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.camera.SetSettingResponse.camera_result)
}

// -------------------------------------------------------------------

// GetSettingRequest

// .mavsdk.rpc.camera.Setting setting = 1;
inline bool GetSettingRequest::has_setting() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.setting_ != nullptr);
  return value;
}
inline void GetSettingRequest::clear_setting() {
  if (_impl_.setting_ != nullptr) _impl_.setting_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::mavsdk::rpc::camera::Setting& GetSettingRequest::_internal_setting() const {
  const ::mavsdk::rpc::camera::Setting* p = _impl_.setting_;
  return p != nullptr ? *p : reinterpret_cast<const ::mavsdk::rpc::camera::Setting&>(
      ::mavsdk::rpc::camera::_Setting_default_instance_);
}
inline const ::mavsdk::rpc::camera::Setting& GetSettingRequest::setting() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera.GetSettingRequest.setting)
  return _internal_setting();
}
inline void GetSettingRequest::unsafe_arena_set_allocated_setting(
    ::mavsdk::rpc::camera::Setting* setting) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.setting_);
  }
  _impl_.setting_ = setting;
  if (setting) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mavsdk.rpc.camera.GetSettingRequest.setting)
}
inline ::mavsdk::rpc::camera::Setting* GetSettingRequest::release_setting() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::mavsdk::rpc::camera::Setting* temp = _impl_.setting_;
  _impl_.setting_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mavsdk::rpc::camera::Setting* GetSettingRequest::unsafe_arena_release_setting() {
  // @@protoc_insertion_point(field_release:mavsdk.rpc.camera.GetSettingRequest.setting)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::mavsdk::rpc::camera::Setting* temp = _impl_.setting_;
  _impl_.setting_ = nullptr;
  return temp;
}
inline ::mavsdk::rpc::camera::Setting* GetSettingRequest::_internal_mutable_setting() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.setting_ == nullptr) {
    auto* p = CreateMaybeMessage<::mavsdk::rpc::camera::Setting>(GetArenaForAllocation());
    _impl_.setting_ = p;
  }
  return _impl_.setting_;
}
inline ::mavsdk::rpc::camera::Setting* GetSettingRequest::mutable_setting() {
  ::mavsdk::rpc::camera::Setting* _msg = _internal_mutable_setting();
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.camera.GetSettingRequest.setting)
  return _msg;
}
inline void GetSettingRequest::set_allocated_setting(::mavsdk::rpc::camera::Setting* setting) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.setting_;
  }
  if (setting) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(setting);
    if (message_arena != submessage_arena) {
      setting = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, setting, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.setting_ = setting;
  // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.camera.GetSettingRequest.setting)
}

// -------------------------------------------------------------------

// GetSettingResponse

// .mavsdk.rpc.camera.CameraResult camera_result = 1;
inline bool GetSettingResponse::has_camera_result() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.camera_result_ != nullptr);
  return value;
}
inline void GetSettingResponse::clear_camera_result() {
  if (_impl_.camera_result_ != nullptr) _impl_.camera_result_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::mavsdk::rpc::camera::CameraResult& GetSettingResponse::_internal_camera_result() const {
  const ::mavsdk::rpc::camera::CameraResult* p = _impl_.camera_result_;
  return p != nullptr ? *p : reinterpret_cast<const ::mavsdk::rpc::camera::CameraResult&>(
      ::mavsdk::rpc::camera::_CameraResult_default_instance_);
}
inline const ::mavsdk::rpc::camera::CameraResult& GetSettingResponse::camera_result() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera.GetSettingResponse.camera_result)
  return _internal_camera_result();
}
inline void GetSettingResponse::unsafe_arena_set_allocated_camera_result(
    ::mavsdk::rpc::camera::CameraResult* camera_result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.camera_result_);
  }
  _impl_.camera_result_ = camera_result;
  if (camera_result) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mavsdk.rpc.camera.GetSettingResponse.camera_result)
}
inline ::mavsdk::rpc::camera::CameraResult* GetSettingResponse::release_camera_result() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::mavsdk::rpc::camera::CameraResult* temp = _impl_.camera_result_;
  _impl_.camera_result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mavsdk::rpc::camera::CameraResult* GetSettingResponse::unsafe_arena_release_camera_result() {
  // @@protoc_insertion_point(field_release:mavsdk.rpc.camera.GetSettingResponse.camera_result)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::mavsdk::rpc::camera::CameraResult* temp = _impl_.camera_result_;
  _impl_.camera_result_ = nullptr;
  return temp;
}
inline ::mavsdk::rpc::camera::CameraResult* GetSettingResponse::_internal_mutable_camera_result() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.camera_result_ == nullptr) {
    auto* p = CreateMaybeMessage<::mavsdk::rpc::camera::CameraResult>(GetArenaForAllocation());
    _impl_.camera_result_ = p;
  }
  return _impl_.camera_result_;
}
inline ::mavsdk::rpc::camera::CameraResult* GetSettingResponse::mutable_camera_result() {
  ::mavsdk::rpc::camera::CameraResult* _msg = _internal_mutable_camera_result();
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.camera.GetSettingResponse.camera_result)
  return _msg;
}
inline void GetSettingResponse::set_allocated_camera_result(::mavsdk::rpc::camera::CameraResult* camera_result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.camera_result_;
  }
  if (camera_result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(camera_result);
    if (message_arena != submessage_arena) {
      camera_result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, camera_result, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.camera_result_ = camera_result;
  // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.camera.GetSettingResponse.camera_result)
}

// .mavsdk.rpc.camera.Setting setting = 2;
inline bool GetSettingResponse::has_setting() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.setting_ != nullptr);
  return value;
}
inline void GetSettingResponse::clear_setting() {
  if (_impl_.setting_ != nullptr) _impl_.setting_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::mavsdk::rpc::camera::Setting& GetSettingResponse::_internal_setting() const {
  const ::mavsdk::rpc::camera::Setting* p = _impl_.setting_;
  return p != nullptr ? *p : reinterpret_cast<const ::mavsdk::rpc::camera::Setting&>(
      ::mavsdk::rpc::camera::_Setting_default_instance_);
}
inline const ::mavsdk::rpc::camera::Setting& GetSettingResponse::setting() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera.GetSettingResponse.setting)
  return _internal_setting();
}
inline void GetSettingResponse::unsafe_arena_set_allocated_setting(
    ::mavsdk::rpc::camera::Setting* setting) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.setting_);
  }
  _impl_.setting_ = setting;
  if (setting) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mavsdk.rpc.camera.GetSettingResponse.setting)
}
inline ::mavsdk::rpc::camera::Setting* GetSettingResponse::release_setting() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::mavsdk::rpc::camera::Setting* temp = _impl_.setting_;
  _impl_.setting_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mavsdk::rpc::camera::Setting* GetSettingResponse::unsafe_arena_release_setting() {
  // @@protoc_insertion_point(field_release:mavsdk.rpc.camera.GetSettingResponse.setting)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::mavsdk::rpc::camera::Setting* temp = _impl_.setting_;
  _impl_.setting_ = nullptr;
  return temp;
}
inline ::mavsdk::rpc::camera::Setting* GetSettingResponse::_internal_mutable_setting() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.setting_ == nullptr) {
    auto* p = CreateMaybeMessage<::mavsdk::rpc::camera::Setting>(GetArenaForAllocation());
    _impl_.setting_ = p;
  }
  return _impl_.setting_;
}
inline ::mavsdk::rpc::camera::Setting* GetSettingResponse::mutable_setting() {
  ::mavsdk::rpc::camera::Setting* _msg = _internal_mutable_setting();
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.camera.GetSettingResponse.setting)
  return _msg;
}
inline void GetSettingResponse::set_allocated_setting(::mavsdk::rpc::camera::Setting* setting) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.setting_;
  }
  if (setting) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(setting);
    if (message_arena != submessage_arena) {
      setting = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, setting, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.setting_ = setting;
  // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.camera.GetSettingResponse.setting)
}

// -------------------------------------------------------------------

// FormatStorageRequest

// -------------------------------------------------------------------

// FormatStorageResponse

// .mavsdk.rpc.camera.CameraResult camera_result = 1;
inline bool FormatStorageResponse::has_camera_result() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.camera_result_ != nullptr);
  return value;
}
inline void FormatStorageResponse::clear_camera_result() {
  if (_impl_.camera_result_ != nullptr) _impl_.camera_result_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::mavsdk::rpc::camera::CameraResult& FormatStorageResponse::_internal_camera_result() const {
  const ::mavsdk::rpc::camera::CameraResult* p = _impl_.camera_result_;
  return p != nullptr ? *p : reinterpret_cast<const ::mavsdk::rpc::camera::CameraResult&>(
      ::mavsdk::rpc::camera::_CameraResult_default_instance_);
}
inline const ::mavsdk::rpc::camera::CameraResult& FormatStorageResponse::camera_result() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera.FormatStorageResponse.camera_result)
  return _internal_camera_result();
}
inline void FormatStorageResponse::unsafe_arena_set_allocated_camera_result(
    ::mavsdk::rpc::camera::CameraResult* camera_result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.camera_result_);
  }
  _impl_.camera_result_ = camera_result;
  if (camera_result) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mavsdk.rpc.camera.FormatStorageResponse.camera_result)
}
inline ::mavsdk::rpc::camera::CameraResult* FormatStorageResponse::release_camera_result() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::mavsdk::rpc::camera::CameraResult* temp = _impl_.camera_result_;
  _impl_.camera_result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mavsdk::rpc::camera::CameraResult* FormatStorageResponse::unsafe_arena_release_camera_result() {
  // @@protoc_insertion_point(field_release:mavsdk.rpc.camera.FormatStorageResponse.camera_result)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::mavsdk::rpc::camera::CameraResult* temp = _impl_.camera_result_;
  _impl_.camera_result_ = nullptr;
  return temp;
}
inline ::mavsdk::rpc::camera::CameraResult* FormatStorageResponse::_internal_mutable_camera_result() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.camera_result_ == nullptr) {
    auto* p = CreateMaybeMessage<::mavsdk::rpc::camera::CameraResult>(GetArenaForAllocation());
    _impl_.camera_result_ = p;
  }
  return _impl_.camera_result_;
}
inline ::mavsdk::rpc::camera::CameraResult* FormatStorageResponse::mutable_camera_result() {
  ::mavsdk::rpc::camera::CameraResult* _msg = _internal_mutable_camera_result();
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.camera.FormatStorageResponse.camera_result)
  return _msg;
}
inline void FormatStorageResponse::set_allocated_camera_result(::mavsdk::rpc::camera::CameraResult* camera_result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.camera_result_;
  }
  if (camera_result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(camera_result);
    if (message_arena != submessage_arena) {
      camera_result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, camera_result, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.camera_result_ = camera_result;
  // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.camera.FormatStorageResponse.camera_result)
}

// -------------------------------------------------------------------

// SelectCameraResponse

// .mavsdk.rpc.camera.CameraResult camera_result = 1;
inline bool SelectCameraResponse::has_camera_result() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.camera_result_ != nullptr);
  return value;
}
inline void SelectCameraResponse::clear_camera_result() {
  if (_impl_.camera_result_ != nullptr) _impl_.camera_result_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::mavsdk::rpc::camera::CameraResult& SelectCameraResponse::_internal_camera_result() const {
  const ::mavsdk::rpc::camera::CameraResult* p = _impl_.camera_result_;
  return p != nullptr ? *p : reinterpret_cast<const ::mavsdk::rpc::camera::CameraResult&>(
      ::mavsdk::rpc::camera::_CameraResult_default_instance_);
}
inline const ::mavsdk::rpc::camera::CameraResult& SelectCameraResponse::camera_result() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera.SelectCameraResponse.camera_result)
  return _internal_camera_result();
}
inline void SelectCameraResponse::unsafe_arena_set_allocated_camera_result(
    ::mavsdk::rpc::camera::CameraResult* camera_result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.camera_result_);
  }
  _impl_.camera_result_ = camera_result;
  if (camera_result) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mavsdk.rpc.camera.SelectCameraResponse.camera_result)
}
inline ::mavsdk::rpc::camera::CameraResult* SelectCameraResponse::release_camera_result() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::mavsdk::rpc::camera::CameraResult* temp = _impl_.camera_result_;
  _impl_.camera_result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mavsdk::rpc::camera::CameraResult* SelectCameraResponse::unsafe_arena_release_camera_result() {
  // @@protoc_insertion_point(field_release:mavsdk.rpc.camera.SelectCameraResponse.camera_result)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::mavsdk::rpc::camera::CameraResult* temp = _impl_.camera_result_;
  _impl_.camera_result_ = nullptr;
  return temp;
}
inline ::mavsdk::rpc::camera::CameraResult* SelectCameraResponse::_internal_mutable_camera_result() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.camera_result_ == nullptr) {
    auto* p = CreateMaybeMessage<::mavsdk::rpc::camera::CameraResult>(GetArenaForAllocation());
    _impl_.camera_result_ = p;
  }
  return _impl_.camera_result_;
}
inline ::mavsdk::rpc::camera::CameraResult* SelectCameraResponse::mutable_camera_result() {
  ::mavsdk::rpc::camera::CameraResult* _msg = _internal_mutable_camera_result();
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.camera.SelectCameraResponse.camera_result)
  return _msg;
}
inline void SelectCameraResponse::set_allocated_camera_result(::mavsdk::rpc::camera::CameraResult* camera_result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.camera_result_;
  }
  if (camera_result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(camera_result);
    if (message_arena != submessage_arena) {
      camera_result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, camera_result, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.camera_result_ = camera_result;
  // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.camera.SelectCameraResponse.camera_result)
}

// -------------------------------------------------------------------

// SelectCameraRequest

// int32 camera_id = 1;
inline void SelectCameraRequest::clear_camera_id() {
  _impl_.camera_id_ = 0;
}
inline ::int32_t SelectCameraRequest::camera_id() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera.SelectCameraRequest.camera_id)
  return _internal_camera_id();
}
inline void SelectCameraRequest::set_camera_id(::int32_t value) {
  _internal_set_camera_id(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera.SelectCameraRequest.camera_id)
}
inline ::int32_t SelectCameraRequest::_internal_camera_id() const {
  return _impl_.camera_id_;
}
inline void SelectCameraRequest::_internal_set_camera_id(::int32_t value) {
  ;
  _impl_.camera_id_ = value;
}

// -------------------------------------------------------------------

// CameraResult

// .mavsdk.rpc.camera.CameraResult.Result result = 1;
inline void CameraResult::clear_result() {
  _impl_.result_ = 0;
}
inline ::mavsdk::rpc::camera::CameraResult_Result CameraResult::result() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera.CameraResult.result)
  return _internal_result();
}
inline void CameraResult::set_result(::mavsdk::rpc::camera::CameraResult_Result value) {
   _internal_set_result(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera.CameraResult.result)
}
inline ::mavsdk::rpc::camera::CameraResult_Result CameraResult::_internal_result() const {
  return static_cast<::mavsdk::rpc::camera::CameraResult_Result>(_impl_.result_);
}
inline void CameraResult::_internal_set_result(::mavsdk::rpc::camera::CameraResult_Result value) {
  ;
  _impl_.result_ = value;
}

// string result_str = 2;
inline void CameraResult::clear_result_str() {
  _impl_.result_str_.ClearToEmpty();
}
inline const std::string& CameraResult::result_str() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera.CameraResult.result_str)
  return _internal_result_str();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CameraResult::set_result_str(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.result_str_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera.CameraResult.result_str)
}
inline std::string* CameraResult::mutable_result_str() {
  std::string* _s = _internal_mutable_result_str();
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.camera.CameraResult.result_str)
  return _s;
}
inline const std::string& CameraResult::_internal_result_str() const {
  return _impl_.result_str_.Get();
}
inline void CameraResult::_internal_set_result_str(const std::string& value) {
  ;


  _impl_.result_str_.Set(value, GetArenaForAllocation());
}
inline std::string* CameraResult::_internal_mutable_result_str() {
  ;
  return _impl_.result_str_.Mutable( GetArenaForAllocation());
}
inline std::string* CameraResult::release_result_str() {
  // @@protoc_insertion_point(field_release:mavsdk.rpc.camera.CameraResult.result_str)
  return _impl_.result_str_.Release();
}
inline void CameraResult::set_allocated_result_str(std::string* value) {
  _impl_.result_str_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.result_str_.IsDefault()) {
          _impl_.result_str_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.camera.CameraResult.result_str)
}

// -------------------------------------------------------------------

// Position

// double latitude_deg = 1;
inline void Position::clear_latitude_deg() {
  _impl_.latitude_deg_ = 0;
}
inline double Position::latitude_deg() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera.Position.latitude_deg)
  return _internal_latitude_deg();
}
inline void Position::set_latitude_deg(double value) {
  _internal_set_latitude_deg(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera.Position.latitude_deg)
}
inline double Position::_internal_latitude_deg() const {
  return _impl_.latitude_deg_;
}
inline void Position::_internal_set_latitude_deg(double value) {
  ;
  _impl_.latitude_deg_ = value;
}

// double longitude_deg = 2;
inline void Position::clear_longitude_deg() {
  _impl_.longitude_deg_ = 0;
}
inline double Position::longitude_deg() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera.Position.longitude_deg)
  return _internal_longitude_deg();
}
inline void Position::set_longitude_deg(double value) {
  _internal_set_longitude_deg(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera.Position.longitude_deg)
}
inline double Position::_internal_longitude_deg() const {
  return _impl_.longitude_deg_;
}
inline void Position::_internal_set_longitude_deg(double value) {
  ;
  _impl_.longitude_deg_ = value;
}

// float absolute_altitude_m = 3;
inline void Position::clear_absolute_altitude_m() {
  _impl_.absolute_altitude_m_ = 0;
}
inline float Position::absolute_altitude_m() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera.Position.absolute_altitude_m)
  return _internal_absolute_altitude_m();
}
inline void Position::set_absolute_altitude_m(float value) {
  _internal_set_absolute_altitude_m(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera.Position.absolute_altitude_m)
}
inline float Position::_internal_absolute_altitude_m() const {
  return _impl_.absolute_altitude_m_;
}
inline void Position::_internal_set_absolute_altitude_m(float value) {
  ;
  _impl_.absolute_altitude_m_ = value;
}

// float relative_altitude_m = 4;
inline void Position::clear_relative_altitude_m() {
  _impl_.relative_altitude_m_ = 0;
}
inline float Position::relative_altitude_m() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera.Position.relative_altitude_m)
  return _internal_relative_altitude_m();
}
inline void Position::set_relative_altitude_m(float value) {
  _internal_set_relative_altitude_m(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera.Position.relative_altitude_m)
}
inline float Position::_internal_relative_altitude_m() const {
  return _impl_.relative_altitude_m_;
}
inline void Position::_internal_set_relative_altitude_m(float value) {
  ;
  _impl_.relative_altitude_m_ = value;
}

// -------------------------------------------------------------------

// Quaternion

// float w = 1;
inline void Quaternion::clear_w() {
  _impl_.w_ = 0;
}
inline float Quaternion::w() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera.Quaternion.w)
  return _internal_w();
}
inline void Quaternion::set_w(float value) {
  _internal_set_w(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera.Quaternion.w)
}
inline float Quaternion::_internal_w() const {
  return _impl_.w_;
}
inline void Quaternion::_internal_set_w(float value) {
  ;
  _impl_.w_ = value;
}

// float x = 2;
inline void Quaternion::clear_x() {
  _impl_.x_ = 0;
}
inline float Quaternion::x() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera.Quaternion.x)
  return _internal_x();
}
inline void Quaternion::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera.Quaternion.x)
}
inline float Quaternion::_internal_x() const {
  return _impl_.x_;
}
inline void Quaternion::_internal_set_x(float value) {
  ;
  _impl_.x_ = value;
}

// float y = 3;
inline void Quaternion::clear_y() {
  _impl_.y_ = 0;
}
inline float Quaternion::y() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera.Quaternion.y)
  return _internal_y();
}
inline void Quaternion::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera.Quaternion.y)
}
inline float Quaternion::_internal_y() const {
  return _impl_.y_;
}
inline void Quaternion::_internal_set_y(float value) {
  ;
  _impl_.y_ = value;
}

// float z = 4;
inline void Quaternion::clear_z() {
  _impl_.z_ = 0;
}
inline float Quaternion::z() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera.Quaternion.z)
  return _internal_z();
}
inline void Quaternion::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera.Quaternion.z)
}
inline float Quaternion::_internal_z() const {
  return _impl_.z_;
}
inline void Quaternion::_internal_set_z(float value) {
  ;
  _impl_.z_ = value;
}

// -------------------------------------------------------------------

// EulerAngle

// float roll_deg = 1;
inline void EulerAngle::clear_roll_deg() {
  _impl_.roll_deg_ = 0;
}
inline float EulerAngle::roll_deg() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera.EulerAngle.roll_deg)
  return _internal_roll_deg();
}
inline void EulerAngle::set_roll_deg(float value) {
  _internal_set_roll_deg(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera.EulerAngle.roll_deg)
}
inline float EulerAngle::_internal_roll_deg() const {
  return _impl_.roll_deg_;
}
inline void EulerAngle::_internal_set_roll_deg(float value) {
  ;
  _impl_.roll_deg_ = value;
}

// float pitch_deg = 2;
inline void EulerAngle::clear_pitch_deg() {
  _impl_.pitch_deg_ = 0;
}
inline float EulerAngle::pitch_deg() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera.EulerAngle.pitch_deg)
  return _internal_pitch_deg();
}
inline void EulerAngle::set_pitch_deg(float value) {
  _internal_set_pitch_deg(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera.EulerAngle.pitch_deg)
}
inline float EulerAngle::_internal_pitch_deg() const {
  return _impl_.pitch_deg_;
}
inline void EulerAngle::_internal_set_pitch_deg(float value) {
  ;
  _impl_.pitch_deg_ = value;
}

// float yaw_deg = 3;
inline void EulerAngle::clear_yaw_deg() {
  _impl_.yaw_deg_ = 0;
}
inline float EulerAngle::yaw_deg() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera.EulerAngle.yaw_deg)
  return _internal_yaw_deg();
}
inline void EulerAngle::set_yaw_deg(float value) {
  _internal_set_yaw_deg(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera.EulerAngle.yaw_deg)
}
inline float EulerAngle::_internal_yaw_deg() const {
  return _impl_.yaw_deg_;
}
inline void EulerAngle::_internal_set_yaw_deg(float value) {
  ;
  _impl_.yaw_deg_ = value;
}

// -------------------------------------------------------------------

// CaptureInfo

// .mavsdk.rpc.camera.Position position = 1;
inline bool CaptureInfo::has_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.position_ != nullptr);
  return value;
}
inline void CaptureInfo::clear_position() {
  if (_impl_.position_ != nullptr) _impl_.position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::mavsdk::rpc::camera::Position& CaptureInfo::_internal_position() const {
  const ::mavsdk::rpc::camera::Position* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::mavsdk::rpc::camera::Position&>(
      ::mavsdk::rpc::camera::_Position_default_instance_);
}
inline const ::mavsdk::rpc::camera::Position& CaptureInfo::position() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera.CaptureInfo.position)
  return _internal_position();
}
inline void CaptureInfo::unsafe_arena_set_allocated_position(
    ::mavsdk::rpc::camera::Position* position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = position;
  if (position) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mavsdk.rpc.camera.CaptureInfo.position)
}
inline ::mavsdk::rpc::camera::Position* CaptureInfo::release_position() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::mavsdk::rpc::camera::Position* temp = _impl_.position_;
  _impl_.position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mavsdk::rpc::camera::Position* CaptureInfo::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:mavsdk.rpc.camera.CaptureInfo.position)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::mavsdk::rpc::camera::Position* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::mavsdk::rpc::camera::Position* CaptureInfo::_internal_mutable_position() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.position_ == nullptr) {
    auto* p = CreateMaybeMessage<::mavsdk::rpc::camera::Position>(GetArenaForAllocation());
    _impl_.position_ = p;
  }
  return _impl_.position_;
}
inline ::mavsdk::rpc::camera::Position* CaptureInfo::mutable_position() {
  ::mavsdk::rpc::camera::Position* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.camera.CaptureInfo.position)
  return _msg;
}
inline void CaptureInfo::set_allocated_position(::mavsdk::rpc::camera::Position* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.position_;
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(position);
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.position_ = position;
  // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.camera.CaptureInfo.position)
}

// .mavsdk.rpc.camera.Quaternion attitude_quaternion = 2;
inline bool CaptureInfo::has_attitude_quaternion() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.attitude_quaternion_ != nullptr);
  return value;
}
inline void CaptureInfo::clear_attitude_quaternion() {
  if (_impl_.attitude_quaternion_ != nullptr) _impl_.attitude_quaternion_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::mavsdk::rpc::camera::Quaternion& CaptureInfo::_internal_attitude_quaternion() const {
  const ::mavsdk::rpc::camera::Quaternion* p = _impl_.attitude_quaternion_;
  return p != nullptr ? *p : reinterpret_cast<const ::mavsdk::rpc::camera::Quaternion&>(
      ::mavsdk::rpc::camera::_Quaternion_default_instance_);
}
inline const ::mavsdk::rpc::camera::Quaternion& CaptureInfo::attitude_quaternion() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera.CaptureInfo.attitude_quaternion)
  return _internal_attitude_quaternion();
}
inline void CaptureInfo::unsafe_arena_set_allocated_attitude_quaternion(
    ::mavsdk::rpc::camera::Quaternion* attitude_quaternion) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.attitude_quaternion_);
  }
  _impl_.attitude_quaternion_ = attitude_quaternion;
  if (attitude_quaternion) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mavsdk.rpc.camera.CaptureInfo.attitude_quaternion)
}
inline ::mavsdk::rpc::camera::Quaternion* CaptureInfo::release_attitude_quaternion() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::mavsdk::rpc::camera::Quaternion* temp = _impl_.attitude_quaternion_;
  _impl_.attitude_quaternion_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mavsdk::rpc::camera::Quaternion* CaptureInfo::unsafe_arena_release_attitude_quaternion() {
  // @@protoc_insertion_point(field_release:mavsdk.rpc.camera.CaptureInfo.attitude_quaternion)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::mavsdk::rpc::camera::Quaternion* temp = _impl_.attitude_quaternion_;
  _impl_.attitude_quaternion_ = nullptr;
  return temp;
}
inline ::mavsdk::rpc::camera::Quaternion* CaptureInfo::_internal_mutable_attitude_quaternion() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.attitude_quaternion_ == nullptr) {
    auto* p = CreateMaybeMessage<::mavsdk::rpc::camera::Quaternion>(GetArenaForAllocation());
    _impl_.attitude_quaternion_ = p;
  }
  return _impl_.attitude_quaternion_;
}
inline ::mavsdk::rpc::camera::Quaternion* CaptureInfo::mutable_attitude_quaternion() {
  ::mavsdk::rpc::camera::Quaternion* _msg = _internal_mutable_attitude_quaternion();
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.camera.CaptureInfo.attitude_quaternion)
  return _msg;
}
inline void CaptureInfo::set_allocated_attitude_quaternion(::mavsdk::rpc::camera::Quaternion* attitude_quaternion) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.attitude_quaternion_;
  }
  if (attitude_quaternion) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(attitude_quaternion);
    if (message_arena != submessage_arena) {
      attitude_quaternion = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, attitude_quaternion, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.attitude_quaternion_ = attitude_quaternion;
  // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.camera.CaptureInfo.attitude_quaternion)
}

// .mavsdk.rpc.camera.EulerAngle attitude_euler_angle = 3;
inline bool CaptureInfo::has_attitude_euler_angle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.attitude_euler_angle_ != nullptr);
  return value;
}
inline void CaptureInfo::clear_attitude_euler_angle() {
  if (_impl_.attitude_euler_angle_ != nullptr) _impl_.attitude_euler_angle_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::mavsdk::rpc::camera::EulerAngle& CaptureInfo::_internal_attitude_euler_angle() const {
  const ::mavsdk::rpc::camera::EulerAngle* p = _impl_.attitude_euler_angle_;
  return p != nullptr ? *p : reinterpret_cast<const ::mavsdk::rpc::camera::EulerAngle&>(
      ::mavsdk::rpc::camera::_EulerAngle_default_instance_);
}
inline const ::mavsdk::rpc::camera::EulerAngle& CaptureInfo::attitude_euler_angle() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera.CaptureInfo.attitude_euler_angle)
  return _internal_attitude_euler_angle();
}
inline void CaptureInfo::unsafe_arena_set_allocated_attitude_euler_angle(
    ::mavsdk::rpc::camera::EulerAngle* attitude_euler_angle) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.attitude_euler_angle_);
  }
  _impl_.attitude_euler_angle_ = attitude_euler_angle;
  if (attitude_euler_angle) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mavsdk.rpc.camera.CaptureInfo.attitude_euler_angle)
}
inline ::mavsdk::rpc::camera::EulerAngle* CaptureInfo::release_attitude_euler_angle() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::mavsdk::rpc::camera::EulerAngle* temp = _impl_.attitude_euler_angle_;
  _impl_.attitude_euler_angle_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mavsdk::rpc::camera::EulerAngle* CaptureInfo::unsafe_arena_release_attitude_euler_angle() {
  // @@protoc_insertion_point(field_release:mavsdk.rpc.camera.CaptureInfo.attitude_euler_angle)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::mavsdk::rpc::camera::EulerAngle* temp = _impl_.attitude_euler_angle_;
  _impl_.attitude_euler_angle_ = nullptr;
  return temp;
}
inline ::mavsdk::rpc::camera::EulerAngle* CaptureInfo::_internal_mutable_attitude_euler_angle() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.attitude_euler_angle_ == nullptr) {
    auto* p = CreateMaybeMessage<::mavsdk::rpc::camera::EulerAngle>(GetArenaForAllocation());
    _impl_.attitude_euler_angle_ = p;
  }
  return _impl_.attitude_euler_angle_;
}
inline ::mavsdk::rpc::camera::EulerAngle* CaptureInfo::mutable_attitude_euler_angle() {
  ::mavsdk::rpc::camera::EulerAngle* _msg = _internal_mutable_attitude_euler_angle();
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.camera.CaptureInfo.attitude_euler_angle)
  return _msg;
}
inline void CaptureInfo::set_allocated_attitude_euler_angle(::mavsdk::rpc::camera::EulerAngle* attitude_euler_angle) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.attitude_euler_angle_;
  }
  if (attitude_euler_angle) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(attitude_euler_angle);
    if (message_arena != submessage_arena) {
      attitude_euler_angle = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, attitude_euler_angle, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.attitude_euler_angle_ = attitude_euler_angle;
  // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.camera.CaptureInfo.attitude_euler_angle)
}

// uint64 time_utc_us = 4;
inline void CaptureInfo::clear_time_utc_us() {
  _impl_.time_utc_us_ = ::uint64_t{0u};
}
inline ::uint64_t CaptureInfo::time_utc_us() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera.CaptureInfo.time_utc_us)
  return _internal_time_utc_us();
}
inline void CaptureInfo::set_time_utc_us(::uint64_t value) {
  _internal_set_time_utc_us(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera.CaptureInfo.time_utc_us)
}
inline ::uint64_t CaptureInfo::_internal_time_utc_us() const {
  return _impl_.time_utc_us_;
}
inline void CaptureInfo::_internal_set_time_utc_us(::uint64_t value) {
  ;
  _impl_.time_utc_us_ = value;
}

// bool is_success = 5;
inline void CaptureInfo::clear_is_success() {
  _impl_.is_success_ = false;
}
inline bool CaptureInfo::is_success() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera.CaptureInfo.is_success)
  return _internal_is_success();
}
inline void CaptureInfo::set_is_success(bool value) {
  _internal_set_is_success(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera.CaptureInfo.is_success)
}
inline bool CaptureInfo::_internal_is_success() const {
  return _impl_.is_success_;
}
inline void CaptureInfo::_internal_set_is_success(bool value) {
  ;
  _impl_.is_success_ = value;
}

// int32 index = 6;
inline void CaptureInfo::clear_index() {
  _impl_.index_ = 0;
}
inline ::int32_t CaptureInfo::index() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera.CaptureInfo.index)
  return _internal_index();
}
inline void CaptureInfo::set_index(::int32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera.CaptureInfo.index)
}
inline ::int32_t CaptureInfo::_internal_index() const {
  return _impl_.index_;
}
inline void CaptureInfo::_internal_set_index(::int32_t value) {
  ;
  _impl_.index_ = value;
}

// string file_url = 7;
inline void CaptureInfo::clear_file_url() {
  _impl_.file_url_.ClearToEmpty();
}
inline const std::string& CaptureInfo::file_url() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera.CaptureInfo.file_url)
  return _internal_file_url();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CaptureInfo::set_file_url(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.file_url_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera.CaptureInfo.file_url)
}
inline std::string* CaptureInfo::mutable_file_url() {
  std::string* _s = _internal_mutable_file_url();
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.camera.CaptureInfo.file_url)
  return _s;
}
inline const std::string& CaptureInfo::_internal_file_url() const {
  return _impl_.file_url_.Get();
}
inline void CaptureInfo::_internal_set_file_url(const std::string& value) {
  ;


  _impl_.file_url_.Set(value, GetArenaForAllocation());
}
inline std::string* CaptureInfo::_internal_mutable_file_url() {
  ;
  return _impl_.file_url_.Mutable( GetArenaForAllocation());
}
inline std::string* CaptureInfo::release_file_url() {
  // @@protoc_insertion_point(field_release:mavsdk.rpc.camera.CaptureInfo.file_url)
  return _impl_.file_url_.Release();
}
inline void CaptureInfo::set_allocated_file_url(std::string* value) {
  _impl_.file_url_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.file_url_.IsDefault()) {
          _impl_.file_url_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.camera.CaptureInfo.file_url)
}

// -------------------------------------------------------------------

// VideoStreamSettings

// float frame_rate_hz = 1;
inline void VideoStreamSettings::clear_frame_rate_hz() {
  _impl_.frame_rate_hz_ = 0;
}
inline float VideoStreamSettings::frame_rate_hz() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera.VideoStreamSettings.frame_rate_hz)
  return _internal_frame_rate_hz();
}
inline void VideoStreamSettings::set_frame_rate_hz(float value) {
  _internal_set_frame_rate_hz(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera.VideoStreamSettings.frame_rate_hz)
}
inline float VideoStreamSettings::_internal_frame_rate_hz() const {
  return _impl_.frame_rate_hz_;
}
inline void VideoStreamSettings::_internal_set_frame_rate_hz(float value) {
  ;
  _impl_.frame_rate_hz_ = value;
}

// uint32 horizontal_resolution_pix = 2;
inline void VideoStreamSettings::clear_horizontal_resolution_pix() {
  _impl_.horizontal_resolution_pix_ = 0u;
}
inline ::uint32_t VideoStreamSettings::horizontal_resolution_pix() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera.VideoStreamSettings.horizontal_resolution_pix)
  return _internal_horizontal_resolution_pix();
}
inline void VideoStreamSettings::set_horizontal_resolution_pix(::uint32_t value) {
  _internal_set_horizontal_resolution_pix(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera.VideoStreamSettings.horizontal_resolution_pix)
}
inline ::uint32_t VideoStreamSettings::_internal_horizontal_resolution_pix() const {
  return _impl_.horizontal_resolution_pix_;
}
inline void VideoStreamSettings::_internal_set_horizontal_resolution_pix(::uint32_t value) {
  ;
  _impl_.horizontal_resolution_pix_ = value;
}

// uint32 vertical_resolution_pix = 3;
inline void VideoStreamSettings::clear_vertical_resolution_pix() {
  _impl_.vertical_resolution_pix_ = 0u;
}
inline ::uint32_t VideoStreamSettings::vertical_resolution_pix() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera.VideoStreamSettings.vertical_resolution_pix)
  return _internal_vertical_resolution_pix();
}
inline void VideoStreamSettings::set_vertical_resolution_pix(::uint32_t value) {
  _internal_set_vertical_resolution_pix(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera.VideoStreamSettings.vertical_resolution_pix)
}
inline ::uint32_t VideoStreamSettings::_internal_vertical_resolution_pix() const {
  return _impl_.vertical_resolution_pix_;
}
inline void VideoStreamSettings::_internal_set_vertical_resolution_pix(::uint32_t value) {
  ;
  _impl_.vertical_resolution_pix_ = value;
}

// uint32 bit_rate_b_s = 4;
inline void VideoStreamSettings::clear_bit_rate_b_s() {
  _impl_.bit_rate_b_s_ = 0u;
}
inline ::uint32_t VideoStreamSettings::bit_rate_b_s() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera.VideoStreamSettings.bit_rate_b_s)
  return _internal_bit_rate_b_s();
}
inline void VideoStreamSettings::set_bit_rate_b_s(::uint32_t value) {
  _internal_set_bit_rate_b_s(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera.VideoStreamSettings.bit_rate_b_s)
}
inline ::uint32_t VideoStreamSettings::_internal_bit_rate_b_s() const {
  return _impl_.bit_rate_b_s_;
}
inline void VideoStreamSettings::_internal_set_bit_rate_b_s(::uint32_t value) {
  ;
  _impl_.bit_rate_b_s_ = value;
}

// uint32 rotation_deg = 5;
inline void VideoStreamSettings::clear_rotation_deg() {
  _impl_.rotation_deg_ = 0u;
}
inline ::uint32_t VideoStreamSettings::rotation_deg() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera.VideoStreamSettings.rotation_deg)
  return _internal_rotation_deg();
}
inline void VideoStreamSettings::set_rotation_deg(::uint32_t value) {
  _internal_set_rotation_deg(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera.VideoStreamSettings.rotation_deg)
}
inline ::uint32_t VideoStreamSettings::_internal_rotation_deg() const {
  return _impl_.rotation_deg_;
}
inline void VideoStreamSettings::_internal_set_rotation_deg(::uint32_t value) {
  ;
  _impl_.rotation_deg_ = value;
}

// string uri = 6;
inline void VideoStreamSettings::clear_uri() {
  _impl_.uri_.ClearToEmpty();
}
inline const std::string& VideoStreamSettings::uri() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera.VideoStreamSettings.uri)
  return _internal_uri();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void VideoStreamSettings::set_uri(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.uri_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera.VideoStreamSettings.uri)
}
inline std::string* VideoStreamSettings::mutable_uri() {
  std::string* _s = _internal_mutable_uri();
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.camera.VideoStreamSettings.uri)
  return _s;
}
inline const std::string& VideoStreamSettings::_internal_uri() const {
  return _impl_.uri_.Get();
}
inline void VideoStreamSettings::_internal_set_uri(const std::string& value) {
  ;


  _impl_.uri_.Set(value, GetArenaForAllocation());
}
inline std::string* VideoStreamSettings::_internal_mutable_uri() {
  ;
  return _impl_.uri_.Mutable( GetArenaForAllocation());
}
inline std::string* VideoStreamSettings::release_uri() {
  // @@protoc_insertion_point(field_release:mavsdk.rpc.camera.VideoStreamSettings.uri)
  return _impl_.uri_.Release();
}
inline void VideoStreamSettings::set_allocated_uri(std::string* value) {
  _impl_.uri_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.uri_.IsDefault()) {
          _impl_.uri_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.camera.VideoStreamSettings.uri)
}

// float horizontal_fov_deg = 7;
inline void VideoStreamSettings::clear_horizontal_fov_deg() {
  _impl_.horizontal_fov_deg_ = 0;
}
inline float VideoStreamSettings::horizontal_fov_deg() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera.VideoStreamSettings.horizontal_fov_deg)
  return _internal_horizontal_fov_deg();
}
inline void VideoStreamSettings::set_horizontal_fov_deg(float value) {
  _internal_set_horizontal_fov_deg(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera.VideoStreamSettings.horizontal_fov_deg)
}
inline float VideoStreamSettings::_internal_horizontal_fov_deg() const {
  return _impl_.horizontal_fov_deg_;
}
inline void VideoStreamSettings::_internal_set_horizontal_fov_deg(float value) {
  ;
  _impl_.horizontal_fov_deg_ = value;
}

// -------------------------------------------------------------------

// VideoStreamInfo

// .mavsdk.rpc.camera.VideoStreamSettings settings = 1;
inline bool VideoStreamInfo::has_settings() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.settings_ != nullptr);
  return value;
}
inline void VideoStreamInfo::clear_settings() {
  if (_impl_.settings_ != nullptr) _impl_.settings_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::mavsdk::rpc::camera::VideoStreamSettings& VideoStreamInfo::_internal_settings() const {
  const ::mavsdk::rpc::camera::VideoStreamSettings* p = _impl_.settings_;
  return p != nullptr ? *p : reinterpret_cast<const ::mavsdk::rpc::camera::VideoStreamSettings&>(
      ::mavsdk::rpc::camera::_VideoStreamSettings_default_instance_);
}
inline const ::mavsdk::rpc::camera::VideoStreamSettings& VideoStreamInfo::settings() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera.VideoStreamInfo.settings)
  return _internal_settings();
}
inline void VideoStreamInfo::unsafe_arena_set_allocated_settings(
    ::mavsdk::rpc::camera::VideoStreamSettings* settings) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.settings_);
  }
  _impl_.settings_ = settings;
  if (settings) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mavsdk.rpc.camera.VideoStreamInfo.settings)
}
inline ::mavsdk::rpc::camera::VideoStreamSettings* VideoStreamInfo::release_settings() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::mavsdk::rpc::camera::VideoStreamSettings* temp = _impl_.settings_;
  _impl_.settings_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mavsdk::rpc::camera::VideoStreamSettings* VideoStreamInfo::unsafe_arena_release_settings() {
  // @@protoc_insertion_point(field_release:mavsdk.rpc.camera.VideoStreamInfo.settings)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::mavsdk::rpc::camera::VideoStreamSettings* temp = _impl_.settings_;
  _impl_.settings_ = nullptr;
  return temp;
}
inline ::mavsdk::rpc::camera::VideoStreamSettings* VideoStreamInfo::_internal_mutable_settings() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.settings_ == nullptr) {
    auto* p = CreateMaybeMessage<::mavsdk::rpc::camera::VideoStreamSettings>(GetArenaForAllocation());
    _impl_.settings_ = p;
  }
  return _impl_.settings_;
}
inline ::mavsdk::rpc::camera::VideoStreamSettings* VideoStreamInfo::mutable_settings() {
  ::mavsdk::rpc::camera::VideoStreamSettings* _msg = _internal_mutable_settings();
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.camera.VideoStreamInfo.settings)
  return _msg;
}
inline void VideoStreamInfo::set_allocated_settings(::mavsdk::rpc::camera::VideoStreamSettings* settings) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.settings_;
  }
  if (settings) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(settings);
    if (message_arena != submessage_arena) {
      settings = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, settings, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.settings_ = settings;
  // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.camera.VideoStreamInfo.settings)
}

// .mavsdk.rpc.camera.VideoStreamInfo.VideoStreamStatus status = 2;
inline void VideoStreamInfo::clear_status() {
  _impl_.status_ = 0;
}
inline ::mavsdk::rpc::camera::VideoStreamInfo_VideoStreamStatus VideoStreamInfo::status() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera.VideoStreamInfo.status)
  return _internal_status();
}
inline void VideoStreamInfo::set_status(::mavsdk::rpc::camera::VideoStreamInfo_VideoStreamStatus value) {
   _internal_set_status(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera.VideoStreamInfo.status)
}
inline ::mavsdk::rpc::camera::VideoStreamInfo_VideoStreamStatus VideoStreamInfo::_internal_status() const {
  return static_cast<::mavsdk::rpc::camera::VideoStreamInfo_VideoStreamStatus>(_impl_.status_);
}
inline void VideoStreamInfo::_internal_set_status(::mavsdk::rpc::camera::VideoStreamInfo_VideoStreamStatus value) {
  ;
  _impl_.status_ = value;
}

// .mavsdk.rpc.camera.VideoStreamInfo.VideoStreamSpectrum spectrum = 3;
inline void VideoStreamInfo::clear_spectrum() {
  _impl_.spectrum_ = 0;
}
inline ::mavsdk::rpc::camera::VideoStreamInfo_VideoStreamSpectrum VideoStreamInfo::spectrum() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera.VideoStreamInfo.spectrum)
  return _internal_spectrum();
}
inline void VideoStreamInfo::set_spectrum(::mavsdk::rpc::camera::VideoStreamInfo_VideoStreamSpectrum value) {
   _internal_set_spectrum(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera.VideoStreamInfo.spectrum)
}
inline ::mavsdk::rpc::camera::VideoStreamInfo_VideoStreamSpectrum VideoStreamInfo::_internal_spectrum() const {
  return static_cast<::mavsdk::rpc::camera::VideoStreamInfo_VideoStreamSpectrum>(_impl_.spectrum_);
}
inline void VideoStreamInfo::_internal_set_spectrum(::mavsdk::rpc::camera::VideoStreamInfo_VideoStreamSpectrum value) {
  ;
  _impl_.spectrum_ = value;
}

// -------------------------------------------------------------------

// Status

// bool video_on = 1;
inline void Status::clear_video_on() {
  _impl_.video_on_ = false;
}
inline bool Status::video_on() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera.Status.video_on)
  return _internal_video_on();
}
inline void Status::set_video_on(bool value) {
  _internal_set_video_on(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera.Status.video_on)
}
inline bool Status::_internal_video_on() const {
  return _impl_.video_on_;
}
inline void Status::_internal_set_video_on(bool value) {
  ;
  _impl_.video_on_ = value;
}

// bool photo_interval_on = 2;
inline void Status::clear_photo_interval_on() {
  _impl_.photo_interval_on_ = false;
}
inline bool Status::photo_interval_on() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera.Status.photo_interval_on)
  return _internal_photo_interval_on();
}
inline void Status::set_photo_interval_on(bool value) {
  _internal_set_photo_interval_on(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera.Status.photo_interval_on)
}
inline bool Status::_internal_photo_interval_on() const {
  return _impl_.photo_interval_on_;
}
inline void Status::_internal_set_photo_interval_on(bool value) {
  ;
  _impl_.photo_interval_on_ = value;
}

// float used_storage_mib = 3;
inline void Status::clear_used_storage_mib() {
  _impl_.used_storage_mib_ = 0;
}
inline float Status::used_storage_mib() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera.Status.used_storage_mib)
  return _internal_used_storage_mib();
}
inline void Status::set_used_storage_mib(float value) {
  _internal_set_used_storage_mib(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera.Status.used_storage_mib)
}
inline float Status::_internal_used_storage_mib() const {
  return _impl_.used_storage_mib_;
}
inline void Status::_internal_set_used_storage_mib(float value) {
  ;
  _impl_.used_storage_mib_ = value;
}

// float available_storage_mib = 4;
inline void Status::clear_available_storage_mib() {
  _impl_.available_storage_mib_ = 0;
}
inline float Status::available_storage_mib() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera.Status.available_storage_mib)
  return _internal_available_storage_mib();
}
inline void Status::set_available_storage_mib(float value) {
  _internal_set_available_storage_mib(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera.Status.available_storage_mib)
}
inline float Status::_internal_available_storage_mib() const {
  return _impl_.available_storage_mib_;
}
inline void Status::_internal_set_available_storage_mib(float value) {
  ;
  _impl_.available_storage_mib_ = value;
}

// float total_storage_mib = 5;
inline void Status::clear_total_storage_mib() {
  _impl_.total_storage_mib_ = 0;
}
inline float Status::total_storage_mib() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera.Status.total_storage_mib)
  return _internal_total_storage_mib();
}
inline void Status::set_total_storage_mib(float value) {
  _internal_set_total_storage_mib(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera.Status.total_storage_mib)
}
inline float Status::_internal_total_storage_mib() const {
  return _impl_.total_storage_mib_;
}
inline void Status::_internal_set_total_storage_mib(float value) {
  ;
  _impl_.total_storage_mib_ = value;
}

// float recording_time_s = 6;
inline void Status::clear_recording_time_s() {
  _impl_.recording_time_s_ = 0;
}
inline float Status::recording_time_s() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera.Status.recording_time_s)
  return _internal_recording_time_s();
}
inline void Status::set_recording_time_s(float value) {
  _internal_set_recording_time_s(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera.Status.recording_time_s)
}
inline float Status::_internal_recording_time_s() const {
  return _impl_.recording_time_s_;
}
inline void Status::_internal_set_recording_time_s(float value) {
  ;
  _impl_.recording_time_s_ = value;
}

// string media_folder_name = 7;
inline void Status::clear_media_folder_name() {
  _impl_.media_folder_name_.ClearToEmpty();
}
inline const std::string& Status::media_folder_name() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera.Status.media_folder_name)
  return _internal_media_folder_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Status::set_media_folder_name(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.media_folder_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera.Status.media_folder_name)
}
inline std::string* Status::mutable_media_folder_name() {
  std::string* _s = _internal_mutable_media_folder_name();
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.camera.Status.media_folder_name)
  return _s;
}
inline const std::string& Status::_internal_media_folder_name() const {
  return _impl_.media_folder_name_.Get();
}
inline void Status::_internal_set_media_folder_name(const std::string& value) {
  ;


  _impl_.media_folder_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Status::_internal_mutable_media_folder_name() {
  ;
  return _impl_.media_folder_name_.Mutable( GetArenaForAllocation());
}
inline std::string* Status::release_media_folder_name() {
  // @@protoc_insertion_point(field_release:mavsdk.rpc.camera.Status.media_folder_name)
  return _impl_.media_folder_name_.Release();
}
inline void Status::set_allocated_media_folder_name(std::string* value) {
  _impl_.media_folder_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.media_folder_name_.IsDefault()) {
          _impl_.media_folder_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.camera.Status.media_folder_name)
}

// .mavsdk.rpc.camera.Status.StorageStatus storage_status = 8;
inline void Status::clear_storage_status() {
  _impl_.storage_status_ = 0;
}
inline ::mavsdk::rpc::camera::Status_StorageStatus Status::storage_status() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera.Status.storage_status)
  return _internal_storage_status();
}
inline void Status::set_storage_status(::mavsdk::rpc::camera::Status_StorageStatus value) {
   _internal_set_storage_status(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera.Status.storage_status)
}
inline ::mavsdk::rpc::camera::Status_StorageStatus Status::_internal_storage_status() const {
  return static_cast<::mavsdk::rpc::camera::Status_StorageStatus>(_impl_.storage_status_);
}
inline void Status::_internal_set_storage_status(::mavsdk::rpc::camera::Status_StorageStatus value) {
  ;
  _impl_.storage_status_ = value;
}

// uint32 storage_id = 9;
inline void Status::clear_storage_id() {
  _impl_.storage_id_ = 0u;
}
inline ::uint32_t Status::storage_id() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera.Status.storage_id)
  return _internal_storage_id();
}
inline void Status::set_storage_id(::uint32_t value) {
  _internal_set_storage_id(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera.Status.storage_id)
}
inline ::uint32_t Status::_internal_storage_id() const {
  return _impl_.storage_id_;
}
inline void Status::_internal_set_storage_id(::uint32_t value) {
  ;
  _impl_.storage_id_ = value;
}

// .mavsdk.rpc.camera.Status.StorageType storage_type = 10;
inline void Status::clear_storage_type() {
  _impl_.storage_type_ = 0;
}
inline ::mavsdk::rpc::camera::Status_StorageType Status::storage_type() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera.Status.storage_type)
  return _internal_storage_type();
}
inline void Status::set_storage_type(::mavsdk::rpc::camera::Status_StorageType value) {
   _internal_set_storage_type(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera.Status.storage_type)
}
inline ::mavsdk::rpc::camera::Status_StorageType Status::_internal_storage_type() const {
  return static_cast<::mavsdk::rpc::camera::Status_StorageType>(_impl_.storage_type_);
}
inline void Status::_internal_set_storage_type(::mavsdk::rpc::camera::Status_StorageType value) {
  ;
  _impl_.storage_type_ = value;
}

// -------------------------------------------------------------------

// Option

// string option_id = 1;
inline void Option::clear_option_id() {
  _impl_.option_id_.ClearToEmpty();
}
inline const std::string& Option::option_id() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera.Option.option_id)
  return _internal_option_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Option::set_option_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.option_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera.Option.option_id)
}
inline std::string* Option::mutable_option_id() {
  std::string* _s = _internal_mutable_option_id();
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.camera.Option.option_id)
  return _s;
}
inline const std::string& Option::_internal_option_id() const {
  return _impl_.option_id_.Get();
}
inline void Option::_internal_set_option_id(const std::string& value) {
  ;


  _impl_.option_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Option::_internal_mutable_option_id() {
  ;
  return _impl_.option_id_.Mutable( GetArenaForAllocation());
}
inline std::string* Option::release_option_id() {
  // @@protoc_insertion_point(field_release:mavsdk.rpc.camera.Option.option_id)
  return _impl_.option_id_.Release();
}
inline void Option::set_allocated_option_id(std::string* value) {
  _impl_.option_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.option_id_.IsDefault()) {
          _impl_.option_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.camera.Option.option_id)
}

// string option_description = 2;
inline void Option::clear_option_description() {
  _impl_.option_description_.ClearToEmpty();
}
inline const std::string& Option::option_description() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera.Option.option_description)
  return _internal_option_description();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Option::set_option_description(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.option_description_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera.Option.option_description)
}
inline std::string* Option::mutable_option_description() {
  std::string* _s = _internal_mutable_option_description();
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.camera.Option.option_description)
  return _s;
}
inline const std::string& Option::_internal_option_description() const {
  return _impl_.option_description_.Get();
}
inline void Option::_internal_set_option_description(const std::string& value) {
  ;


  _impl_.option_description_.Set(value, GetArenaForAllocation());
}
inline std::string* Option::_internal_mutable_option_description() {
  ;
  return _impl_.option_description_.Mutable( GetArenaForAllocation());
}
inline std::string* Option::release_option_description() {
  // @@protoc_insertion_point(field_release:mavsdk.rpc.camera.Option.option_description)
  return _impl_.option_description_.Release();
}
inline void Option::set_allocated_option_description(std::string* value) {
  _impl_.option_description_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.option_description_.IsDefault()) {
          _impl_.option_description_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.camera.Option.option_description)
}

// -------------------------------------------------------------------

// Setting

// string setting_id = 1;
inline void Setting::clear_setting_id() {
  _impl_.setting_id_.ClearToEmpty();
}
inline const std::string& Setting::setting_id() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera.Setting.setting_id)
  return _internal_setting_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Setting::set_setting_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.setting_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera.Setting.setting_id)
}
inline std::string* Setting::mutable_setting_id() {
  std::string* _s = _internal_mutable_setting_id();
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.camera.Setting.setting_id)
  return _s;
}
inline const std::string& Setting::_internal_setting_id() const {
  return _impl_.setting_id_.Get();
}
inline void Setting::_internal_set_setting_id(const std::string& value) {
  ;


  _impl_.setting_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Setting::_internal_mutable_setting_id() {
  ;
  return _impl_.setting_id_.Mutable( GetArenaForAllocation());
}
inline std::string* Setting::release_setting_id() {
  // @@protoc_insertion_point(field_release:mavsdk.rpc.camera.Setting.setting_id)
  return _impl_.setting_id_.Release();
}
inline void Setting::set_allocated_setting_id(std::string* value) {
  _impl_.setting_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.setting_id_.IsDefault()) {
          _impl_.setting_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.camera.Setting.setting_id)
}

// string setting_description = 2;
inline void Setting::clear_setting_description() {
  _impl_.setting_description_.ClearToEmpty();
}
inline const std::string& Setting::setting_description() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera.Setting.setting_description)
  return _internal_setting_description();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Setting::set_setting_description(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.setting_description_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera.Setting.setting_description)
}
inline std::string* Setting::mutable_setting_description() {
  std::string* _s = _internal_mutable_setting_description();
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.camera.Setting.setting_description)
  return _s;
}
inline const std::string& Setting::_internal_setting_description() const {
  return _impl_.setting_description_.Get();
}
inline void Setting::_internal_set_setting_description(const std::string& value) {
  ;


  _impl_.setting_description_.Set(value, GetArenaForAllocation());
}
inline std::string* Setting::_internal_mutable_setting_description() {
  ;
  return _impl_.setting_description_.Mutable( GetArenaForAllocation());
}
inline std::string* Setting::release_setting_description() {
  // @@protoc_insertion_point(field_release:mavsdk.rpc.camera.Setting.setting_description)
  return _impl_.setting_description_.Release();
}
inline void Setting::set_allocated_setting_description(std::string* value) {
  _impl_.setting_description_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.setting_description_.IsDefault()) {
          _impl_.setting_description_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.camera.Setting.setting_description)
}

// .mavsdk.rpc.camera.Option option = 3;
inline bool Setting::has_option() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.option_ != nullptr);
  return value;
}
inline void Setting::clear_option() {
  if (_impl_.option_ != nullptr) _impl_.option_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::mavsdk::rpc::camera::Option& Setting::_internal_option() const {
  const ::mavsdk::rpc::camera::Option* p = _impl_.option_;
  return p != nullptr ? *p : reinterpret_cast<const ::mavsdk::rpc::camera::Option&>(
      ::mavsdk::rpc::camera::_Option_default_instance_);
}
inline const ::mavsdk::rpc::camera::Option& Setting::option() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera.Setting.option)
  return _internal_option();
}
inline void Setting::unsafe_arena_set_allocated_option(
    ::mavsdk::rpc::camera::Option* option) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.option_);
  }
  _impl_.option_ = option;
  if (option) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mavsdk.rpc.camera.Setting.option)
}
inline ::mavsdk::rpc::camera::Option* Setting::release_option() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::mavsdk::rpc::camera::Option* temp = _impl_.option_;
  _impl_.option_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::mavsdk::rpc::camera::Option* Setting::unsafe_arena_release_option() {
  // @@protoc_insertion_point(field_release:mavsdk.rpc.camera.Setting.option)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::mavsdk::rpc::camera::Option* temp = _impl_.option_;
  _impl_.option_ = nullptr;
  return temp;
}
inline ::mavsdk::rpc::camera::Option* Setting::_internal_mutable_option() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.option_ == nullptr) {
    auto* p = CreateMaybeMessage<::mavsdk::rpc::camera::Option>(GetArenaForAllocation());
    _impl_.option_ = p;
  }
  return _impl_.option_;
}
inline ::mavsdk::rpc::camera::Option* Setting::mutable_option() {
  ::mavsdk::rpc::camera::Option* _msg = _internal_mutable_option();
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.camera.Setting.option)
  return _msg;
}
inline void Setting::set_allocated_option(::mavsdk::rpc::camera::Option* option) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.option_;
  }
  if (option) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(option);
    if (message_arena != submessage_arena) {
      option = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, option, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.option_ = option;
  // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.camera.Setting.option)
}

// bool is_range = 4;
inline void Setting::clear_is_range() {
  _impl_.is_range_ = false;
}
inline bool Setting::is_range() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera.Setting.is_range)
  return _internal_is_range();
}
inline void Setting::set_is_range(bool value) {
  _internal_set_is_range(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera.Setting.is_range)
}
inline bool Setting::_internal_is_range() const {
  return _impl_.is_range_;
}
inline void Setting::_internal_set_is_range(bool value) {
  ;
  _impl_.is_range_ = value;
}

// -------------------------------------------------------------------

// SettingOptions

// string setting_id = 1;
inline void SettingOptions::clear_setting_id() {
  _impl_.setting_id_.ClearToEmpty();
}
inline const std::string& SettingOptions::setting_id() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera.SettingOptions.setting_id)
  return _internal_setting_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SettingOptions::set_setting_id(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.setting_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera.SettingOptions.setting_id)
}
inline std::string* SettingOptions::mutable_setting_id() {
  std::string* _s = _internal_mutable_setting_id();
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.camera.SettingOptions.setting_id)
  return _s;
}
inline const std::string& SettingOptions::_internal_setting_id() const {
  return _impl_.setting_id_.Get();
}
inline void SettingOptions::_internal_set_setting_id(const std::string& value) {
  ;


  _impl_.setting_id_.Set(value, GetArenaForAllocation());
}
inline std::string* SettingOptions::_internal_mutable_setting_id() {
  ;
  return _impl_.setting_id_.Mutable( GetArenaForAllocation());
}
inline std::string* SettingOptions::release_setting_id() {
  // @@protoc_insertion_point(field_release:mavsdk.rpc.camera.SettingOptions.setting_id)
  return _impl_.setting_id_.Release();
}
inline void SettingOptions::set_allocated_setting_id(std::string* value) {
  _impl_.setting_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.setting_id_.IsDefault()) {
          _impl_.setting_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.camera.SettingOptions.setting_id)
}

// string setting_description = 2;
inline void SettingOptions::clear_setting_description() {
  _impl_.setting_description_.ClearToEmpty();
}
inline const std::string& SettingOptions::setting_description() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera.SettingOptions.setting_description)
  return _internal_setting_description();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SettingOptions::set_setting_description(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.setting_description_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera.SettingOptions.setting_description)
}
inline std::string* SettingOptions::mutable_setting_description() {
  std::string* _s = _internal_mutable_setting_description();
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.camera.SettingOptions.setting_description)
  return _s;
}
inline const std::string& SettingOptions::_internal_setting_description() const {
  return _impl_.setting_description_.Get();
}
inline void SettingOptions::_internal_set_setting_description(const std::string& value) {
  ;


  _impl_.setting_description_.Set(value, GetArenaForAllocation());
}
inline std::string* SettingOptions::_internal_mutable_setting_description() {
  ;
  return _impl_.setting_description_.Mutable( GetArenaForAllocation());
}
inline std::string* SettingOptions::release_setting_description() {
  // @@protoc_insertion_point(field_release:mavsdk.rpc.camera.SettingOptions.setting_description)
  return _impl_.setting_description_.Release();
}
inline void SettingOptions::set_allocated_setting_description(std::string* value) {
  _impl_.setting_description_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.setting_description_.IsDefault()) {
          _impl_.setting_description_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.camera.SettingOptions.setting_description)
}

// repeated .mavsdk.rpc.camera.Option options = 3;
inline int SettingOptions::_internal_options_size() const {
  return _impl_.options_.size();
}
inline int SettingOptions::options_size() const {
  return _internal_options_size();
}
inline void SettingOptions::clear_options() {
  _internal_mutable_options()->Clear();
}
inline ::mavsdk::rpc::camera::Option* SettingOptions::mutable_options(int index) {
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.camera.SettingOptions.options)
  return _internal_mutable_options()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mavsdk::rpc::camera::Option >*
SettingOptions::mutable_options() {
  // @@protoc_insertion_point(field_mutable_list:mavsdk.rpc.camera.SettingOptions.options)
  return _internal_mutable_options();
}
inline const ::mavsdk::rpc::camera::Option& SettingOptions::_internal_options(int index) const {
  return _internal_options().Get(index);
}
inline const ::mavsdk::rpc::camera::Option& SettingOptions::options(int index) const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera.SettingOptions.options)
  return _internal_options(index);
}
inline ::mavsdk::rpc::camera::Option* SettingOptions::_internal_add_options() {
  return _internal_mutable_options()->Add();
}
inline ::mavsdk::rpc::camera::Option* SettingOptions::add_options() {
  ::mavsdk::rpc::camera::Option* _add = _internal_add_options();
  // @@protoc_insertion_point(field_add:mavsdk.rpc.camera.SettingOptions.options)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mavsdk::rpc::camera::Option >&
SettingOptions::options() const {
  // @@protoc_insertion_point(field_list:mavsdk.rpc.camera.SettingOptions.options)
  return _internal_options();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::mavsdk::rpc::camera::Option>&
SettingOptions::_internal_options() const {
  return _impl_.options_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::mavsdk::rpc::camera::Option>*
SettingOptions::_internal_mutable_options() {
  return &_impl_.options_;
}

// bool is_range = 4;
inline void SettingOptions::clear_is_range() {
  _impl_.is_range_ = false;
}
inline bool SettingOptions::is_range() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera.SettingOptions.is_range)
  return _internal_is_range();
}
inline void SettingOptions::set_is_range(bool value) {
  _internal_set_is_range(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera.SettingOptions.is_range)
}
inline bool SettingOptions::_internal_is_range() const {
  return _impl_.is_range_;
}
inline void SettingOptions::_internal_set_is_range(bool value) {
  ;
  _impl_.is_range_ = value;
}

// -------------------------------------------------------------------

// Information

// string vendor_name = 1;
inline void Information::clear_vendor_name() {
  _impl_.vendor_name_.ClearToEmpty();
}
inline const std::string& Information::vendor_name() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera.Information.vendor_name)
  return _internal_vendor_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Information::set_vendor_name(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.vendor_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera.Information.vendor_name)
}
inline std::string* Information::mutable_vendor_name() {
  std::string* _s = _internal_mutable_vendor_name();
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.camera.Information.vendor_name)
  return _s;
}
inline const std::string& Information::_internal_vendor_name() const {
  return _impl_.vendor_name_.Get();
}
inline void Information::_internal_set_vendor_name(const std::string& value) {
  ;


  _impl_.vendor_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Information::_internal_mutable_vendor_name() {
  ;
  return _impl_.vendor_name_.Mutable( GetArenaForAllocation());
}
inline std::string* Information::release_vendor_name() {
  // @@protoc_insertion_point(field_release:mavsdk.rpc.camera.Information.vendor_name)
  return _impl_.vendor_name_.Release();
}
inline void Information::set_allocated_vendor_name(std::string* value) {
  _impl_.vendor_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.vendor_name_.IsDefault()) {
          _impl_.vendor_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.camera.Information.vendor_name)
}

// string model_name = 2;
inline void Information::clear_model_name() {
  _impl_.model_name_.ClearToEmpty();
}
inline const std::string& Information::model_name() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera.Information.model_name)
  return _internal_model_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Information::set_model_name(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.model_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera.Information.model_name)
}
inline std::string* Information::mutable_model_name() {
  std::string* _s = _internal_mutable_model_name();
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.camera.Information.model_name)
  return _s;
}
inline const std::string& Information::_internal_model_name() const {
  return _impl_.model_name_.Get();
}
inline void Information::_internal_set_model_name(const std::string& value) {
  ;


  _impl_.model_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Information::_internal_mutable_model_name() {
  ;
  return _impl_.model_name_.Mutable( GetArenaForAllocation());
}
inline std::string* Information::release_model_name() {
  // @@protoc_insertion_point(field_release:mavsdk.rpc.camera.Information.model_name)
  return _impl_.model_name_.Release();
}
inline void Information::set_allocated_model_name(std::string* value) {
  _impl_.model_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.model_name_.IsDefault()) {
          _impl_.model_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.camera.Information.model_name)
}

// float focal_length_mm = 3;
inline void Information::clear_focal_length_mm() {
  _impl_.focal_length_mm_ = 0;
}
inline float Information::focal_length_mm() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera.Information.focal_length_mm)
  return _internal_focal_length_mm();
}
inline void Information::set_focal_length_mm(float value) {
  _internal_set_focal_length_mm(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera.Information.focal_length_mm)
}
inline float Information::_internal_focal_length_mm() const {
  return _impl_.focal_length_mm_;
}
inline void Information::_internal_set_focal_length_mm(float value) {
  ;
  _impl_.focal_length_mm_ = value;
}

// float horizontal_sensor_size_mm = 4;
inline void Information::clear_horizontal_sensor_size_mm() {
  _impl_.horizontal_sensor_size_mm_ = 0;
}
inline float Information::horizontal_sensor_size_mm() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera.Information.horizontal_sensor_size_mm)
  return _internal_horizontal_sensor_size_mm();
}
inline void Information::set_horizontal_sensor_size_mm(float value) {
  _internal_set_horizontal_sensor_size_mm(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera.Information.horizontal_sensor_size_mm)
}
inline float Information::_internal_horizontal_sensor_size_mm() const {
  return _impl_.horizontal_sensor_size_mm_;
}
inline void Information::_internal_set_horizontal_sensor_size_mm(float value) {
  ;
  _impl_.horizontal_sensor_size_mm_ = value;
}

// float vertical_sensor_size_mm = 5;
inline void Information::clear_vertical_sensor_size_mm() {
  _impl_.vertical_sensor_size_mm_ = 0;
}
inline float Information::vertical_sensor_size_mm() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera.Information.vertical_sensor_size_mm)
  return _internal_vertical_sensor_size_mm();
}
inline void Information::set_vertical_sensor_size_mm(float value) {
  _internal_set_vertical_sensor_size_mm(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera.Information.vertical_sensor_size_mm)
}
inline float Information::_internal_vertical_sensor_size_mm() const {
  return _impl_.vertical_sensor_size_mm_;
}
inline void Information::_internal_set_vertical_sensor_size_mm(float value) {
  ;
  _impl_.vertical_sensor_size_mm_ = value;
}

// uint32 horizontal_resolution_px = 6;
inline void Information::clear_horizontal_resolution_px() {
  _impl_.horizontal_resolution_px_ = 0u;
}
inline ::uint32_t Information::horizontal_resolution_px() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera.Information.horizontal_resolution_px)
  return _internal_horizontal_resolution_px();
}
inline void Information::set_horizontal_resolution_px(::uint32_t value) {
  _internal_set_horizontal_resolution_px(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera.Information.horizontal_resolution_px)
}
inline ::uint32_t Information::_internal_horizontal_resolution_px() const {
  return _impl_.horizontal_resolution_px_;
}
inline void Information::_internal_set_horizontal_resolution_px(::uint32_t value) {
  ;
  _impl_.horizontal_resolution_px_ = value;
}

// uint32 vertical_resolution_px = 7;
inline void Information::clear_vertical_resolution_px() {
  _impl_.vertical_resolution_px_ = 0u;
}
inline ::uint32_t Information::vertical_resolution_px() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.camera.Information.vertical_resolution_px)
  return _internal_vertical_resolution_px();
}
inline void Information::set_vertical_resolution_px(::uint32_t value) {
  _internal_set_vertical_resolution_px(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.camera.Information.vertical_resolution_px)
}
inline ::uint32_t Information::_internal_vertical_resolution_px() const {
  return _impl_.vertical_resolution_px_;
}
inline void Information::_internal_set_vertical_resolution_px(::uint32_t value) {
  ;
  _impl_.vertical_resolution_px_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace camera
}  // namespace rpc
}  // namespace mavsdk


PROTOBUF_NAMESPACE_OPEN

template <>
struct is_proto_enum<::mavsdk::rpc::camera::CameraResult_Result> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::mavsdk::rpc::camera::CameraResult_Result>() {
  return ::mavsdk::rpc::camera::CameraResult_Result_descriptor();
}
template <>
struct is_proto_enum<::mavsdk::rpc::camera::VideoStreamInfo_VideoStreamStatus> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::mavsdk::rpc::camera::VideoStreamInfo_VideoStreamStatus>() {
  return ::mavsdk::rpc::camera::VideoStreamInfo_VideoStreamStatus_descriptor();
}
template <>
struct is_proto_enum<::mavsdk::rpc::camera::VideoStreamInfo_VideoStreamSpectrum> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::mavsdk::rpc::camera::VideoStreamInfo_VideoStreamSpectrum>() {
  return ::mavsdk::rpc::camera::VideoStreamInfo_VideoStreamSpectrum_descriptor();
}
template <>
struct is_proto_enum<::mavsdk::rpc::camera::Status_StorageStatus> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::mavsdk::rpc::camera::Status_StorageStatus>() {
  return ::mavsdk::rpc::camera::Status_StorageStatus_descriptor();
}
template <>
struct is_proto_enum<::mavsdk::rpc::camera::Status_StorageType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::mavsdk::rpc::camera::Status_StorageType>() {
  return ::mavsdk::rpc::camera::Status_StorageType_descriptor();
}
template <>
struct is_proto_enum<::mavsdk::rpc::camera::Mode> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::mavsdk::rpc::camera::Mode>() {
  return ::mavsdk::rpc::camera::Mode_descriptor();
}
template <>
struct is_proto_enum<::mavsdk::rpc::camera::PhotosRange> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::mavsdk::rpc::camera::PhotosRange>() {
  return ::mavsdk::rpc::camera::PhotosRange_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_camera_2fcamera_2eproto_2epb_2eh
