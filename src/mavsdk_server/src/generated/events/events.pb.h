// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: events/events.proto
// Protobuf C++ Version: 5.29.1

#ifndef events_2fevents_2eproto_2epb_2eh
#define events_2fevents_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5029001
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "mavsdk_options.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_events_2fevents_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_events_2fevents_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_events_2fevents_2eproto;
namespace mavsdk {
namespace rpc {
namespace events {
class Event;
struct EventDefaultTypeInternal;
extern EventDefaultTypeInternal _Event_default_instance_;
class EventsResponse;
struct EventsResponseDefaultTypeInternal;
extern EventsResponseDefaultTypeInternal _EventsResponse_default_instance_;
class EventsResult;
struct EventsResultDefaultTypeInternal;
extern EventsResultDefaultTypeInternal _EventsResult_default_instance_;
class GetHealthAndArmingChecksReportRequest;
struct GetHealthAndArmingChecksReportRequestDefaultTypeInternal;
extern GetHealthAndArmingChecksReportRequestDefaultTypeInternal _GetHealthAndArmingChecksReportRequest_default_instance_;
class GetHealthAndArmingChecksReportResponse;
struct GetHealthAndArmingChecksReportResponseDefaultTypeInternal;
extern GetHealthAndArmingChecksReportResponseDefaultTypeInternal _GetHealthAndArmingChecksReportResponse_default_instance_;
class HealthAndArmingCheckMode;
struct HealthAndArmingCheckModeDefaultTypeInternal;
extern HealthAndArmingCheckModeDefaultTypeInternal _HealthAndArmingCheckMode_default_instance_;
class HealthAndArmingCheckProblem;
struct HealthAndArmingCheckProblemDefaultTypeInternal;
extern HealthAndArmingCheckProblemDefaultTypeInternal _HealthAndArmingCheckProblem_default_instance_;
class HealthAndArmingCheckReport;
struct HealthAndArmingCheckReportDefaultTypeInternal;
extern HealthAndArmingCheckReportDefaultTypeInternal _HealthAndArmingCheckReport_default_instance_;
class HealthAndArmingChecksResponse;
struct HealthAndArmingChecksResponseDefaultTypeInternal;
extern HealthAndArmingChecksResponseDefaultTypeInternal _HealthAndArmingChecksResponse_default_instance_;
class HealthComponentReport;
struct HealthComponentReportDefaultTypeInternal;
extern HealthComponentReportDefaultTypeInternal _HealthComponentReport_default_instance_;
class SubscribeEventsRequest;
struct SubscribeEventsRequestDefaultTypeInternal;
extern SubscribeEventsRequestDefaultTypeInternal _SubscribeEventsRequest_default_instance_;
class SubscribeHealthAndArmingChecksRequest;
struct SubscribeHealthAndArmingChecksRequestDefaultTypeInternal;
extern SubscribeHealthAndArmingChecksRequestDefaultTypeInternal _SubscribeHealthAndArmingChecksRequest_default_instance_;
}  // namespace events
}  // namespace rpc
}  // namespace mavsdk
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace mavsdk {
namespace rpc {
namespace events {
enum EventsResult_Result : int {
  EventsResult_Result_RESULT_SUCCESS = 0,
  EventsResult_Result_RESULT_NOT_AVAILABLE = 1,
  EventsResult_Result_RESULT_CONNECTION_ERROR = 2,
  EventsResult_Result_RESULT_UNSUPPORTED = 3,
  EventsResult_Result_RESULT_DENIED = 4,
  EventsResult_Result_RESULT_FAILED = 5,
  EventsResult_Result_RESULT_TIMEOUT = 6,
  EventsResult_Result_RESULT_NO_SYSTEM = 7,
  EventsResult_Result_RESULT_UNKNOWN = 8,
  EventsResult_Result_EventsResult_Result_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  EventsResult_Result_EventsResult_Result_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool EventsResult_Result_IsValid(int value);
extern const uint32_t EventsResult_Result_internal_data_[];
constexpr EventsResult_Result EventsResult_Result_Result_MIN = static_cast<EventsResult_Result>(0);
constexpr EventsResult_Result EventsResult_Result_Result_MAX = static_cast<EventsResult_Result>(8);
constexpr int EventsResult_Result_Result_ARRAYSIZE = 8 + 1;
const ::google::protobuf::EnumDescriptor*
EventsResult_Result_descriptor();
template <typename T>
const std::string& EventsResult_Result_Name(T value) {
  static_assert(std::is_same<T, EventsResult_Result>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Result_Name().");
  return EventsResult_Result_Name(static_cast<EventsResult_Result>(value));
}
template <>
inline const std::string& EventsResult_Result_Name(EventsResult_Result value) {
  return ::google::protobuf::internal::NameOfDenseEnum<EventsResult_Result_descriptor,
                                                 0, 8>(
      static_cast<int>(value));
}
inline bool EventsResult_Result_Parse(absl::string_view name, EventsResult_Result* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EventsResult_Result>(
      EventsResult_Result_descriptor(), name, value);
}
enum LogLevel : int {
  LOG_LEVEL_EMERGENCY = 0,
  LOG_LEVEL_ALERT = 1,
  LOG_LEVEL_CRITICAL = 2,
  LOG_LEVEL_ERROR = 3,
  LOG_LEVEL_WARNING = 4,
  LOG_LEVEL_NOTICE = 5,
  LOG_LEVEL_INFO = 6,
  LOG_LEVEL_DEBUG = 7,
  LogLevel_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  LogLevel_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool LogLevel_IsValid(int value);
extern const uint32_t LogLevel_internal_data_[];
constexpr LogLevel LogLevel_MIN = static_cast<LogLevel>(0);
constexpr LogLevel LogLevel_MAX = static_cast<LogLevel>(7);
constexpr int LogLevel_ARRAYSIZE = 7 + 1;
const ::google::protobuf::EnumDescriptor*
LogLevel_descriptor();
template <typename T>
const std::string& LogLevel_Name(T value) {
  static_assert(std::is_same<T, LogLevel>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to LogLevel_Name().");
  return LogLevel_Name(static_cast<LogLevel>(value));
}
template <>
inline const std::string& LogLevel_Name(LogLevel value) {
  return ::google::protobuf::internal::NameOfDenseEnum<LogLevel_descriptor,
                                                 0, 7>(
      static_cast<int>(value));
}
inline bool LogLevel_Parse(absl::string_view name, LogLevel* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LogLevel>(
      LogLevel_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class SubscribeHealthAndArmingChecksRequest final
    : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:mavsdk.rpc.events.SubscribeHealthAndArmingChecksRequest) */ {
 public:
  inline SubscribeHealthAndArmingChecksRequest() : SubscribeHealthAndArmingChecksRequest(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SubscribeHealthAndArmingChecksRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SubscribeHealthAndArmingChecksRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SubscribeHealthAndArmingChecksRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline SubscribeHealthAndArmingChecksRequest(const SubscribeHealthAndArmingChecksRequest& from) : SubscribeHealthAndArmingChecksRequest(nullptr, from) {}
  inline SubscribeHealthAndArmingChecksRequest(SubscribeHealthAndArmingChecksRequest&& from) noexcept
      : SubscribeHealthAndArmingChecksRequest(nullptr, std::move(from)) {}
  inline SubscribeHealthAndArmingChecksRequest& operator=(const SubscribeHealthAndArmingChecksRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscribeHealthAndArmingChecksRequest& operator=(SubscribeHealthAndArmingChecksRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscribeHealthAndArmingChecksRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubscribeHealthAndArmingChecksRequest* internal_default_instance() {
    return reinterpret_cast<const SubscribeHealthAndArmingChecksRequest*>(
        &_SubscribeHealthAndArmingChecksRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(SubscribeHealthAndArmingChecksRequest& a, SubscribeHealthAndArmingChecksRequest& b) { a.Swap(&b); }
  inline void Swap(SubscribeHealthAndArmingChecksRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscribeHealthAndArmingChecksRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscribeHealthAndArmingChecksRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<SubscribeHealthAndArmingChecksRequest>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SubscribeHealthAndArmingChecksRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SubscribeHealthAndArmingChecksRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "mavsdk.rpc.events.SubscribeHealthAndArmingChecksRequest"; }

 protected:
  explicit SubscribeHealthAndArmingChecksRequest(::google::protobuf::Arena* arena);
  SubscribeHealthAndArmingChecksRequest(::google::protobuf::Arena* arena, const SubscribeHealthAndArmingChecksRequest& from);
  SubscribeHealthAndArmingChecksRequest(::google::protobuf::Arena* arena, SubscribeHealthAndArmingChecksRequest&& from) noexcept
      : SubscribeHealthAndArmingChecksRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:mavsdk.rpc.events.SubscribeHealthAndArmingChecksRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SubscribeHealthAndArmingChecksRequest& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_events_2fevents_2eproto;
};
// -------------------------------------------------------------------

class SubscribeEventsRequest final
    : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:mavsdk.rpc.events.SubscribeEventsRequest) */ {
 public:
  inline SubscribeEventsRequest() : SubscribeEventsRequest(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SubscribeEventsRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SubscribeEventsRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SubscribeEventsRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline SubscribeEventsRequest(const SubscribeEventsRequest& from) : SubscribeEventsRequest(nullptr, from) {}
  inline SubscribeEventsRequest(SubscribeEventsRequest&& from) noexcept
      : SubscribeEventsRequest(nullptr, std::move(from)) {}
  inline SubscribeEventsRequest& operator=(const SubscribeEventsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscribeEventsRequest& operator=(SubscribeEventsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscribeEventsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubscribeEventsRequest* internal_default_instance() {
    return reinterpret_cast<const SubscribeEventsRequest*>(
        &_SubscribeEventsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(SubscribeEventsRequest& a, SubscribeEventsRequest& b) { a.Swap(&b); }
  inline void Swap(SubscribeEventsRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscribeEventsRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscribeEventsRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<SubscribeEventsRequest>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SubscribeEventsRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SubscribeEventsRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "mavsdk.rpc.events.SubscribeEventsRequest"; }

 protected:
  explicit SubscribeEventsRequest(::google::protobuf::Arena* arena);
  SubscribeEventsRequest(::google::protobuf::Arena* arena, const SubscribeEventsRequest& from);
  SubscribeEventsRequest(::google::protobuf::Arena* arena, SubscribeEventsRequest&& from) noexcept
      : SubscribeEventsRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:mavsdk.rpc.events.SubscribeEventsRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SubscribeEventsRequest& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_events_2fevents_2eproto;
};
// -------------------------------------------------------------------

class HealthComponentReport final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:mavsdk.rpc.events.HealthComponentReport) */ {
 public:
  inline HealthComponentReport() : HealthComponentReport(nullptr) {}
  ~HealthComponentReport() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(HealthComponentReport* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(HealthComponentReport));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR HealthComponentReport(
      ::google::protobuf::internal::ConstantInitialized);

  inline HealthComponentReport(const HealthComponentReport& from) : HealthComponentReport(nullptr, from) {}
  inline HealthComponentReport(HealthComponentReport&& from) noexcept
      : HealthComponentReport(nullptr, std::move(from)) {}
  inline HealthComponentReport& operator=(const HealthComponentReport& from) {
    CopyFrom(from);
    return *this;
  }
  inline HealthComponentReport& operator=(HealthComponentReport&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HealthComponentReport& default_instance() {
    return *internal_default_instance();
  }
  static inline const HealthComponentReport* internal_default_instance() {
    return reinterpret_cast<const HealthComponentReport*>(
        &_HealthComponentReport_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(HealthComponentReport& a, HealthComponentReport& b) { a.Swap(&b); }
  inline void Swap(HealthComponentReport* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HealthComponentReport* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HealthComponentReport* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<HealthComponentReport>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const HealthComponentReport& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const HealthComponentReport& from) { HealthComponentReport::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(HealthComponentReport* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "mavsdk.rpc.events.HealthComponentReport"; }

 protected:
  explicit HealthComponentReport(::google::protobuf::Arena* arena);
  HealthComponentReport(::google::protobuf::Arena* arena, const HealthComponentReport& from);
  HealthComponentReport(::google::protobuf::Arena* arena, HealthComponentReport&& from) noexcept
      : HealthComponentReport(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNameFieldNumber = 1,
    kLabelFieldNumber = 2,
    kIsPresentFieldNumber = 3,
    kHasErrorFieldNumber = 4,
    kHasWarningFieldNumber = 5,
  };
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string label = 2;
  void clear_label() ;
  const std::string& label() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_label(Arg_&& arg, Args_... args);
  std::string* mutable_label();
  PROTOBUF_NODISCARD std::string* release_label();
  void set_allocated_label(std::string* value);

  private:
  const std::string& _internal_label() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_label(
      const std::string& value);
  std::string* _internal_mutable_label();

  public:
  // bool is_present = 3;
  void clear_is_present() ;
  bool is_present() const;
  void set_is_present(bool value);

  private:
  bool _internal_is_present() const;
  void _internal_set_is_present(bool value);

  public:
  // bool has_error = 4;
  void clear_has_error() ;
  bool has_error() const;
  void set_has_error(bool value);

  private:
  bool _internal_has_error() const;
  void _internal_set_has_error(bool value);

  public:
  // bool has_warning = 5;
  void clear_has_warning() ;
  bool has_warning() const;
  void set_has_warning(bool value);

  private:
  bool _internal_has_warning() const;
  void _internal_set_has_warning(bool value);

  public:
  // @@protoc_insertion_point(class_scope:mavsdk.rpc.events.HealthComponentReport)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 0,
      57, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const HealthComponentReport& from_msg);
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr label_;
    bool is_present_;
    bool has_error_;
    bool has_warning_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2fevents_2eproto;
};
// -------------------------------------------------------------------

class HealthAndArmingCheckProblem final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:mavsdk.rpc.events.HealthAndArmingCheckProblem) */ {
 public:
  inline HealthAndArmingCheckProblem() : HealthAndArmingCheckProblem(nullptr) {}
  ~HealthAndArmingCheckProblem() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(HealthAndArmingCheckProblem* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(HealthAndArmingCheckProblem));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR HealthAndArmingCheckProblem(
      ::google::protobuf::internal::ConstantInitialized);

  inline HealthAndArmingCheckProblem(const HealthAndArmingCheckProblem& from) : HealthAndArmingCheckProblem(nullptr, from) {}
  inline HealthAndArmingCheckProblem(HealthAndArmingCheckProblem&& from) noexcept
      : HealthAndArmingCheckProblem(nullptr, std::move(from)) {}
  inline HealthAndArmingCheckProblem& operator=(const HealthAndArmingCheckProblem& from) {
    CopyFrom(from);
    return *this;
  }
  inline HealthAndArmingCheckProblem& operator=(HealthAndArmingCheckProblem&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HealthAndArmingCheckProblem& default_instance() {
    return *internal_default_instance();
  }
  static inline const HealthAndArmingCheckProblem* internal_default_instance() {
    return reinterpret_cast<const HealthAndArmingCheckProblem*>(
        &_HealthAndArmingCheckProblem_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(HealthAndArmingCheckProblem& a, HealthAndArmingCheckProblem& b) { a.Swap(&b); }
  inline void Swap(HealthAndArmingCheckProblem* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HealthAndArmingCheckProblem* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HealthAndArmingCheckProblem* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<HealthAndArmingCheckProblem>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const HealthAndArmingCheckProblem& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const HealthAndArmingCheckProblem& from) { HealthAndArmingCheckProblem::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(HealthAndArmingCheckProblem* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "mavsdk.rpc.events.HealthAndArmingCheckProblem"; }

 protected:
  explicit HealthAndArmingCheckProblem(::google::protobuf::Arena* arena);
  HealthAndArmingCheckProblem(::google::protobuf::Arena* arena, const HealthAndArmingCheckProblem& from);
  HealthAndArmingCheckProblem(::google::protobuf::Arena* arena, HealthAndArmingCheckProblem&& from) noexcept
      : HealthAndArmingCheckProblem(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMessageFieldNumber = 1,
    kDescriptionFieldNumber = 2,
    kHealthComponentFieldNumber = 4,
    kLogLevelFieldNumber = 3,
  };
  // string message = 1;
  void clear_message() ;
  const std::string& message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* value);

  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(
      const std::string& value);
  std::string* _internal_mutable_message();

  public:
  // string description = 2;
  void clear_description() ;
  const std::string& description() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_description(Arg_&& arg, Args_... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* value);

  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(
      const std::string& value);
  std::string* _internal_mutable_description();

  public:
  // string health_component = 4;
  void clear_health_component() ;
  const std::string& health_component() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_health_component(Arg_&& arg, Args_... args);
  std::string* mutable_health_component();
  PROTOBUF_NODISCARD std::string* release_health_component();
  void set_allocated_health_component(std::string* value);

  private:
  const std::string& _internal_health_component() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_health_component(
      const std::string& value);
  std::string* _internal_mutable_health_component();

  public:
  // .mavsdk.rpc.events.LogLevel log_level = 3;
  void clear_log_level() ;
  ::mavsdk::rpc::events::LogLevel log_level() const;
  void set_log_level(::mavsdk::rpc::events::LogLevel value);

  private:
  ::mavsdk::rpc::events::LogLevel _internal_log_level() const;
  void _internal_set_log_level(::mavsdk::rpc::events::LogLevel value);

  public:
  // @@protoc_insertion_point(class_scope:mavsdk.rpc.events.HealthAndArmingCheckProblem)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      88, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const HealthAndArmingCheckProblem& from_msg);
    ::google::protobuf::internal::ArenaStringPtr message_;
    ::google::protobuf::internal::ArenaStringPtr description_;
    ::google::protobuf::internal::ArenaStringPtr health_component_;
    int log_level_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2fevents_2eproto;
};
// -------------------------------------------------------------------

class GetHealthAndArmingChecksReportRequest final
    : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:mavsdk.rpc.events.GetHealthAndArmingChecksReportRequest) */ {
 public:
  inline GetHealthAndArmingChecksReportRequest() : GetHealthAndArmingChecksReportRequest(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GetHealthAndArmingChecksReportRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GetHealthAndArmingChecksReportRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetHealthAndArmingChecksReportRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetHealthAndArmingChecksReportRequest(const GetHealthAndArmingChecksReportRequest& from) : GetHealthAndArmingChecksReportRequest(nullptr, from) {}
  inline GetHealthAndArmingChecksReportRequest(GetHealthAndArmingChecksReportRequest&& from) noexcept
      : GetHealthAndArmingChecksReportRequest(nullptr, std::move(from)) {}
  inline GetHealthAndArmingChecksReportRequest& operator=(const GetHealthAndArmingChecksReportRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetHealthAndArmingChecksReportRequest& operator=(GetHealthAndArmingChecksReportRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetHealthAndArmingChecksReportRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetHealthAndArmingChecksReportRequest* internal_default_instance() {
    return reinterpret_cast<const GetHealthAndArmingChecksReportRequest*>(
        &_GetHealthAndArmingChecksReportRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(GetHealthAndArmingChecksReportRequest& a, GetHealthAndArmingChecksReportRequest& b) { a.Swap(&b); }
  inline void Swap(GetHealthAndArmingChecksReportRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetHealthAndArmingChecksReportRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetHealthAndArmingChecksReportRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<GetHealthAndArmingChecksReportRequest>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetHealthAndArmingChecksReportRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetHealthAndArmingChecksReportRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "mavsdk.rpc.events.GetHealthAndArmingChecksReportRequest"; }

 protected:
  explicit GetHealthAndArmingChecksReportRequest(::google::protobuf::Arena* arena);
  GetHealthAndArmingChecksReportRequest(::google::protobuf::Arena* arena, const GetHealthAndArmingChecksReportRequest& from);
  GetHealthAndArmingChecksReportRequest(::google::protobuf::Arena* arena, GetHealthAndArmingChecksReportRequest&& from) noexcept
      : GetHealthAndArmingChecksReportRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:mavsdk.rpc.events.GetHealthAndArmingChecksReportRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GetHealthAndArmingChecksReportRequest& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_events_2fevents_2eproto;
};
// -------------------------------------------------------------------

class EventsResult final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:mavsdk.rpc.events.EventsResult) */ {
 public:
  inline EventsResult() : EventsResult(nullptr) {}
  ~EventsResult() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(EventsResult* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(EventsResult));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR EventsResult(
      ::google::protobuf::internal::ConstantInitialized);

  inline EventsResult(const EventsResult& from) : EventsResult(nullptr, from) {}
  inline EventsResult(EventsResult&& from) noexcept
      : EventsResult(nullptr, std::move(from)) {}
  inline EventsResult& operator=(const EventsResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline EventsResult& operator=(EventsResult&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EventsResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const EventsResult* internal_default_instance() {
    return reinterpret_cast<const EventsResult*>(
        &_EventsResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(EventsResult& a, EventsResult& b) { a.Swap(&b); }
  inline void Swap(EventsResult* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EventsResult* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EventsResult* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<EventsResult>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EventsResult& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const EventsResult& from) { EventsResult::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(EventsResult* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "mavsdk.rpc.events.EventsResult"; }

 protected:
  explicit EventsResult(::google::protobuf::Arena* arena);
  EventsResult(::google::protobuf::Arena* arena, const EventsResult& from);
  EventsResult(::google::protobuf::Arena* arena, EventsResult&& from) noexcept
      : EventsResult(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Result = EventsResult_Result;
  static constexpr Result RESULT_SUCCESS = EventsResult_Result_RESULT_SUCCESS;
  static constexpr Result RESULT_NOT_AVAILABLE = EventsResult_Result_RESULT_NOT_AVAILABLE;
  static constexpr Result RESULT_CONNECTION_ERROR = EventsResult_Result_RESULT_CONNECTION_ERROR;
  static constexpr Result RESULT_UNSUPPORTED = EventsResult_Result_RESULT_UNSUPPORTED;
  static constexpr Result RESULT_DENIED = EventsResult_Result_RESULT_DENIED;
  static constexpr Result RESULT_FAILED = EventsResult_Result_RESULT_FAILED;
  static constexpr Result RESULT_TIMEOUT = EventsResult_Result_RESULT_TIMEOUT;
  static constexpr Result RESULT_NO_SYSTEM = EventsResult_Result_RESULT_NO_SYSTEM;
  static constexpr Result RESULT_UNKNOWN = EventsResult_Result_RESULT_UNKNOWN;
  static inline bool Result_IsValid(int value) {
    return EventsResult_Result_IsValid(value);
  }
  static constexpr Result Result_MIN = EventsResult_Result_Result_MIN;
  static constexpr Result Result_MAX = EventsResult_Result_Result_MAX;
  static constexpr int Result_ARRAYSIZE = EventsResult_Result_Result_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Result_descriptor() {
    return EventsResult_Result_descriptor();
  }
  template <typename T>
  static inline const std::string& Result_Name(T value) {
    return EventsResult_Result_Name(value);
  }
  static inline bool Result_Parse(absl::string_view name, Result* value) {
    return EventsResult_Result_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kResultStrFieldNumber = 2,
    kResultFieldNumber = 1,
  };
  // string result_str = 2;
  void clear_result_str() ;
  const std::string& result_str() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_result_str(Arg_&& arg, Args_... args);
  std::string* mutable_result_str();
  PROTOBUF_NODISCARD std::string* release_result_str();
  void set_allocated_result_str(std::string* value);

  private:
  const std::string& _internal_result_str() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_result_str(
      const std::string& value);
  std::string* _internal_mutable_result_str();

  public:
  // .mavsdk.rpc.events.EventsResult.Result result = 1;
  void clear_result() ;
  ::mavsdk::rpc::events::EventsResult_Result result() const;
  void set_result(::mavsdk::rpc::events::EventsResult_Result value);

  private:
  ::mavsdk::rpc::events::EventsResult_Result _internal_result() const;
  void _internal_set_result(::mavsdk::rpc::events::EventsResult_Result value);

  public:
  // @@protoc_insertion_point(class_scope:mavsdk.rpc.events.EventsResult)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      49, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const EventsResult& from_msg);
    ::google::protobuf::internal::ArenaStringPtr result_str_;
    int result_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2fevents_2eproto;
};
// -------------------------------------------------------------------

class Event final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:mavsdk.rpc.events.Event) */ {
 public:
  inline Event() : Event(nullptr) {}
  ~Event() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Event* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Event));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Event(
      ::google::protobuf::internal::ConstantInitialized);

  inline Event(const Event& from) : Event(nullptr, from) {}
  inline Event(Event&& from) noexcept
      : Event(nullptr, std::move(from)) {}
  inline Event& operator=(const Event& from) {
    CopyFrom(from);
    return *this;
  }
  inline Event& operator=(Event&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Event& default_instance() {
    return *internal_default_instance();
  }
  static inline const Event* internal_default_instance() {
    return reinterpret_cast<const Event*>(
        &_Event_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(Event& a, Event& b) { a.Swap(&b); }
  inline void Swap(Event* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Event* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Event* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Event>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Event& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Event& from) { Event::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Event* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "mavsdk.rpc.events.Event"; }

 protected:
  explicit Event(::google::protobuf::Arena* arena);
  Event(::google::protobuf::Arena* arena, const Event& from);
  Event(::google::protobuf::Arena* arena, Event&& from) noexcept
      : Event(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMessageFieldNumber = 2,
    kDescriptionFieldNumber = 3,
    kEventNamespaceFieldNumber = 5,
    kEventNameFieldNumber = 6,
    kCompidFieldNumber = 1,
    kLogLevelFieldNumber = 4,
  };
  // string message = 2;
  void clear_message() ;
  const std::string& message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* value);

  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(
      const std::string& value);
  std::string* _internal_mutable_message();

  public:
  // string description = 3;
  void clear_description() ;
  const std::string& description() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_description(Arg_&& arg, Args_... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* value);

  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(
      const std::string& value);
  std::string* _internal_mutable_description();

  public:
  // string event_namespace = 5;
  void clear_event_namespace() ;
  const std::string& event_namespace() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_event_namespace(Arg_&& arg, Args_... args);
  std::string* mutable_event_namespace();
  PROTOBUF_NODISCARD std::string* release_event_namespace();
  void set_allocated_event_namespace(std::string* value);

  private:
  const std::string& _internal_event_namespace() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_event_namespace(
      const std::string& value);
  std::string* _internal_mutable_event_namespace();

  public:
  // string event_name = 6;
  void clear_event_name() ;
  const std::string& event_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_event_name(Arg_&& arg, Args_... args);
  std::string* mutable_event_name();
  PROTOBUF_NODISCARD std::string* release_event_name();
  void set_allocated_event_name(std::string* value);

  private:
  const std::string& _internal_event_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_event_name(
      const std::string& value);
  std::string* _internal_mutable_event_name();

  public:
  // uint32 compid = 1;
  void clear_compid() ;
  ::uint32_t compid() const;
  void set_compid(::uint32_t value);

  private:
  ::uint32_t _internal_compid() const;
  void _internal_set_compid(::uint32_t value);

  public:
  // .mavsdk.rpc.events.LogLevel log_level = 4;
  void clear_log_level() ;
  ::mavsdk::rpc::events::LogLevel log_level() const;
  void set_log_level(::mavsdk::rpc::events::LogLevel value);

  private:
  ::mavsdk::rpc::events::LogLevel _internal_log_level() const;
  void _internal_set_log_level(::mavsdk::rpc::events::LogLevel value);

  public:
  // @@protoc_insertion_point(class_scope:mavsdk.rpc.events.Event)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 0,
      75, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Event& from_msg);
    ::google::protobuf::internal::ArenaStringPtr message_;
    ::google::protobuf::internal::ArenaStringPtr description_;
    ::google::protobuf::internal::ArenaStringPtr event_namespace_;
    ::google::protobuf::internal::ArenaStringPtr event_name_;
    ::uint32_t compid_;
    int log_level_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2fevents_2eproto;
};
// -------------------------------------------------------------------

class HealthAndArmingCheckMode final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:mavsdk.rpc.events.HealthAndArmingCheckMode) */ {
 public:
  inline HealthAndArmingCheckMode() : HealthAndArmingCheckMode(nullptr) {}
  ~HealthAndArmingCheckMode() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(HealthAndArmingCheckMode* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(HealthAndArmingCheckMode));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR HealthAndArmingCheckMode(
      ::google::protobuf::internal::ConstantInitialized);

  inline HealthAndArmingCheckMode(const HealthAndArmingCheckMode& from) : HealthAndArmingCheckMode(nullptr, from) {}
  inline HealthAndArmingCheckMode(HealthAndArmingCheckMode&& from) noexcept
      : HealthAndArmingCheckMode(nullptr, std::move(from)) {}
  inline HealthAndArmingCheckMode& operator=(const HealthAndArmingCheckMode& from) {
    CopyFrom(from);
    return *this;
  }
  inline HealthAndArmingCheckMode& operator=(HealthAndArmingCheckMode&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HealthAndArmingCheckMode& default_instance() {
    return *internal_default_instance();
  }
  static inline const HealthAndArmingCheckMode* internal_default_instance() {
    return reinterpret_cast<const HealthAndArmingCheckMode*>(
        &_HealthAndArmingCheckMode_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(HealthAndArmingCheckMode& a, HealthAndArmingCheckMode& b) { a.Swap(&b); }
  inline void Swap(HealthAndArmingCheckMode* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HealthAndArmingCheckMode* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HealthAndArmingCheckMode* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<HealthAndArmingCheckMode>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const HealthAndArmingCheckMode& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const HealthAndArmingCheckMode& from) { HealthAndArmingCheckMode::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(HealthAndArmingCheckMode* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "mavsdk.rpc.events.HealthAndArmingCheckMode"; }

 protected:
  explicit HealthAndArmingCheckMode(::google::protobuf::Arena* arena);
  HealthAndArmingCheckMode(::google::protobuf::Arena* arena, const HealthAndArmingCheckMode& from);
  HealthAndArmingCheckMode(::google::protobuf::Arena* arena, HealthAndArmingCheckMode&& from) noexcept
      : HealthAndArmingCheckMode(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kProblemsFieldNumber = 3,
    kModeNameFieldNumber = 1,
    kCanArmOrRunFieldNumber = 2,
  };
  // repeated .mavsdk.rpc.events.HealthAndArmingCheckProblem problems = 3;
  int problems_size() const;
  private:
  int _internal_problems_size() const;

  public:
  void clear_problems() ;
  ::mavsdk::rpc::events::HealthAndArmingCheckProblem* mutable_problems(int index);
  ::google::protobuf::RepeatedPtrField<::mavsdk::rpc::events::HealthAndArmingCheckProblem>* mutable_problems();

  private:
  const ::google::protobuf::RepeatedPtrField<::mavsdk::rpc::events::HealthAndArmingCheckProblem>& _internal_problems() const;
  ::google::protobuf::RepeatedPtrField<::mavsdk::rpc::events::HealthAndArmingCheckProblem>* _internal_mutable_problems();
  public:
  const ::mavsdk::rpc::events::HealthAndArmingCheckProblem& problems(int index) const;
  ::mavsdk::rpc::events::HealthAndArmingCheckProblem* add_problems();
  const ::google::protobuf::RepeatedPtrField<::mavsdk::rpc::events::HealthAndArmingCheckProblem>& problems() const;
  // string mode_name = 1;
  void clear_mode_name() ;
  const std::string& mode_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_mode_name(Arg_&& arg, Args_... args);
  std::string* mutable_mode_name();
  PROTOBUF_NODISCARD std::string* release_mode_name();
  void set_allocated_mode_name(std::string* value);

  private:
  const std::string& _internal_mode_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mode_name(
      const std::string& value);
  std::string* _internal_mutable_mode_name();

  public:
  // bool can_arm_or_run = 2;
  void clear_can_arm_or_run() ;
  bool can_arm_or_run() const;
  void set_can_arm_or_run(bool value);

  private:
  bool _internal_can_arm_or_run() const;
  void _internal_set_can_arm_or_run(bool value);

  public:
  // @@protoc_insertion_point(class_scope:mavsdk.rpc.events.HealthAndArmingCheckMode)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      60, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const HealthAndArmingCheckMode& from_msg);
    ::google::protobuf::RepeatedPtrField< ::mavsdk::rpc::events::HealthAndArmingCheckProblem > problems_;
    ::google::protobuf::internal::ArenaStringPtr mode_name_;
    bool can_arm_or_run_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2fevents_2eproto;
};
// -------------------------------------------------------------------

class EventsResponse final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:mavsdk.rpc.events.EventsResponse) */ {
 public:
  inline EventsResponse() : EventsResponse(nullptr) {}
  ~EventsResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(EventsResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(EventsResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR EventsResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline EventsResponse(const EventsResponse& from) : EventsResponse(nullptr, from) {}
  inline EventsResponse(EventsResponse&& from) noexcept
      : EventsResponse(nullptr, std::move(from)) {}
  inline EventsResponse& operator=(const EventsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline EventsResponse& operator=(EventsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EventsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const EventsResponse* internal_default_instance() {
    return reinterpret_cast<const EventsResponse*>(
        &_EventsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(EventsResponse& a, EventsResponse& b) { a.Swap(&b); }
  inline void Swap(EventsResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EventsResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EventsResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<EventsResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EventsResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const EventsResponse& from) { EventsResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(EventsResponse* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "mavsdk.rpc.events.EventsResponse"; }

 protected:
  explicit EventsResponse(::google::protobuf::Arena* arena);
  EventsResponse(::google::protobuf::Arena* arena, const EventsResponse& from);
  EventsResponse(::google::protobuf::Arena* arena, EventsResponse&& from) noexcept
      : EventsResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEventFieldNumber = 1,
  };
  // .mavsdk.rpc.events.Event event = 1;
  bool has_event() const;
  void clear_event() ;
  const ::mavsdk::rpc::events::Event& event() const;
  PROTOBUF_NODISCARD ::mavsdk::rpc::events::Event* release_event();
  ::mavsdk::rpc::events::Event* mutable_event();
  void set_allocated_event(::mavsdk::rpc::events::Event* value);
  void unsafe_arena_set_allocated_event(::mavsdk::rpc::events::Event* value);
  ::mavsdk::rpc::events::Event* unsafe_arena_release_event();

  private:
  const ::mavsdk::rpc::events::Event& _internal_event() const;
  ::mavsdk::rpc::events::Event* _internal_mutable_event();

  public:
  // @@protoc_insertion_point(class_scope:mavsdk.rpc.events.EventsResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const EventsResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::mavsdk::rpc::events::Event* event_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2fevents_2eproto;
};
// -------------------------------------------------------------------

class HealthAndArmingCheckReport final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:mavsdk.rpc.events.HealthAndArmingCheckReport) */ {
 public:
  inline HealthAndArmingCheckReport() : HealthAndArmingCheckReport(nullptr) {}
  ~HealthAndArmingCheckReport() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(HealthAndArmingCheckReport* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(HealthAndArmingCheckReport));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR HealthAndArmingCheckReport(
      ::google::protobuf::internal::ConstantInitialized);

  inline HealthAndArmingCheckReport(const HealthAndArmingCheckReport& from) : HealthAndArmingCheckReport(nullptr, from) {}
  inline HealthAndArmingCheckReport(HealthAndArmingCheckReport&& from) noexcept
      : HealthAndArmingCheckReport(nullptr, std::move(from)) {}
  inline HealthAndArmingCheckReport& operator=(const HealthAndArmingCheckReport& from) {
    CopyFrom(from);
    return *this;
  }
  inline HealthAndArmingCheckReport& operator=(HealthAndArmingCheckReport&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HealthAndArmingCheckReport& default_instance() {
    return *internal_default_instance();
  }
  static inline const HealthAndArmingCheckReport* internal_default_instance() {
    return reinterpret_cast<const HealthAndArmingCheckReport*>(
        &_HealthAndArmingCheckReport_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(HealthAndArmingCheckReport& a, HealthAndArmingCheckReport& b) { a.Swap(&b); }
  inline void Swap(HealthAndArmingCheckReport* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HealthAndArmingCheckReport* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HealthAndArmingCheckReport* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<HealthAndArmingCheckReport>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const HealthAndArmingCheckReport& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const HealthAndArmingCheckReport& from) { HealthAndArmingCheckReport::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(HealthAndArmingCheckReport* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "mavsdk.rpc.events.HealthAndArmingCheckReport"; }

 protected:
  explicit HealthAndArmingCheckReport(::google::protobuf::Arena* arena);
  HealthAndArmingCheckReport(::google::protobuf::Arena* arena, const HealthAndArmingCheckReport& from);
  HealthAndArmingCheckReport(::google::protobuf::Arena* arena, HealthAndArmingCheckReport&& from) noexcept
      : HealthAndArmingCheckReport(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kHealthComponentsFieldNumber = 2,
    kAllProblemsFieldNumber = 3,
    kCurrentModeIntentionFieldNumber = 1,
  };
  // repeated .mavsdk.rpc.events.HealthComponentReport health_components = 2;
  int health_components_size() const;
  private:
  int _internal_health_components_size() const;

  public:
  void clear_health_components() ;
  ::mavsdk::rpc::events::HealthComponentReport* mutable_health_components(int index);
  ::google::protobuf::RepeatedPtrField<::mavsdk::rpc::events::HealthComponentReport>* mutable_health_components();

  private:
  const ::google::protobuf::RepeatedPtrField<::mavsdk::rpc::events::HealthComponentReport>& _internal_health_components() const;
  ::google::protobuf::RepeatedPtrField<::mavsdk::rpc::events::HealthComponentReport>* _internal_mutable_health_components();
  public:
  const ::mavsdk::rpc::events::HealthComponentReport& health_components(int index) const;
  ::mavsdk::rpc::events::HealthComponentReport* add_health_components();
  const ::google::protobuf::RepeatedPtrField<::mavsdk::rpc::events::HealthComponentReport>& health_components() const;
  // repeated .mavsdk.rpc.events.HealthAndArmingCheckProblem all_problems = 3;
  int all_problems_size() const;
  private:
  int _internal_all_problems_size() const;

  public:
  void clear_all_problems() ;
  ::mavsdk::rpc::events::HealthAndArmingCheckProblem* mutable_all_problems(int index);
  ::google::protobuf::RepeatedPtrField<::mavsdk::rpc::events::HealthAndArmingCheckProblem>* mutable_all_problems();

  private:
  const ::google::protobuf::RepeatedPtrField<::mavsdk::rpc::events::HealthAndArmingCheckProblem>& _internal_all_problems() const;
  ::google::protobuf::RepeatedPtrField<::mavsdk::rpc::events::HealthAndArmingCheckProblem>* _internal_mutable_all_problems();
  public:
  const ::mavsdk::rpc::events::HealthAndArmingCheckProblem& all_problems(int index) const;
  ::mavsdk::rpc::events::HealthAndArmingCheckProblem* add_all_problems();
  const ::google::protobuf::RepeatedPtrField<::mavsdk::rpc::events::HealthAndArmingCheckProblem>& all_problems() const;
  // .mavsdk.rpc.events.HealthAndArmingCheckMode current_mode_intention = 1;
  bool has_current_mode_intention() const;
  void clear_current_mode_intention() ;
  const ::mavsdk::rpc::events::HealthAndArmingCheckMode& current_mode_intention() const;
  PROTOBUF_NODISCARD ::mavsdk::rpc::events::HealthAndArmingCheckMode* release_current_mode_intention();
  ::mavsdk::rpc::events::HealthAndArmingCheckMode* mutable_current_mode_intention();
  void set_allocated_current_mode_intention(::mavsdk::rpc::events::HealthAndArmingCheckMode* value);
  void unsafe_arena_set_allocated_current_mode_intention(::mavsdk::rpc::events::HealthAndArmingCheckMode* value);
  ::mavsdk::rpc::events::HealthAndArmingCheckMode* unsafe_arena_release_current_mode_intention();

  private:
  const ::mavsdk::rpc::events::HealthAndArmingCheckMode& _internal_current_mode_intention() const;
  ::mavsdk::rpc::events::HealthAndArmingCheckMode* _internal_mutable_current_mode_intention();

  public:
  // @@protoc_insertion_point(class_scope:mavsdk.rpc.events.HealthAndArmingCheckReport)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 3,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const HealthAndArmingCheckReport& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::mavsdk::rpc::events::HealthComponentReport > health_components_;
    ::google::protobuf::RepeatedPtrField< ::mavsdk::rpc::events::HealthAndArmingCheckProblem > all_problems_;
    ::mavsdk::rpc::events::HealthAndArmingCheckMode* current_mode_intention_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2fevents_2eproto;
};
// -------------------------------------------------------------------

class HealthAndArmingChecksResponse final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:mavsdk.rpc.events.HealthAndArmingChecksResponse) */ {
 public:
  inline HealthAndArmingChecksResponse() : HealthAndArmingChecksResponse(nullptr) {}
  ~HealthAndArmingChecksResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(HealthAndArmingChecksResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(HealthAndArmingChecksResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR HealthAndArmingChecksResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline HealthAndArmingChecksResponse(const HealthAndArmingChecksResponse& from) : HealthAndArmingChecksResponse(nullptr, from) {}
  inline HealthAndArmingChecksResponse(HealthAndArmingChecksResponse&& from) noexcept
      : HealthAndArmingChecksResponse(nullptr, std::move(from)) {}
  inline HealthAndArmingChecksResponse& operator=(const HealthAndArmingChecksResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline HealthAndArmingChecksResponse& operator=(HealthAndArmingChecksResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HealthAndArmingChecksResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const HealthAndArmingChecksResponse* internal_default_instance() {
    return reinterpret_cast<const HealthAndArmingChecksResponse*>(
        &_HealthAndArmingChecksResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(HealthAndArmingChecksResponse& a, HealthAndArmingChecksResponse& b) { a.Swap(&b); }
  inline void Swap(HealthAndArmingChecksResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HealthAndArmingChecksResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HealthAndArmingChecksResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<HealthAndArmingChecksResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const HealthAndArmingChecksResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const HealthAndArmingChecksResponse& from) { HealthAndArmingChecksResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(HealthAndArmingChecksResponse* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "mavsdk.rpc.events.HealthAndArmingChecksResponse"; }

 protected:
  explicit HealthAndArmingChecksResponse(::google::protobuf::Arena* arena);
  HealthAndArmingChecksResponse(::google::protobuf::Arena* arena, const HealthAndArmingChecksResponse& from);
  HealthAndArmingChecksResponse(::google::protobuf::Arena* arena, HealthAndArmingChecksResponse&& from) noexcept
      : HealthAndArmingChecksResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kReportFieldNumber = 1,
  };
  // .mavsdk.rpc.events.HealthAndArmingCheckReport report = 1;
  bool has_report() const;
  void clear_report() ;
  const ::mavsdk::rpc::events::HealthAndArmingCheckReport& report() const;
  PROTOBUF_NODISCARD ::mavsdk::rpc::events::HealthAndArmingCheckReport* release_report();
  ::mavsdk::rpc::events::HealthAndArmingCheckReport* mutable_report();
  void set_allocated_report(::mavsdk::rpc::events::HealthAndArmingCheckReport* value);
  void unsafe_arena_set_allocated_report(::mavsdk::rpc::events::HealthAndArmingCheckReport* value);
  ::mavsdk::rpc::events::HealthAndArmingCheckReport* unsafe_arena_release_report();

  private:
  const ::mavsdk::rpc::events::HealthAndArmingCheckReport& _internal_report() const;
  ::mavsdk::rpc::events::HealthAndArmingCheckReport* _internal_mutable_report();

  public:
  // @@protoc_insertion_point(class_scope:mavsdk.rpc.events.HealthAndArmingChecksResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const HealthAndArmingChecksResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::mavsdk::rpc::events::HealthAndArmingCheckReport* report_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2fevents_2eproto;
};
// -------------------------------------------------------------------

class GetHealthAndArmingChecksReportResponse final
    : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:mavsdk.rpc.events.GetHealthAndArmingChecksReportResponse) */ {
 public:
  inline GetHealthAndArmingChecksReportResponse() : GetHealthAndArmingChecksReportResponse(nullptr) {}
  ~GetHealthAndArmingChecksReportResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GetHealthAndArmingChecksReportResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GetHealthAndArmingChecksReportResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetHealthAndArmingChecksReportResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetHealthAndArmingChecksReportResponse(const GetHealthAndArmingChecksReportResponse& from) : GetHealthAndArmingChecksReportResponse(nullptr, from) {}
  inline GetHealthAndArmingChecksReportResponse(GetHealthAndArmingChecksReportResponse&& from) noexcept
      : GetHealthAndArmingChecksReportResponse(nullptr, std::move(from)) {}
  inline GetHealthAndArmingChecksReportResponse& operator=(const GetHealthAndArmingChecksReportResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetHealthAndArmingChecksReportResponse& operator=(GetHealthAndArmingChecksReportResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetHealthAndArmingChecksReportResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetHealthAndArmingChecksReportResponse* internal_default_instance() {
    return reinterpret_cast<const GetHealthAndArmingChecksReportResponse*>(
        &_GetHealthAndArmingChecksReportResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(GetHealthAndArmingChecksReportResponse& a, GetHealthAndArmingChecksReportResponse& b) { a.Swap(&b); }
  inline void Swap(GetHealthAndArmingChecksReportResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetHealthAndArmingChecksReportResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetHealthAndArmingChecksReportResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<GetHealthAndArmingChecksReportResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetHealthAndArmingChecksReportResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetHealthAndArmingChecksReportResponse& from) { GetHealthAndArmingChecksReportResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(GetHealthAndArmingChecksReportResponse* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "mavsdk.rpc.events.GetHealthAndArmingChecksReportResponse"; }

 protected:
  explicit GetHealthAndArmingChecksReportResponse(::google::protobuf::Arena* arena);
  GetHealthAndArmingChecksReportResponse(::google::protobuf::Arena* arena, const GetHealthAndArmingChecksReportResponse& from);
  GetHealthAndArmingChecksReportResponse(::google::protobuf::Arena* arena, GetHealthAndArmingChecksReportResponse&& from) noexcept
      : GetHealthAndArmingChecksReportResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEventsResultFieldNumber = 1,
    kReportFieldNumber = 2,
  };
  // .mavsdk.rpc.events.EventsResult events_result = 1;
  bool has_events_result() const;
  void clear_events_result() ;
  const ::mavsdk::rpc::events::EventsResult& events_result() const;
  PROTOBUF_NODISCARD ::mavsdk::rpc::events::EventsResult* release_events_result();
  ::mavsdk::rpc::events::EventsResult* mutable_events_result();
  void set_allocated_events_result(::mavsdk::rpc::events::EventsResult* value);
  void unsafe_arena_set_allocated_events_result(::mavsdk::rpc::events::EventsResult* value);
  ::mavsdk::rpc::events::EventsResult* unsafe_arena_release_events_result();

  private:
  const ::mavsdk::rpc::events::EventsResult& _internal_events_result() const;
  ::mavsdk::rpc::events::EventsResult* _internal_mutable_events_result();

  public:
  // .mavsdk.rpc.events.HealthAndArmingCheckReport report = 2;
  bool has_report() const;
  void clear_report() ;
  const ::mavsdk::rpc::events::HealthAndArmingCheckReport& report() const;
  PROTOBUF_NODISCARD ::mavsdk::rpc::events::HealthAndArmingCheckReport* release_report();
  ::mavsdk::rpc::events::HealthAndArmingCheckReport* mutable_report();
  void set_allocated_report(::mavsdk::rpc::events::HealthAndArmingCheckReport* value);
  void unsafe_arena_set_allocated_report(::mavsdk::rpc::events::HealthAndArmingCheckReport* value);
  ::mavsdk::rpc::events::HealthAndArmingCheckReport* unsafe_arena_release_report();

  private:
  const ::mavsdk::rpc::events::HealthAndArmingCheckReport& _internal_report() const;
  ::mavsdk::rpc::events::HealthAndArmingCheckReport* _internal_mutable_report();

  public:
  // @@protoc_insertion_point(class_scope:mavsdk.rpc.events.GetHealthAndArmingChecksReportResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GetHealthAndArmingChecksReportResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::mavsdk::rpc::events::EventsResult* events_result_;
    ::mavsdk::rpc::events::HealthAndArmingCheckReport* report_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_events_2fevents_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Event

// uint32 compid = 1;
inline void Event::clear_compid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.compid_ = 0u;
}
inline ::uint32_t Event::compid() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.events.Event.compid)
  return _internal_compid();
}
inline void Event::set_compid(::uint32_t value) {
  _internal_set_compid(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.events.Event.compid)
}
inline ::uint32_t Event::_internal_compid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.compid_;
}
inline void Event::_internal_set_compid(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.compid_ = value;
}

// string message = 2;
inline void Event::clear_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.ClearToEmpty();
}
inline const std::string& Event::message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.events.Event.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Event::set_message(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mavsdk.rpc.events.Event.message)
}
inline std::string* Event::mutable_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.events.Event.message)
  return _s;
}
inline const std::string& Event::_internal_message() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.message_.Get();
}
inline void Event::_internal_set_message(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.Set(value, GetArena());
}
inline std::string* Event::_internal_mutable_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.message_.Mutable( GetArena());
}
inline std::string* Event::release_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:mavsdk.rpc.events.Event.message)
  return _impl_.message_.Release();
}
inline void Event::set_allocated_message(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.events.Event.message)
}

// string description = 3;
inline void Event::clear_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.description_.ClearToEmpty();
}
inline const std::string& Event::description() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.events.Event.description)
  return _internal_description();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Event::set_description(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.description_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mavsdk.rpc.events.Event.description)
}
inline std::string* Event::mutable_description() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.events.Event.description)
  return _s;
}
inline const std::string& Event::_internal_description() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.description_.Get();
}
inline void Event::_internal_set_description(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.description_.Set(value, GetArena());
}
inline std::string* Event::_internal_mutable_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.description_.Mutable( GetArena());
}
inline std::string* Event::release_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:mavsdk.rpc.events.Event.description)
  return _impl_.description_.Release();
}
inline void Event::set_allocated_description(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.description_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.events.Event.description)
}

// .mavsdk.rpc.events.LogLevel log_level = 4;
inline void Event::clear_log_level() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.log_level_ = 0;
}
inline ::mavsdk::rpc::events::LogLevel Event::log_level() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.events.Event.log_level)
  return _internal_log_level();
}
inline void Event::set_log_level(::mavsdk::rpc::events::LogLevel value) {
  _internal_set_log_level(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.events.Event.log_level)
}
inline ::mavsdk::rpc::events::LogLevel Event::_internal_log_level() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::mavsdk::rpc::events::LogLevel>(_impl_.log_level_);
}
inline void Event::_internal_set_log_level(::mavsdk::rpc::events::LogLevel value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.log_level_ = value;
}

// string event_namespace = 5;
inline void Event::clear_event_namespace() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.event_namespace_.ClearToEmpty();
}
inline const std::string& Event::event_namespace() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.events.Event.event_namespace)
  return _internal_event_namespace();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Event::set_event_namespace(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.event_namespace_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mavsdk.rpc.events.Event.event_namespace)
}
inline std::string* Event::mutable_event_namespace() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_event_namespace();
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.events.Event.event_namespace)
  return _s;
}
inline const std::string& Event::_internal_event_namespace() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.event_namespace_.Get();
}
inline void Event::_internal_set_event_namespace(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.event_namespace_.Set(value, GetArena());
}
inline std::string* Event::_internal_mutable_event_namespace() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.event_namespace_.Mutable( GetArena());
}
inline std::string* Event::release_event_namespace() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:mavsdk.rpc.events.Event.event_namespace)
  return _impl_.event_namespace_.Release();
}
inline void Event::set_allocated_event_namespace(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.event_namespace_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.event_namespace_.IsDefault()) {
    _impl_.event_namespace_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.events.Event.event_namespace)
}

// string event_name = 6;
inline void Event::clear_event_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.event_name_.ClearToEmpty();
}
inline const std::string& Event::event_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.events.Event.event_name)
  return _internal_event_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Event::set_event_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.event_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mavsdk.rpc.events.Event.event_name)
}
inline std::string* Event::mutable_event_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_event_name();
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.events.Event.event_name)
  return _s;
}
inline const std::string& Event::_internal_event_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.event_name_.Get();
}
inline void Event::_internal_set_event_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.event_name_.Set(value, GetArena());
}
inline std::string* Event::_internal_mutable_event_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.event_name_.Mutable( GetArena());
}
inline std::string* Event::release_event_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:mavsdk.rpc.events.Event.event_name)
  return _impl_.event_name_.Release();
}
inline void Event::set_allocated_event_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.event_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.event_name_.IsDefault()) {
    _impl_.event_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.events.Event.event_name)
}

// -------------------------------------------------------------------

// HealthAndArmingCheckProblem

// string message = 1;
inline void HealthAndArmingCheckProblem::clear_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.ClearToEmpty();
}
inline const std::string& HealthAndArmingCheckProblem::message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.events.HealthAndArmingCheckProblem.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void HealthAndArmingCheckProblem::set_message(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mavsdk.rpc.events.HealthAndArmingCheckProblem.message)
}
inline std::string* HealthAndArmingCheckProblem::mutable_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.events.HealthAndArmingCheckProblem.message)
  return _s;
}
inline const std::string& HealthAndArmingCheckProblem::_internal_message() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.message_.Get();
}
inline void HealthAndArmingCheckProblem::_internal_set_message(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.Set(value, GetArena());
}
inline std::string* HealthAndArmingCheckProblem::_internal_mutable_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.message_.Mutable( GetArena());
}
inline std::string* HealthAndArmingCheckProblem::release_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:mavsdk.rpc.events.HealthAndArmingCheckProblem.message)
  return _impl_.message_.Release();
}
inline void HealthAndArmingCheckProblem::set_allocated_message(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.events.HealthAndArmingCheckProblem.message)
}

// string description = 2;
inline void HealthAndArmingCheckProblem::clear_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.description_.ClearToEmpty();
}
inline const std::string& HealthAndArmingCheckProblem::description() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.events.HealthAndArmingCheckProblem.description)
  return _internal_description();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void HealthAndArmingCheckProblem::set_description(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.description_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mavsdk.rpc.events.HealthAndArmingCheckProblem.description)
}
inline std::string* HealthAndArmingCheckProblem::mutable_description() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.events.HealthAndArmingCheckProblem.description)
  return _s;
}
inline const std::string& HealthAndArmingCheckProblem::_internal_description() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.description_.Get();
}
inline void HealthAndArmingCheckProblem::_internal_set_description(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.description_.Set(value, GetArena());
}
inline std::string* HealthAndArmingCheckProblem::_internal_mutable_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.description_.Mutable( GetArena());
}
inline std::string* HealthAndArmingCheckProblem::release_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:mavsdk.rpc.events.HealthAndArmingCheckProblem.description)
  return _impl_.description_.Release();
}
inline void HealthAndArmingCheckProblem::set_allocated_description(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.description_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.events.HealthAndArmingCheckProblem.description)
}

// .mavsdk.rpc.events.LogLevel log_level = 3;
inline void HealthAndArmingCheckProblem::clear_log_level() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.log_level_ = 0;
}
inline ::mavsdk::rpc::events::LogLevel HealthAndArmingCheckProblem::log_level() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.events.HealthAndArmingCheckProblem.log_level)
  return _internal_log_level();
}
inline void HealthAndArmingCheckProblem::set_log_level(::mavsdk::rpc::events::LogLevel value) {
  _internal_set_log_level(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.events.HealthAndArmingCheckProblem.log_level)
}
inline ::mavsdk::rpc::events::LogLevel HealthAndArmingCheckProblem::_internal_log_level() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::mavsdk::rpc::events::LogLevel>(_impl_.log_level_);
}
inline void HealthAndArmingCheckProblem::_internal_set_log_level(::mavsdk::rpc::events::LogLevel value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.log_level_ = value;
}

// string health_component = 4;
inline void HealthAndArmingCheckProblem::clear_health_component() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.health_component_.ClearToEmpty();
}
inline const std::string& HealthAndArmingCheckProblem::health_component() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.events.HealthAndArmingCheckProblem.health_component)
  return _internal_health_component();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void HealthAndArmingCheckProblem::set_health_component(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.health_component_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mavsdk.rpc.events.HealthAndArmingCheckProblem.health_component)
}
inline std::string* HealthAndArmingCheckProblem::mutable_health_component() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_health_component();
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.events.HealthAndArmingCheckProblem.health_component)
  return _s;
}
inline const std::string& HealthAndArmingCheckProblem::_internal_health_component() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.health_component_.Get();
}
inline void HealthAndArmingCheckProblem::_internal_set_health_component(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.health_component_.Set(value, GetArena());
}
inline std::string* HealthAndArmingCheckProblem::_internal_mutable_health_component() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.health_component_.Mutable( GetArena());
}
inline std::string* HealthAndArmingCheckProblem::release_health_component() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:mavsdk.rpc.events.HealthAndArmingCheckProblem.health_component)
  return _impl_.health_component_.Release();
}
inline void HealthAndArmingCheckProblem::set_allocated_health_component(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.health_component_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.health_component_.IsDefault()) {
    _impl_.health_component_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.events.HealthAndArmingCheckProblem.health_component)
}

// -------------------------------------------------------------------

// HealthAndArmingCheckMode

// string mode_name = 1;
inline void HealthAndArmingCheckMode::clear_mode_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.mode_name_.ClearToEmpty();
}
inline const std::string& HealthAndArmingCheckMode::mode_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.events.HealthAndArmingCheckMode.mode_name)
  return _internal_mode_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void HealthAndArmingCheckMode::set_mode_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.mode_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mavsdk.rpc.events.HealthAndArmingCheckMode.mode_name)
}
inline std::string* HealthAndArmingCheckMode::mutable_mode_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_mode_name();
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.events.HealthAndArmingCheckMode.mode_name)
  return _s;
}
inline const std::string& HealthAndArmingCheckMode::_internal_mode_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.mode_name_.Get();
}
inline void HealthAndArmingCheckMode::_internal_set_mode_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.mode_name_.Set(value, GetArena());
}
inline std::string* HealthAndArmingCheckMode::_internal_mutable_mode_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.mode_name_.Mutable( GetArena());
}
inline std::string* HealthAndArmingCheckMode::release_mode_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:mavsdk.rpc.events.HealthAndArmingCheckMode.mode_name)
  return _impl_.mode_name_.Release();
}
inline void HealthAndArmingCheckMode::set_allocated_mode_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.mode_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.mode_name_.IsDefault()) {
    _impl_.mode_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.events.HealthAndArmingCheckMode.mode_name)
}

// bool can_arm_or_run = 2;
inline void HealthAndArmingCheckMode::clear_can_arm_or_run() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.can_arm_or_run_ = false;
}
inline bool HealthAndArmingCheckMode::can_arm_or_run() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.events.HealthAndArmingCheckMode.can_arm_or_run)
  return _internal_can_arm_or_run();
}
inline void HealthAndArmingCheckMode::set_can_arm_or_run(bool value) {
  _internal_set_can_arm_or_run(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.events.HealthAndArmingCheckMode.can_arm_or_run)
}
inline bool HealthAndArmingCheckMode::_internal_can_arm_or_run() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.can_arm_or_run_;
}
inline void HealthAndArmingCheckMode::_internal_set_can_arm_or_run(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.can_arm_or_run_ = value;
}

// repeated .mavsdk.rpc.events.HealthAndArmingCheckProblem problems = 3;
inline int HealthAndArmingCheckMode::_internal_problems_size() const {
  return _internal_problems().size();
}
inline int HealthAndArmingCheckMode::problems_size() const {
  return _internal_problems_size();
}
inline void HealthAndArmingCheckMode::clear_problems() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.problems_.Clear();
}
inline ::mavsdk::rpc::events::HealthAndArmingCheckProblem* HealthAndArmingCheckMode::mutable_problems(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.events.HealthAndArmingCheckMode.problems)
  return _internal_mutable_problems()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::mavsdk::rpc::events::HealthAndArmingCheckProblem>* HealthAndArmingCheckMode::mutable_problems()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:mavsdk.rpc.events.HealthAndArmingCheckMode.problems)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_problems();
}
inline const ::mavsdk::rpc::events::HealthAndArmingCheckProblem& HealthAndArmingCheckMode::problems(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.events.HealthAndArmingCheckMode.problems)
  return _internal_problems().Get(index);
}
inline ::mavsdk::rpc::events::HealthAndArmingCheckProblem* HealthAndArmingCheckMode::add_problems() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::mavsdk::rpc::events::HealthAndArmingCheckProblem* _add = _internal_mutable_problems()->Add();
  // @@protoc_insertion_point(field_add:mavsdk.rpc.events.HealthAndArmingCheckMode.problems)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::mavsdk::rpc::events::HealthAndArmingCheckProblem>& HealthAndArmingCheckMode::problems() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:mavsdk.rpc.events.HealthAndArmingCheckMode.problems)
  return _internal_problems();
}
inline const ::google::protobuf::RepeatedPtrField<::mavsdk::rpc::events::HealthAndArmingCheckProblem>&
HealthAndArmingCheckMode::_internal_problems() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.problems_;
}
inline ::google::protobuf::RepeatedPtrField<::mavsdk::rpc::events::HealthAndArmingCheckProblem>*
HealthAndArmingCheckMode::_internal_mutable_problems() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.problems_;
}

// -------------------------------------------------------------------

// HealthComponentReport

// string name = 1;
inline void HealthComponentReport::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& HealthComponentReport::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.events.HealthComponentReport.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void HealthComponentReport::set_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mavsdk.rpc.events.HealthComponentReport.name)
}
inline std::string* HealthComponentReport::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.events.HealthComponentReport.name)
  return _s;
}
inline const std::string& HealthComponentReport::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void HealthComponentReport::_internal_set_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(value, GetArena());
}
inline std::string* HealthComponentReport::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* HealthComponentReport::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:mavsdk.rpc.events.HealthComponentReport.name)
  return _impl_.name_.Release();
}
inline void HealthComponentReport::set_allocated_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.events.HealthComponentReport.name)
}

// string label = 2;
inline void HealthComponentReport::clear_label() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.label_.ClearToEmpty();
}
inline const std::string& HealthComponentReport::label() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.events.HealthComponentReport.label)
  return _internal_label();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void HealthComponentReport::set_label(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.label_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mavsdk.rpc.events.HealthComponentReport.label)
}
inline std::string* HealthComponentReport::mutable_label() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_label();
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.events.HealthComponentReport.label)
  return _s;
}
inline const std::string& HealthComponentReport::_internal_label() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.label_.Get();
}
inline void HealthComponentReport::_internal_set_label(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.label_.Set(value, GetArena());
}
inline std::string* HealthComponentReport::_internal_mutable_label() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.label_.Mutable( GetArena());
}
inline std::string* HealthComponentReport::release_label() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:mavsdk.rpc.events.HealthComponentReport.label)
  return _impl_.label_.Release();
}
inline void HealthComponentReport::set_allocated_label(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.label_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.label_.IsDefault()) {
    _impl_.label_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.events.HealthComponentReport.label)
}

// bool is_present = 3;
inline void HealthComponentReport::clear_is_present() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_present_ = false;
}
inline bool HealthComponentReport::is_present() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.events.HealthComponentReport.is_present)
  return _internal_is_present();
}
inline void HealthComponentReport::set_is_present(bool value) {
  _internal_set_is_present(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.events.HealthComponentReport.is_present)
}
inline bool HealthComponentReport::_internal_is_present() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.is_present_;
}
inline void HealthComponentReport::_internal_set_is_present(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_present_ = value;
}

// bool has_error = 4;
inline void HealthComponentReport::clear_has_error() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.has_error_ = false;
}
inline bool HealthComponentReport::has_error() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.events.HealthComponentReport.has_error)
  return _internal_has_error();
}
inline void HealthComponentReport::set_has_error(bool value) {
  _internal_set_has_error(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.events.HealthComponentReport.has_error)
}
inline bool HealthComponentReport::_internal_has_error() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.has_error_;
}
inline void HealthComponentReport::_internal_set_has_error(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.has_error_ = value;
}

// bool has_warning = 5;
inline void HealthComponentReport::clear_has_warning() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.has_warning_ = false;
}
inline bool HealthComponentReport::has_warning() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.events.HealthComponentReport.has_warning)
  return _internal_has_warning();
}
inline void HealthComponentReport::set_has_warning(bool value) {
  _internal_set_has_warning(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.events.HealthComponentReport.has_warning)
}
inline bool HealthComponentReport::_internal_has_warning() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.has_warning_;
}
inline void HealthComponentReport::_internal_set_has_warning(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.has_warning_ = value;
}

// -------------------------------------------------------------------

// HealthAndArmingCheckReport

// .mavsdk.rpc.events.HealthAndArmingCheckMode current_mode_intention = 1;
inline bool HealthAndArmingCheckReport::has_current_mode_intention() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.current_mode_intention_ != nullptr);
  return value;
}
inline void HealthAndArmingCheckReport::clear_current_mode_intention() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.current_mode_intention_ != nullptr) _impl_.current_mode_intention_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::mavsdk::rpc::events::HealthAndArmingCheckMode& HealthAndArmingCheckReport::_internal_current_mode_intention() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::mavsdk::rpc::events::HealthAndArmingCheckMode* p = _impl_.current_mode_intention_;
  return p != nullptr ? *p : reinterpret_cast<const ::mavsdk::rpc::events::HealthAndArmingCheckMode&>(::mavsdk::rpc::events::_HealthAndArmingCheckMode_default_instance_);
}
inline const ::mavsdk::rpc::events::HealthAndArmingCheckMode& HealthAndArmingCheckReport::current_mode_intention() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.events.HealthAndArmingCheckReport.current_mode_intention)
  return _internal_current_mode_intention();
}
inline void HealthAndArmingCheckReport::unsafe_arena_set_allocated_current_mode_intention(::mavsdk::rpc::events::HealthAndArmingCheckMode* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.current_mode_intention_);
  }
  _impl_.current_mode_intention_ = reinterpret_cast<::mavsdk::rpc::events::HealthAndArmingCheckMode*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mavsdk.rpc.events.HealthAndArmingCheckReport.current_mode_intention)
}
inline ::mavsdk::rpc::events::HealthAndArmingCheckMode* HealthAndArmingCheckReport::release_current_mode_intention() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::mavsdk::rpc::events::HealthAndArmingCheckMode* released = _impl_.current_mode_intention_;
  _impl_.current_mode_intention_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::mavsdk::rpc::events::HealthAndArmingCheckMode* HealthAndArmingCheckReport::unsafe_arena_release_current_mode_intention() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:mavsdk.rpc.events.HealthAndArmingCheckReport.current_mode_intention)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::mavsdk::rpc::events::HealthAndArmingCheckMode* temp = _impl_.current_mode_intention_;
  _impl_.current_mode_intention_ = nullptr;
  return temp;
}
inline ::mavsdk::rpc::events::HealthAndArmingCheckMode* HealthAndArmingCheckReport::_internal_mutable_current_mode_intention() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.current_mode_intention_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::mavsdk::rpc::events::HealthAndArmingCheckMode>(GetArena());
    _impl_.current_mode_intention_ = reinterpret_cast<::mavsdk::rpc::events::HealthAndArmingCheckMode*>(p);
  }
  return _impl_.current_mode_intention_;
}
inline ::mavsdk::rpc::events::HealthAndArmingCheckMode* HealthAndArmingCheckReport::mutable_current_mode_intention() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::mavsdk::rpc::events::HealthAndArmingCheckMode* _msg = _internal_mutable_current_mode_intention();
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.events.HealthAndArmingCheckReport.current_mode_intention)
  return _msg;
}
inline void HealthAndArmingCheckReport::set_allocated_current_mode_intention(::mavsdk::rpc::events::HealthAndArmingCheckMode* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.current_mode_intention_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.current_mode_intention_ = reinterpret_cast<::mavsdk::rpc::events::HealthAndArmingCheckMode*>(value);
  // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.events.HealthAndArmingCheckReport.current_mode_intention)
}

// repeated .mavsdk.rpc.events.HealthComponentReport health_components = 2;
inline int HealthAndArmingCheckReport::_internal_health_components_size() const {
  return _internal_health_components().size();
}
inline int HealthAndArmingCheckReport::health_components_size() const {
  return _internal_health_components_size();
}
inline void HealthAndArmingCheckReport::clear_health_components() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.health_components_.Clear();
}
inline ::mavsdk::rpc::events::HealthComponentReport* HealthAndArmingCheckReport::mutable_health_components(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.events.HealthAndArmingCheckReport.health_components)
  return _internal_mutable_health_components()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::mavsdk::rpc::events::HealthComponentReport>* HealthAndArmingCheckReport::mutable_health_components()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:mavsdk.rpc.events.HealthAndArmingCheckReport.health_components)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_health_components();
}
inline const ::mavsdk::rpc::events::HealthComponentReport& HealthAndArmingCheckReport::health_components(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.events.HealthAndArmingCheckReport.health_components)
  return _internal_health_components().Get(index);
}
inline ::mavsdk::rpc::events::HealthComponentReport* HealthAndArmingCheckReport::add_health_components() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::mavsdk::rpc::events::HealthComponentReport* _add = _internal_mutable_health_components()->Add();
  // @@protoc_insertion_point(field_add:mavsdk.rpc.events.HealthAndArmingCheckReport.health_components)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::mavsdk::rpc::events::HealthComponentReport>& HealthAndArmingCheckReport::health_components() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:mavsdk.rpc.events.HealthAndArmingCheckReport.health_components)
  return _internal_health_components();
}
inline const ::google::protobuf::RepeatedPtrField<::mavsdk::rpc::events::HealthComponentReport>&
HealthAndArmingCheckReport::_internal_health_components() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.health_components_;
}
inline ::google::protobuf::RepeatedPtrField<::mavsdk::rpc::events::HealthComponentReport>*
HealthAndArmingCheckReport::_internal_mutable_health_components() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.health_components_;
}

// repeated .mavsdk.rpc.events.HealthAndArmingCheckProblem all_problems = 3;
inline int HealthAndArmingCheckReport::_internal_all_problems_size() const {
  return _internal_all_problems().size();
}
inline int HealthAndArmingCheckReport::all_problems_size() const {
  return _internal_all_problems_size();
}
inline void HealthAndArmingCheckReport::clear_all_problems() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.all_problems_.Clear();
}
inline ::mavsdk::rpc::events::HealthAndArmingCheckProblem* HealthAndArmingCheckReport::mutable_all_problems(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.events.HealthAndArmingCheckReport.all_problems)
  return _internal_mutable_all_problems()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::mavsdk::rpc::events::HealthAndArmingCheckProblem>* HealthAndArmingCheckReport::mutable_all_problems()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:mavsdk.rpc.events.HealthAndArmingCheckReport.all_problems)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_all_problems();
}
inline const ::mavsdk::rpc::events::HealthAndArmingCheckProblem& HealthAndArmingCheckReport::all_problems(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.events.HealthAndArmingCheckReport.all_problems)
  return _internal_all_problems().Get(index);
}
inline ::mavsdk::rpc::events::HealthAndArmingCheckProblem* HealthAndArmingCheckReport::add_all_problems() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::mavsdk::rpc::events::HealthAndArmingCheckProblem* _add = _internal_mutable_all_problems()->Add();
  // @@protoc_insertion_point(field_add:mavsdk.rpc.events.HealthAndArmingCheckReport.all_problems)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::mavsdk::rpc::events::HealthAndArmingCheckProblem>& HealthAndArmingCheckReport::all_problems() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:mavsdk.rpc.events.HealthAndArmingCheckReport.all_problems)
  return _internal_all_problems();
}
inline const ::google::protobuf::RepeatedPtrField<::mavsdk::rpc::events::HealthAndArmingCheckProblem>&
HealthAndArmingCheckReport::_internal_all_problems() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.all_problems_;
}
inline ::google::protobuf::RepeatedPtrField<::mavsdk::rpc::events::HealthAndArmingCheckProblem>*
HealthAndArmingCheckReport::_internal_mutable_all_problems() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.all_problems_;
}

// -------------------------------------------------------------------

// EventsResult

// .mavsdk.rpc.events.EventsResult.Result result = 1;
inline void EventsResult::clear_result() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.result_ = 0;
}
inline ::mavsdk::rpc::events::EventsResult_Result EventsResult::result() const {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.events.EventsResult.result)
  return _internal_result();
}
inline void EventsResult::set_result(::mavsdk::rpc::events::EventsResult_Result value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:mavsdk.rpc.events.EventsResult.result)
}
inline ::mavsdk::rpc::events::EventsResult_Result EventsResult::_internal_result() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::mavsdk::rpc::events::EventsResult_Result>(_impl_.result_);
}
inline void EventsResult::_internal_set_result(::mavsdk::rpc::events::EventsResult_Result value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.result_ = value;
}

// string result_str = 2;
inline void EventsResult::clear_result_str() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.result_str_.ClearToEmpty();
}
inline const std::string& EventsResult::result_str() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.events.EventsResult.result_str)
  return _internal_result_str();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EventsResult::set_result_str(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.result_str_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mavsdk.rpc.events.EventsResult.result_str)
}
inline std::string* EventsResult::mutable_result_str() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_result_str();
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.events.EventsResult.result_str)
  return _s;
}
inline const std::string& EventsResult::_internal_result_str() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.result_str_.Get();
}
inline void EventsResult::_internal_set_result_str(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.result_str_.Set(value, GetArena());
}
inline std::string* EventsResult::_internal_mutable_result_str() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.result_str_.Mutable( GetArena());
}
inline std::string* EventsResult::release_result_str() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:mavsdk.rpc.events.EventsResult.result_str)
  return _impl_.result_str_.Release();
}
inline void EventsResult::set_allocated_result_str(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.result_str_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.result_str_.IsDefault()) {
    _impl_.result_str_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.events.EventsResult.result_str)
}

// -------------------------------------------------------------------

// SubscribeEventsRequest

// -------------------------------------------------------------------

// EventsResponse

// .mavsdk.rpc.events.Event event = 1;
inline bool EventsResponse::has_event() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.event_ != nullptr);
  return value;
}
inline void EventsResponse::clear_event() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.event_ != nullptr) _impl_.event_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::mavsdk::rpc::events::Event& EventsResponse::_internal_event() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::mavsdk::rpc::events::Event* p = _impl_.event_;
  return p != nullptr ? *p : reinterpret_cast<const ::mavsdk::rpc::events::Event&>(::mavsdk::rpc::events::_Event_default_instance_);
}
inline const ::mavsdk::rpc::events::Event& EventsResponse::event() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.events.EventsResponse.event)
  return _internal_event();
}
inline void EventsResponse::unsafe_arena_set_allocated_event(::mavsdk::rpc::events::Event* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.event_);
  }
  _impl_.event_ = reinterpret_cast<::mavsdk::rpc::events::Event*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mavsdk.rpc.events.EventsResponse.event)
}
inline ::mavsdk::rpc::events::Event* EventsResponse::release_event() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::mavsdk::rpc::events::Event* released = _impl_.event_;
  _impl_.event_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::mavsdk::rpc::events::Event* EventsResponse::unsafe_arena_release_event() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:mavsdk.rpc.events.EventsResponse.event)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::mavsdk::rpc::events::Event* temp = _impl_.event_;
  _impl_.event_ = nullptr;
  return temp;
}
inline ::mavsdk::rpc::events::Event* EventsResponse::_internal_mutable_event() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.event_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::mavsdk::rpc::events::Event>(GetArena());
    _impl_.event_ = reinterpret_cast<::mavsdk::rpc::events::Event*>(p);
  }
  return _impl_.event_;
}
inline ::mavsdk::rpc::events::Event* EventsResponse::mutable_event() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::mavsdk::rpc::events::Event* _msg = _internal_mutable_event();
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.events.EventsResponse.event)
  return _msg;
}
inline void EventsResponse::set_allocated_event(::mavsdk::rpc::events::Event* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.event_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.event_ = reinterpret_cast<::mavsdk::rpc::events::Event*>(value);
  // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.events.EventsResponse.event)
}

// -------------------------------------------------------------------

// SubscribeHealthAndArmingChecksRequest

// -------------------------------------------------------------------

// HealthAndArmingChecksResponse

// .mavsdk.rpc.events.HealthAndArmingCheckReport report = 1;
inline bool HealthAndArmingChecksResponse::has_report() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.report_ != nullptr);
  return value;
}
inline void HealthAndArmingChecksResponse::clear_report() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.report_ != nullptr) _impl_.report_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::mavsdk::rpc::events::HealthAndArmingCheckReport& HealthAndArmingChecksResponse::_internal_report() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::mavsdk::rpc::events::HealthAndArmingCheckReport* p = _impl_.report_;
  return p != nullptr ? *p : reinterpret_cast<const ::mavsdk::rpc::events::HealthAndArmingCheckReport&>(::mavsdk::rpc::events::_HealthAndArmingCheckReport_default_instance_);
}
inline const ::mavsdk::rpc::events::HealthAndArmingCheckReport& HealthAndArmingChecksResponse::report() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.events.HealthAndArmingChecksResponse.report)
  return _internal_report();
}
inline void HealthAndArmingChecksResponse::unsafe_arena_set_allocated_report(::mavsdk::rpc::events::HealthAndArmingCheckReport* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.report_);
  }
  _impl_.report_ = reinterpret_cast<::mavsdk::rpc::events::HealthAndArmingCheckReport*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mavsdk.rpc.events.HealthAndArmingChecksResponse.report)
}
inline ::mavsdk::rpc::events::HealthAndArmingCheckReport* HealthAndArmingChecksResponse::release_report() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::mavsdk::rpc::events::HealthAndArmingCheckReport* released = _impl_.report_;
  _impl_.report_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::mavsdk::rpc::events::HealthAndArmingCheckReport* HealthAndArmingChecksResponse::unsafe_arena_release_report() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:mavsdk.rpc.events.HealthAndArmingChecksResponse.report)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::mavsdk::rpc::events::HealthAndArmingCheckReport* temp = _impl_.report_;
  _impl_.report_ = nullptr;
  return temp;
}
inline ::mavsdk::rpc::events::HealthAndArmingCheckReport* HealthAndArmingChecksResponse::_internal_mutable_report() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.report_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::mavsdk::rpc::events::HealthAndArmingCheckReport>(GetArena());
    _impl_.report_ = reinterpret_cast<::mavsdk::rpc::events::HealthAndArmingCheckReport*>(p);
  }
  return _impl_.report_;
}
inline ::mavsdk::rpc::events::HealthAndArmingCheckReport* HealthAndArmingChecksResponse::mutable_report() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::mavsdk::rpc::events::HealthAndArmingCheckReport* _msg = _internal_mutable_report();
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.events.HealthAndArmingChecksResponse.report)
  return _msg;
}
inline void HealthAndArmingChecksResponse::set_allocated_report(::mavsdk::rpc::events::HealthAndArmingCheckReport* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.report_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.report_ = reinterpret_cast<::mavsdk::rpc::events::HealthAndArmingCheckReport*>(value);
  // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.events.HealthAndArmingChecksResponse.report)
}

// -------------------------------------------------------------------

// GetHealthAndArmingChecksReportRequest

// -------------------------------------------------------------------

// GetHealthAndArmingChecksReportResponse

// .mavsdk.rpc.events.EventsResult events_result = 1;
inline bool GetHealthAndArmingChecksReportResponse::has_events_result() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.events_result_ != nullptr);
  return value;
}
inline void GetHealthAndArmingChecksReportResponse::clear_events_result() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.events_result_ != nullptr) _impl_.events_result_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::mavsdk::rpc::events::EventsResult& GetHealthAndArmingChecksReportResponse::_internal_events_result() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::mavsdk::rpc::events::EventsResult* p = _impl_.events_result_;
  return p != nullptr ? *p : reinterpret_cast<const ::mavsdk::rpc::events::EventsResult&>(::mavsdk::rpc::events::_EventsResult_default_instance_);
}
inline const ::mavsdk::rpc::events::EventsResult& GetHealthAndArmingChecksReportResponse::events_result() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.events.GetHealthAndArmingChecksReportResponse.events_result)
  return _internal_events_result();
}
inline void GetHealthAndArmingChecksReportResponse::unsafe_arena_set_allocated_events_result(::mavsdk::rpc::events::EventsResult* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.events_result_);
  }
  _impl_.events_result_ = reinterpret_cast<::mavsdk::rpc::events::EventsResult*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mavsdk.rpc.events.GetHealthAndArmingChecksReportResponse.events_result)
}
inline ::mavsdk::rpc::events::EventsResult* GetHealthAndArmingChecksReportResponse::release_events_result() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::mavsdk::rpc::events::EventsResult* released = _impl_.events_result_;
  _impl_.events_result_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::mavsdk::rpc::events::EventsResult* GetHealthAndArmingChecksReportResponse::unsafe_arena_release_events_result() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:mavsdk.rpc.events.GetHealthAndArmingChecksReportResponse.events_result)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::mavsdk::rpc::events::EventsResult* temp = _impl_.events_result_;
  _impl_.events_result_ = nullptr;
  return temp;
}
inline ::mavsdk::rpc::events::EventsResult* GetHealthAndArmingChecksReportResponse::_internal_mutable_events_result() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.events_result_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::mavsdk::rpc::events::EventsResult>(GetArena());
    _impl_.events_result_ = reinterpret_cast<::mavsdk::rpc::events::EventsResult*>(p);
  }
  return _impl_.events_result_;
}
inline ::mavsdk::rpc::events::EventsResult* GetHealthAndArmingChecksReportResponse::mutable_events_result() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::mavsdk::rpc::events::EventsResult* _msg = _internal_mutable_events_result();
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.events.GetHealthAndArmingChecksReportResponse.events_result)
  return _msg;
}
inline void GetHealthAndArmingChecksReportResponse::set_allocated_events_result(::mavsdk::rpc::events::EventsResult* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.events_result_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.events_result_ = reinterpret_cast<::mavsdk::rpc::events::EventsResult*>(value);
  // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.events.GetHealthAndArmingChecksReportResponse.events_result)
}

// .mavsdk.rpc.events.HealthAndArmingCheckReport report = 2;
inline bool GetHealthAndArmingChecksReportResponse::has_report() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.report_ != nullptr);
  return value;
}
inline void GetHealthAndArmingChecksReportResponse::clear_report() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.report_ != nullptr) _impl_.report_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::mavsdk::rpc::events::HealthAndArmingCheckReport& GetHealthAndArmingChecksReportResponse::_internal_report() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::mavsdk::rpc::events::HealthAndArmingCheckReport* p = _impl_.report_;
  return p != nullptr ? *p : reinterpret_cast<const ::mavsdk::rpc::events::HealthAndArmingCheckReport&>(::mavsdk::rpc::events::_HealthAndArmingCheckReport_default_instance_);
}
inline const ::mavsdk::rpc::events::HealthAndArmingCheckReport& GetHealthAndArmingChecksReportResponse::report() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mavsdk.rpc.events.GetHealthAndArmingChecksReportResponse.report)
  return _internal_report();
}
inline void GetHealthAndArmingChecksReportResponse::unsafe_arena_set_allocated_report(::mavsdk::rpc::events::HealthAndArmingCheckReport* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.report_);
  }
  _impl_.report_ = reinterpret_cast<::mavsdk::rpc::events::HealthAndArmingCheckReport*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mavsdk.rpc.events.GetHealthAndArmingChecksReportResponse.report)
}
inline ::mavsdk::rpc::events::HealthAndArmingCheckReport* GetHealthAndArmingChecksReportResponse::release_report() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::mavsdk::rpc::events::HealthAndArmingCheckReport* released = _impl_.report_;
  _impl_.report_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::mavsdk::rpc::events::HealthAndArmingCheckReport* GetHealthAndArmingChecksReportResponse::unsafe_arena_release_report() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:mavsdk.rpc.events.GetHealthAndArmingChecksReportResponse.report)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::mavsdk::rpc::events::HealthAndArmingCheckReport* temp = _impl_.report_;
  _impl_.report_ = nullptr;
  return temp;
}
inline ::mavsdk::rpc::events::HealthAndArmingCheckReport* GetHealthAndArmingChecksReportResponse::_internal_mutable_report() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.report_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::mavsdk::rpc::events::HealthAndArmingCheckReport>(GetArena());
    _impl_.report_ = reinterpret_cast<::mavsdk::rpc::events::HealthAndArmingCheckReport*>(p);
  }
  return _impl_.report_;
}
inline ::mavsdk::rpc::events::HealthAndArmingCheckReport* GetHealthAndArmingChecksReportResponse::mutable_report() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::mavsdk::rpc::events::HealthAndArmingCheckReport* _msg = _internal_mutable_report();
  // @@protoc_insertion_point(field_mutable:mavsdk.rpc.events.GetHealthAndArmingChecksReportResponse.report)
  return _msg;
}
inline void GetHealthAndArmingChecksReportResponse::set_allocated_report(::mavsdk::rpc::events::HealthAndArmingCheckReport* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.report_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.report_ = reinterpret_cast<::mavsdk::rpc::events::HealthAndArmingCheckReport*>(value);
  // @@protoc_insertion_point(field_set_allocated:mavsdk.rpc.events.GetHealthAndArmingChecksReportResponse.report)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace events
}  // namespace rpc
}  // namespace mavsdk


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::mavsdk::rpc::events::EventsResult_Result> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::mavsdk::rpc::events::EventsResult_Result>() {
  return ::mavsdk::rpc::events::EventsResult_Result_descriptor();
}
template <>
struct is_proto_enum<::mavsdk::rpc::events::LogLevel> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::mavsdk::rpc::events::LogLevel>() {
  return ::mavsdk::rpc::events::LogLevel_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // events_2fevents_2eproto_2epb_2eh
