// WARNING: THIS FILE IS AUTOGENERATED! As such, it should not be edited.
// Edits need to be made to the proto files
// (see https://github.com/mavlink/MAVSDK-Proto/blob/main/protos/mission_raw/mission_raw.proto)

#include "mission_raw.h"

#include <mavsdk/plugins/mission_raw/mission_raw.h>
#include <cstring>
#include <vector>

// ===== C++ to C Type Conversions =====

static mavsdk_mission_raw_result_t
translate_result(mavsdk::MissionRaw::Result cpp_result) {
    switch(cpp_result) {
        case mavsdk::MissionRaw::Result::Unknown:
            return MAVSDK_MISSION_RAW_RESULT_UNKNOWN;
        case mavsdk::MissionRaw::Result::Success:
            return MAVSDK_MISSION_RAW_RESULT_SUCCESS;
        case mavsdk::MissionRaw::Result::Error:
            return MAVSDK_MISSION_RAW_RESULT_ERROR;
        case mavsdk::MissionRaw::Result::TooManyMissionItems:
            return MAVSDK_MISSION_RAW_RESULT_TOO_MANY_MISSION_ITEMS;
        case mavsdk::MissionRaw::Result::Busy:
            return MAVSDK_MISSION_RAW_RESULT_BUSY;
        case mavsdk::MissionRaw::Result::Timeout:
            return MAVSDK_MISSION_RAW_RESULT_TIMEOUT;
        case mavsdk::MissionRaw::Result::InvalidArgument:
            return MAVSDK_MISSION_RAW_RESULT_INVALID_ARGUMENT;
        case mavsdk::MissionRaw::Result::Unsupported:
            return MAVSDK_MISSION_RAW_RESULT_UNSUPPORTED;
        case mavsdk::MissionRaw::Result::NoMissionAvailable:
            return MAVSDK_MISSION_RAW_RESULT_NO_MISSION_AVAILABLE;
        case mavsdk::MissionRaw::Result::TransferCancelled:
            return MAVSDK_MISSION_RAW_RESULT_TRANSFER_CANCELLED;
        case mavsdk::MissionRaw::Result::FailedToOpenQgcPlan:
            return MAVSDK_MISSION_RAW_RESULT_FAILED_TO_OPEN_QGC_PLAN;
        case mavsdk::MissionRaw::Result::FailedToParseQgcPlan:
            return MAVSDK_MISSION_RAW_RESULT_FAILED_TO_PARSE_QGC_PLAN;
        case mavsdk::MissionRaw::Result::NoSystem:
            return MAVSDK_MISSION_RAW_RESULT_NO_SYSTEM;
        case mavsdk::MissionRaw::Result::Denied:
            return MAVSDK_MISSION_RAW_RESULT_DENIED;
        case mavsdk::MissionRaw::Result::MissionTypeNotConsistent:
            return MAVSDK_MISSION_RAW_RESULT_MISSION_TYPE_NOT_CONSISTENT;
        case mavsdk::MissionRaw::Result::InvalidSequence:
            return MAVSDK_MISSION_RAW_RESULT_INVALID_SEQUENCE;
        case mavsdk::MissionRaw::Result::CurrentInvalid:
            return MAVSDK_MISSION_RAW_RESULT_CURRENT_INVALID;
        case mavsdk::MissionRaw::Result::ProtocolError:
            return MAVSDK_MISSION_RAW_RESULT_PROTOCOL_ERROR;
        case mavsdk::MissionRaw::Result::IntMessagesNotSupported:
            return MAVSDK_MISSION_RAW_RESULT_INT_MESSAGES_NOT_SUPPORTED;
        case mavsdk::MissionRaw::Result::FailedToOpenMissionPlannerPlan:
            return MAVSDK_MISSION_RAW_RESULT_FAILED_TO_OPEN_MISSION_PLANNER_PLAN;
        case mavsdk::MissionRaw::Result::FailedToParseMissionPlannerPlan:
            return MAVSDK_MISSION_RAW_RESULT_FAILED_TO_PARSE_MISSION_PLANNER_PLAN;
    }
}



static mavsdk::MissionRaw::MissionProgress
translate_mission_progress_from_c(const mavsdk_mission_raw_mission_progress_t& c_struct) {
    mavsdk::MissionRaw::MissionProgress cpp_struct{};
    cpp_struct.current = c_struct.current;
    cpp_struct.total = c_struct.total;
    return cpp_struct;
}

static mavsdk_mission_raw_mission_progress_t
translate_mission_progress_to_c(const mavsdk::MissionRaw::MissionProgress& cpp_struct) {
    mavsdk_mission_raw_mission_progress_t c_struct{};
    c_struct.current = cpp_struct.current;
    c_struct.total = cpp_struct.total;
    return c_struct;
}

void mavsdk_mission_raw_mission_progress_destroy(
    mavsdk_mission_raw_mission_progress_t* target) {
    if (!target) return;
}

void mavsdk_mission_raw_mission_progress_array_destroy(
    mavsdk_mission_raw_mission_progress_t** array,
    size_t size) {
    if (!array || !*array) return;

    for (size_t i = 0; i < size; i++) {
        mavsdk_mission_raw_mission_progress_destroy(&(*array)[i]);
    }

    delete[] *array;
    *array = nullptr;
}


static mavsdk::MissionRaw::MissionItem
translate_mission_item_from_c(const mavsdk_mission_raw_mission_item_t& c_struct) {
    mavsdk::MissionRaw::MissionItem cpp_struct{};
    cpp_struct.seq = c_struct.seq;
    cpp_struct.frame = c_struct.frame;
    cpp_struct.command = c_struct.command;
    cpp_struct.current = c_struct.current;
    cpp_struct.autocontinue = c_struct.autocontinue;
    cpp_struct.param1 = c_struct.param1;
    cpp_struct.param2 = c_struct.param2;
    cpp_struct.param3 = c_struct.param3;
    cpp_struct.param4 = c_struct.param4;
    cpp_struct.x = c_struct.x;
    cpp_struct.y = c_struct.y;
    cpp_struct.z = c_struct.z;
    cpp_struct.mission_type = c_struct.mission_type;
    return cpp_struct;
}

static mavsdk_mission_raw_mission_item_t
translate_mission_item_to_c(const mavsdk::MissionRaw::MissionItem& cpp_struct) {
    mavsdk_mission_raw_mission_item_t c_struct{};
    c_struct.seq = cpp_struct.seq;
    c_struct.frame = cpp_struct.frame;
    c_struct.command = cpp_struct.command;
    c_struct.current = cpp_struct.current;
    c_struct.autocontinue = cpp_struct.autocontinue;
    c_struct.param1 = cpp_struct.param1;
    c_struct.param2 = cpp_struct.param2;
    c_struct.param3 = cpp_struct.param3;
    c_struct.param4 = cpp_struct.param4;
    c_struct.x = cpp_struct.x;
    c_struct.y = cpp_struct.y;
    c_struct.z = cpp_struct.z;
    c_struct.mission_type = cpp_struct.mission_type;
    return c_struct;
}

void mavsdk_mission_raw_mission_item_destroy(
    mavsdk_mission_raw_mission_item_t* target) {
    if (!target) return;
}

void mavsdk_mission_raw_mission_item_array_destroy(
    mavsdk_mission_raw_mission_item_t** array,
    size_t size) {
    if (!array || !*array) return;

    for (size_t i = 0; i < size; i++) {
        mavsdk_mission_raw_mission_item_destroy(&(*array)[i]);
    }

    delete[] *array;
    *array = nullptr;
}


static mavsdk::MissionRaw::MissionImportData
translate_mission_import_data_from_c(const mavsdk_mission_raw_mission_import_data_t& c_struct) {
    mavsdk::MissionRaw::MissionImportData cpp_struct{};
    cpp_struct.mission_items.reserve(c_struct.mission_items_size);
    for (size_t i = 0; i < c_struct.mission_items_size; i++) {
        cpp_struct.mission_items.push_back(
            translate_mission_item_from_c(c_struct.mission_items[i]));
    }
    cpp_struct.geofence_items.reserve(c_struct.geofence_items_size);
    for (size_t i = 0; i < c_struct.geofence_items_size; i++) {
        cpp_struct.geofence_items.push_back(
            translate_mission_item_from_c(c_struct.geofence_items[i]));
    }
    cpp_struct.rally_items.reserve(c_struct.rally_items_size);
    for (size_t i = 0; i < c_struct.rally_items_size; i++) {
        cpp_struct.rally_items.push_back(
            translate_mission_item_from_c(c_struct.rally_items[i]));
    }
    return cpp_struct;
}

static mavsdk_mission_raw_mission_import_data_t
translate_mission_import_data_to_c(const mavsdk::MissionRaw::MissionImportData& cpp_struct) {
    mavsdk_mission_raw_mission_import_data_t c_struct{};
    c_struct.mission_items_size = cpp_struct.mission_items.size();
    c_struct.mission_items = new mavsdk_mission_raw_mission_item_t[c_struct.mission_items_size];
    for (size_t i = 0; i < c_struct.mission_items_size; i++) {
        c_struct.mission_items[i] = translate_mission_item_to_c(cpp_struct.mission_items[i]);
    }
    c_struct.geofence_items_size = cpp_struct.geofence_items.size();
    c_struct.geofence_items = new mavsdk_mission_raw_mission_item_t[c_struct.geofence_items_size];
    for (size_t i = 0; i < c_struct.geofence_items_size; i++) {
        c_struct.geofence_items[i] = translate_mission_item_to_c(cpp_struct.geofence_items[i]);
    }
    c_struct.rally_items_size = cpp_struct.rally_items.size();
    c_struct.rally_items = new mavsdk_mission_raw_mission_item_t[c_struct.rally_items_size];
    for (size_t i = 0; i < c_struct.rally_items_size; i++) {
        c_struct.rally_items[i] = translate_mission_item_to_c(cpp_struct.rally_items[i]);
    }
    return c_struct;
}

void mavsdk_mission_raw_mission_import_data_destroy(
    mavsdk_mission_raw_mission_import_data_t* target) {
    if (!target) return;
    if (target->mission_items) {
        for (size_t i = 0; i < target->mission_items_size; i++) {
            mavsdk_mission_raw_mission_item_destroy(&target->mission_items[i]);
        }
        delete[] target->mission_items;
        target->mission_items = nullptr;
        target->mission_items_size = 0;
    }
    if (target->geofence_items) {
        for (size_t i = 0; i < target->geofence_items_size; i++) {
            mavsdk_mission_raw_mission_item_destroy(&target->geofence_items[i]);
        }
        delete[] target->geofence_items;
        target->geofence_items = nullptr;
        target->geofence_items_size = 0;
    }
    if (target->rally_items) {
        for (size_t i = 0; i < target->rally_items_size; i++) {
            mavsdk_mission_raw_mission_item_destroy(&target->rally_items[i]);
        }
        delete[] target->rally_items;
        target->rally_items = nullptr;
        target->rally_items_size = 0;
    }
}

void mavsdk_mission_raw_mission_import_data_array_destroy(
    mavsdk_mission_raw_mission_import_data_t** array,
    size_t size) {
    if (!array || !*array) return;

    for (size_t i = 0; i < size; i++) {
        mavsdk_mission_raw_mission_import_data_destroy(&(*array)[i]);
    }

    delete[] *array;
    *array = nullptr;
}



// ===== Primitive Array Destroy Functions =====
void mavsdk_mission_raw_float_array_destroy(float** array) {
    if (!array || !*array) return;
    delete[] *array;
    *array = nullptr;
}

void mavsdk_mission_raw_double_array_destroy(double** array) {
    if (!array || !*array) return;
    delete[] *array;
    *array = nullptr;
}

void mavsdk_mission_raw_int32t_array_destroy(int32_t** array) {
    if (!array || !*array) return;
    delete[] *array;
    *array = nullptr;
}

void mavsdk_mission_raw_uint32t_array_destroy(uint32_t** array) {
    if (!array || !*array) return;
    delete[] *array;
    *array = nullptr;
}

void mavsdk_mission_raw_int64t_array_destroy(int64_t** array) {
    if (!array || !*array) return;
    delete[] *array;
    *array = nullptr;
}

void mavsdk_mission_raw_uint64t_array_destroy(uint64_t** array) {
    if (!array || !*array) return;
    delete[] *array;
    *array = nullptr;
}

void mavsdk_mission_raw_bool_array_destroy(bool** array) {
    if (!array || !*array) return;
    delete[] *array;
    *array = nullptr;
}


void mavsdk_mission_raw_string_destroy(char** str) {
    if (!str || !*str) return;
    free(*str);
    *str = nullptr;
}

void mavsdk_mission_raw_byte_buffer_destroy(uint8_t** buffer) {
    if (!buffer || !*buffer) return;
    delete[] *buffer;
    *buffer = nullptr;
}

// ===== MissionRaw Wrapper =====

struct mavsdk_mission_raw_wrapper {
    std::shared_ptr<mavsdk::MissionRaw> cpp_plugin;
};

mavsdk_mission_raw_t
mavsdk_mission_raw_create(mavsdk_system_t system) {
    if (system == nullptr) {
        return nullptr;
    }

    auto wrapper = new mavsdk_mission_raw_wrapper();
    auto system_ptr = static_cast<std::shared_ptr<mavsdk::System>*>(system);
    wrapper->cpp_plugin = std::make_shared<mavsdk::MissionRaw>(*system_ptr);

    return wrapper;
}

void mavsdk_mission_raw_destroy(mavsdk_mission_raw_t mission_raw) {
    if (mission_raw == nullptr) {
        return;
    }

    auto wrapper = static_cast<mavsdk_mission_raw_wrapper*>(mission_raw);
    delete wrapper;
}

// ===== Method Implementations =====

// UploadMission async
void mavsdk_mission_raw_upload_mission_async(
    mavsdk_mission_raw_t mission_raw,
    const mavsdk_mission_raw_mission_item_t* mission_items,
    size_t mission_items_size,
    mavsdk_mission_raw_upload_mission_callback_t callback,
    void* user_data)
{
    auto wrapper = static_cast<mavsdk_mission_raw_wrapper*>(mission_raw);

    wrapper->cpp_plugin->upload_mission_async(
        [&mission_items, mission_items_size]() {
            std::vector<mavsdk::MissionRaw::MissionItem> vec;
            vec.reserve(mission_items_size);
            for (size_t i = 0; i < mission_items_size; i++) {
                vec.push_back(translate_mission_item_from_c(mission_items[i]));
            }
            return vec;
        }(),
        [callback, user_data](
            mavsdk::MissionRaw::Result result) {
                if (callback) {
                    callback(
                        translate_result(result),
                        user_data);
                }
        });
}


// UploadMission sync
mavsdk_mission_raw_result_t
mavsdk_mission_raw_upload_mission(
    mavsdk_mission_raw_t mission_raw,
    const mavsdk_mission_raw_mission_item_t* mission_items,
    size_t mission_items_size)
{
    auto wrapper = static_cast<mavsdk_mission_raw_wrapper*>(mission_raw);

    auto ret_value = wrapper->cpp_plugin->upload_mission(        [&mission_items, mission_items_size]() {
            std::vector<mavsdk::MissionRaw::MissionItem> vec;
            vec.reserve(mission_items_size);
            for (size_t i = 0; i < mission_items_size; i++) {
                vec.push_back(translate_mission_item_from_c(mission_items[i]));
            }
            return vec;
        }());

    return translate_result(ret_value);
}

// UploadGeofence async
void mavsdk_mission_raw_upload_geofence_async(
    mavsdk_mission_raw_t mission_raw,
    const mavsdk_mission_raw_mission_item_t* mission_items,
    size_t mission_items_size,
    mavsdk_mission_raw_upload_geofence_callback_t callback,
    void* user_data)
{
    auto wrapper = static_cast<mavsdk_mission_raw_wrapper*>(mission_raw);

    wrapper->cpp_plugin->upload_geofence_async(
        [&mission_items, mission_items_size]() {
            std::vector<mavsdk::MissionRaw::MissionItem> vec;
            vec.reserve(mission_items_size);
            for (size_t i = 0; i < mission_items_size; i++) {
                vec.push_back(translate_mission_item_from_c(mission_items[i]));
            }
            return vec;
        }(),
        [callback, user_data](
            mavsdk::MissionRaw::Result result) {
                if (callback) {
                    callback(
                        translate_result(result),
                        user_data);
                }
        });
}


// UploadGeofence sync
mavsdk_mission_raw_result_t
mavsdk_mission_raw_upload_geofence(
    mavsdk_mission_raw_t mission_raw,
    const mavsdk_mission_raw_mission_item_t* mission_items,
    size_t mission_items_size)
{
    auto wrapper = static_cast<mavsdk_mission_raw_wrapper*>(mission_raw);

    auto ret_value = wrapper->cpp_plugin->upload_geofence(        [&mission_items, mission_items_size]() {
            std::vector<mavsdk::MissionRaw::MissionItem> vec;
            vec.reserve(mission_items_size);
            for (size_t i = 0; i < mission_items_size; i++) {
                vec.push_back(translate_mission_item_from_c(mission_items[i]));
            }
            return vec;
        }());

    return translate_result(ret_value);
}

// UploadRallyPoints async
void mavsdk_mission_raw_upload_rally_points_async(
    mavsdk_mission_raw_t mission_raw,
    const mavsdk_mission_raw_mission_item_t* mission_items,
    size_t mission_items_size,
    mavsdk_mission_raw_upload_rally_points_callback_t callback,
    void* user_data)
{
    auto wrapper = static_cast<mavsdk_mission_raw_wrapper*>(mission_raw);

    wrapper->cpp_plugin->upload_rally_points_async(
        [&mission_items, mission_items_size]() {
            std::vector<mavsdk::MissionRaw::MissionItem> vec;
            vec.reserve(mission_items_size);
            for (size_t i = 0; i < mission_items_size; i++) {
                vec.push_back(translate_mission_item_from_c(mission_items[i]));
            }
            return vec;
        }(),
        [callback, user_data](
            mavsdk::MissionRaw::Result result) {
                if (callback) {
                    callback(
                        translate_result(result),
                        user_data);
                }
        });
}


// UploadRallyPoints sync
mavsdk_mission_raw_result_t
mavsdk_mission_raw_upload_rally_points(
    mavsdk_mission_raw_t mission_raw,
    const mavsdk_mission_raw_mission_item_t* mission_items,
    size_t mission_items_size)
{
    auto wrapper = static_cast<mavsdk_mission_raw_wrapper*>(mission_raw);

    auto ret_value = wrapper->cpp_plugin->upload_rally_points(        [&mission_items, mission_items_size]() {
            std::vector<mavsdk::MissionRaw::MissionItem> vec;
            vec.reserve(mission_items_size);
            for (size_t i = 0; i < mission_items_size; i++) {
                vec.push_back(translate_mission_item_from_c(mission_items[i]));
            }
            return vec;
        }());

    return translate_result(ret_value);
}


// CancelMissionUpload sync
mavsdk_mission_raw_result_t
mavsdk_mission_raw_cancel_mission_upload(
    mavsdk_mission_raw_t mission_raw)
{
    auto wrapper = static_cast<mavsdk_mission_raw_wrapper*>(mission_raw);

    auto ret_value = wrapper->cpp_plugin->cancel_mission_upload();

    return translate_result(ret_value);
}

// DownloadMission async
void mavsdk_mission_raw_download_mission_async(
    mavsdk_mission_raw_t mission_raw,
    mavsdk_mission_raw_download_mission_callback_t callback,
    void* user_data)
{
    auto wrapper = static_cast<mavsdk_mission_raw_wrapper*>(mission_raw);

    wrapper->cpp_plugin->download_mission_async(
        [callback, user_data](
            mavsdk::MissionRaw::Result result,
            std::vector<mavsdk::MissionRaw::MissionItem> value) {
                if (callback) {
                    size_t count = value.size();
                    mavsdk_mission_raw_mission_item_t* mission_items = nullptr;

                    if (count > 0) {
                        mission_items = new mavsdk_mission_raw_mission_item_t[count];
                        for (size_t i = 0; i < count; i++) {
                            mission_items[i] = translate_mission_item_to_c(value[i]);
                        }
                    }

                    callback(
                        translate_result(result),
                        mission_items,
                        count,
                        user_data);
                }
        });
}


// DownloadMission sync
mavsdk_mission_raw_result_t
mavsdk_mission_raw_download_mission(
    mavsdk_mission_raw_t mission_raw,
    mavsdk_mission_raw_mission_item_t** mission_items_out,
    size_t* mission_items_size_out)
{
    auto wrapper = static_cast<mavsdk_mission_raw_wrapper*>(mission_raw);

    auto result_pair = wrapper->cpp_plugin->download_mission(
);

    if (mission_items_out != nullptr) {
        size_t count = result_pair.second.size();

        *mission_items_out = new mavsdk_mission_raw_mission_item_t[count];

        for (size_t i = 0; i < count; i++) {
            (*mission_items_out)[i] = translate_mission_item_to_c(result_pair.second[i]);
        }

        if (mission_items_size_out != nullptr) {
            *mission_items_size_out = count;
        }
    }

    return translate_result(result_pair.first);
}

// DownloadGeofence async
void mavsdk_mission_raw_download_geofence_async(
    mavsdk_mission_raw_t mission_raw,
    mavsdk_mission_raw_download_geofence_callback_t callback,
    void* user_data)
{
    auto wrapper = static_cast<mavsdk_mission_raw_wrapper*>(mission_raw);

    wrapper->cpp_plugin->download_geofence_async(
        [callback, user_data](
            mavsdk::MissionRaw::Result result,
            std::vector<mavsdk::MissionRaw::MissionItem> value) {
                if (callback) {
                    size_t count = value.size();
                    mavsdk_mission_raw_mission_item_t* geofence_items = nullptr;

                    if (count > 0) {
                        geofence_items = new mavsdk_mission_raw_mission_item_t[count];
                        for (size_t i = 0; i < count; i++) {
                            geofence_items[i] = translate_mission_item_to_c(value[i]);
                        }
                    }

                    callback(
                        translate_result(result),
                        geofence_items,
                        count,
                        user_data);
                }
        });
}


// DownloadGeofence sync
mavsdk_mission_raw_result_t
mavsdk_mission_raw_download_geofence(
    mavsdk_mission_raw_t mission_raw,
    mavsdk_mission_raw_mission_item_t** geofence_items_out,
    size_t* geofence_items_size_out)
{
    auto wrapper = static_cast<mavsdk_mission_raw_wrapper*>(mission_raw);

    auto result_pair = wrapper->cpp_plugin->download_geofence(
);

    if (geofence_items_out != nullptr) {
        size_t count = result_pair.second.size();

        *geofence_items_out = new mavsdk_mission_raw_mission_item_t[count];

        for (size_t i = 0; i < count; i++) {
            (*geofence_items_out)[i] = translate_mission_item_to_c(result_pair.second[i]);
        }

        if (geofence_items_size_out != nullptr) {
            *geofence_items_size_out = count;
        }
    }

    return translate_result(result_pair.first);
}

// DownloadRallypoints async
void mavsdk_mission_raw_download_rallypoints_async(
    mavsdk_mission_raw_t mission_raw,
    mavsdk_mission_raw_download_rallypoints_callback_t callback,
    void* user_data)
{
    auto wrapper = static_cast<mavsdk_mission_raw_wrapper*>(mission_raw);

    wrapper->cpp_plugin->download_rallypoints_async(
        [callback, user_data](
            mavsdk::MissionRaw::Result result,
            std::vector<mavsdk::MissionRaw::MissionItem> value) {
                if (callback) {
                    size_t count = value.size();
                    mavsdk_mission_raw_mission_item_t* rallypoint_items = nullptr;

                    if (count > 0) {
                        rallypoint_items = new mavsdk_mission_raw_mission_item_t[count];
                        for (size_t i = 0; i < count; i++) {
                            rallypoint_items[i] = translate_mission_item_to_c(value[i]);
                        }
                    }

                    callback(
                        translate_result(result),
                        rallypoint_items,
                        count,
                        user_data);
                }
        });
}


// DownloadRallypoints sync
mavsdk_mission_raw_result_t
mavsdk_mission_raw_download_rallypoints(
    mavsdk_mission_raw_t mission_raw,
    mavsdk_mission_raw_mission_item_t** rallypoint_items_out,
    size_t* rallypoint_items_size_out)
{
    auto wrapper = static_cast<mavsdk_mission_raw_wrapper*>(mission_raw);

    auto result_pair = wrapper->cpp_plugin->download_rallypoints(
);

    if (rallypoint_items_out != nullptr) {
        size_t count = result_pair.second.size();

        *rallypoint_items_out = new mavsdk_mission_raw_mission_item_t[count];

        for (size_t i = 0; i < count; i++) {
            (*rallypoint_items_out)[i] = translate_mission_item_to_c(result_pair.second[i]);
        }

        if (rallypoint_items_size_out != nullptr) {
            *rallypoint_items_size_out = count;
        }
    }

    return translate_result(result_pair.first);
}


// CancelMissionDownload sync
mavsdk_mission_raw_result_t
mavsdk_mission_raw_cancel_mission_download(
    mavsdk_mission_raw_t mission_raw)
{
    auto wrapper = static_cast<mavsdk_mission_raw_wrapper*>(mission_raw);

    auto ret_value = wrapper->cpp_plugin->cancel_mission_download();

    return translate_result(ret_value);
}

// StartMission async
void mavsdk_mission_raw_start_mission_async(
    mavsdk_mission_raw_t mission_raw,
    mavsdk_mission_raw_start_mission_callback_t callback,
    void* user_data)
{
    auto wrapper = static_cast<mavsdk_mission_raw_wrapper*>(mission_raw);

    wrapper->cpp_plugin->start_mission_async(
        [callback, user_data](
            mavsdk::MissionRaw::Result result) {
                if (callback) {
                    callback(
                        translate_result(result),
                        user_data);
                }
        });
}


// StartMission sync
mavsdk_mission_raw_result_t
mavsdk_mission_raw_start_mission(
    mavsdk_mission_raw_t mission_raw)
{
    auto wrapper = static_cast<mavsdk_mission_raw_wrapper*>(mission_raw);

    auto ret_value = wrapper->cpp_plugin->start_mission();

    return translate_result(ret_value);
}

// PauseMission async
void mavsdk_mission_raw_pause_mission_async(
    mavsdk_mission_raw_t mission_raw,
    mavsdk_mission_raw_pause_mission_callback_t callback,
    void* user_data)
{
    auto wrapper = static_cast<mavsdk_mission_raw_wrapper*>(mission_raw);

    wrapper->cpp_plugin->pause_mission_async(
        [callback, user_data](
            mavsdk::MissionRaw::Result result) {
                if (callback) {
                    callback(
                        translate_result(result),
                        user_data);
                }
        });
}


// PauseMission sync
mavsdk_mission_raw_result_t
mavsdk_mission_raw_pause_mission(
    mavsdk_mission_raw_t mission_raw)
{
    auto wrapper = static_cast<mavsdk_mission_raw_wrapper*>(mission_raw);

    auto ret_value = wrapper->cpp_plugin->pause_mission();

    return translate_result(ret_value);
}

// ClearMission async
void mavsdk_mission_raw_clear_mission_async(
    mavsdk_mission_raw_t mission_raw,
    mavsdk_mission_raw_clear_mission_callback_t callback,
    void* user_data)
{
    auto wrapper = static_cast<mavsdk_mission_raw_wrapper*>(mission_raw);

    wrapper->cpp_plugin->clear_mission_async(
        [callback, user_data](
            mavsdk::MissionRaw::Result result) {
                if (callback) {
                    callback(
                        translate_result(result),
                        user_data);
                }
        });
}


// ClearMission sync
mavsdk_mission_raw_result_t
mavsdk_mission_raw_clear_mission(
    mavsdk_mission_raw_t mission_raw)
{
    auto wrapper = static_cast<mavsdk_mission_raw_wrapper*>(mission_raw);

    auto ret_value = wrapper->cpp_plugin->clear_mission();

    return translate_result(ret_value);
}

// SetCurrentMissionItem async
void mavsdk_mission_raw_set_current_mission_item_async(
    mavsdk_mission_raw_t mission_raw,
    int32_t index,
    mavsdk_mission_raw_set_current_mission_item_callback_t callback,
    void* user_data)
{
    auto wrapper = static_cast<mavsdk_mission_raw_wrapper*>(mission_raw);

    wrapper->cpp_plugin->set_current_mission_item_async(
        index,
        [callback, user_data](
            mavsdk::MissionRaw::Result result) {
                if (callback) {
                    callback(
                        translate_result(result),
                        user_data);
                }
        });
}


// SetCurrentMissionItem sync
mavsdk_mission_raw_result_t
mavsdk_mission_raw_set_current_mission_item(
    mavsdk_mission_raw_t mission_raw,
    int32_t index)
{
    auto wrapper = static_cast<mavsdk_mission_raw_wrapper*>(mission_raw);

    auto ret_value = wrapper->cpp_plugin->set_current_mission_item(        index);

    return translate_result(ret_value);
}

// MissionProgress async
mavsdk_mission_raw_mission_progress_handle_t mavsdk_mission_raw_subscribe_mission_progress(
    mavsdk_mission_raw_t mission_raw,
    mavsdk_mission_raw_mission_progress_callback_t callback,
    void* user_data)
{
    auto wrapper = static_cast<mavsdk_mission_raw_wrapper*>(mission_raw);

    auto cpp_handle =    wrapper->cpp_plugin->subscribe_mission_progress(
        [callback, user_data](
            mavsdk::MissionRaw::MissionProgress value) {
                if (callback) {
                    callback(
                        translate_mission_progress_to_c(value),
                        user_data);
                }
        });

    auto handle_wrapper = new mavsdk::MissionRaw::MissionProgressHandle(std::move(cpp_handle));
    return static_cast<mavsdk_mission_raw_mission_progress_handle_t>(handle_wrapper);
}

void mavsdk_mission_raw_unsubscribe_mission_progress(
    mavsdk_mission_raw_t mission_raw,
    mavsdk_mission_raw_mission_progress_handle_t handle)
{
    if (handle) {
        auto wrapper = static_cast<mavsdk_mission_raw_wrapper*>(mission_raw);
        auto cpp_handle = static_cast<mavsdk::MissionRaw::MissionProgressHandle*>(handle);
        wrapper->cpp_plugin->unsubscribe_mission_progress(std::move(*cpp_handle));
        delete cpp_handle;
    }
}

// MissionProgress sync
void
mavsdk_mission_raw_mission_progress(
    mavsdk_mission_raw_t mission_raw,
    mavsdk_mission_raw_mission_progress_t* mission_progress_out)
{
    auto wrapper = static_cast<mavsdk_mission_raw_wrapper*>(mission_raw);

    auto ret_value = wrapper->cpp_plugin->mission_progress();

    if (mission_progress_out != nullptr) {
        *mission_progress_out = translate_mission_progress_to_c(ret_value);
    }
}

// MissionChanged async
mavsdk_mission_raw_mission_changed_handle_t mavsdk_mission_raw_subscribe_mission_changed(
    mavsdk_mission_raw_t mission_raw,
    mavsdk_mission_raw_mission_changed_callback_t callback,
    void* user_data)
{
    auto wrapper = static_cast<mavsdk_mission_raw_wrapper*>(mission_raw);

    auto cpp_handle =    wrapper->cpp_plugin->subscribe_mission_changed(
        [callback, user_data](
            bool value) {
                if (callback) {
                    callback(
                        value,
                        user_data);
                }
        });

    auto handle_wrapper = new mavsdk::MissionRaw::MissionChangedHandle(std::move(cpp_handle));
    return static_cast<mavsdk_mission_raw_mission_changed_handle_t>(handle_wrapper);
}

void mavsdk_mission_raw_unsubscribe_mission_changed(
    mavsdk_mission_raw_t mission_raw,
    mavsdk_mission_raw_mission_changed_handle_t handle)
{
    if (handle) {
        auto wrapper = static_cast<mavsdk_mission_raw_wrapper*>(mission_raw);
        auto cpp_handle = static_cast<mavsdk::MissionRaw::MissionChangedHandle*>(handle);
        wrapper->cpp_plugin->unsubscribe_mission_changed(std::move(*cpp_handle));
        delete cpp_handle;
    }
}



// ImportQgroundcontrolMission sync
mavsdk_mission_raw_result_t
mavsdk_mission_raw_import_qgroundcontrol_mission(
    mavsdk_mission_raw_t mission_raw,
    char* qgc_plan_path,
    mavsdk_mission_raw_mission_import_data_t* mission_import_data_out)
{
    auto wrapper = static_cast<mavsdk_mission_raw_wrapper*>(mission_raw);

    auto result_pair = wrapper->cpp_plugin->import_qgroundcontrol_mission(
        qgc_plan_path);

    if (mission_import_data_out != nullptr) {
        *mission_import_data_out = translate_mission_import_data_to_c(result_pair.second);
    }

    return translate_result(result_pair.first);
}


// ImportQgroundcontrolMissionFromString sync
mavsdk_mission_raw_result_t
mavsdk_mission_raw_import_qgroundcontrol_mission_from_string(
    mavsdk_mission_raw_t mission_raw,
    char* qgc_plan,
    mavsdk_mission_raw_mission_import_data_t* mission_import_data_out)
{
    auto wrapper = static_cast<mavsdk_mission_raw_wrapper*>(mission_raw);

    auto result_pair = wrapper->cpp_plugin->import_qgroundcontrol_mission_from_string(
        qgc_plan);

    if (mission_import_data_out != nullptr) {
        *mission_import_data_out = translate_mission_import_data_to_c(result_pair.second);
    }

    return translate_result(result_pair.first);
}


// ImportMissionPlannerMission sync
mavsdk_mission_raw_result_t
mavsdk_mission_raw_import_mission_planner_mission(
    mavsdk_mission_raw_t mission_raw,
    char* mission_planner_path,
    mavsdk_mission_raw_mission_import_data_t* mission_import_data_out)
{
    auto wrapper = static_cast<mavsdk_mission_raw_wrapper*>(mission_raw);

    auto result_pair = wrapper->cpp_plugin->import_mission_planner_mission(
        mission_planner_path);

    if (mission_import_data_out != nullptr) {
        *mission_import_data_out = translate_mission_import_data_to_c(result_pair.second);
    }

    return translate_result(result_pair.first);
}


// ImportMissionPlannerMissionFromString sync
mavsdk_mission_raw_result_t
mavsdk_mission_raw_import_mission_planner_mission_from_string(
    mavsdk_mission_raw_t mission_raw,
    char* mission_planner_mission,
    mavsdk_mission_raw_mission_import_data_t* mission_import_data_out)
{
    auto wrapper = static_cast<mavsdk_mission_raw_wrapper*>(mission_raw);

    auto result_pair = wrapper->cpp_plugin->import_mission_planner_mission_from_string(
        mission_planner_mission);

    if (mission_import_data_out != nullptr) {
        *mission_import_data_out = translate_mission_import_data_to_c(result_pair.second);
    }

    return translate_result(result_pair.first);
}


// IsMissionFinished sync
mavsdk_mission_raw_result_t
mavsdk_mission_raw_is_mission_finished(
    mavsdk_mission_raw_t mission_raw,
    bool* is_finished_out)
{
    auto wrapper = static_cast<mavsdk_mission_raw_wrapper*>(mission_raw);

    auto result_pair = wrapper->cpp_plugin->is_mission_finished(
);

    *is_finished_out = result_pair.second;

    return translate_result(result_pair.first);
}
