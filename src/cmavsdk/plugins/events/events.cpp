// WARNING: THIS FILE IS AUTOGENERATED! As such, it should not be edited.
// Edits need to be made to the proto files
// (see https://github.com/mavlink/MAVSDK-Proto/blob/main/protos/events/events.proto)

#include "events.h"

#include <mavsdk/plugins/events/events.h>
#include <cstring>
#include <vector>

// ===== C++ to C Type Conversions =====

static mavsdk_events_result_t
translate_result(mavsdk::Events::Result cpp_result) {
    switch(cpp_result) {
        case mavsdk::Events::Result::Success:
            return MAVSDK_EVENTS_RESULT_SUCCESS;
        case mavsdk::Events::Result::NotAvailable:
            return MAVSDK_EVENTS_RESULT_NOT_AVAILABLE;
        case mavsdk::Events::Result::ConnectionError:
            return MAVSDK_EVENTS_RESULT_CONNECTION_ERROR;
        case mavsdk::Events::Result::Unsupported:
            return MAVSDK_EVENTS_RESULT_UNSUPPORTED;
        case mavsdk::Events::Result::Denied:
            return MAVSDK_EVENTS_RESULT_DENIED;
        case mavsdk::Events::Result::Failed:
            return MAVSDK_EVENTS_RESULT_FAILED;
        case mavsdk::Events::Result::Timeout:
            return MAVSDK_EVENTS_RESULT_TIMEOUT;
        case mavsdk::Events::Result::NoSystem:
            return MAVSDK_EVENTS_RESULT_NO_SYSTEM;
        case mavsdk::Events::Result::Unknown:
            return MAVSDK_EVENTS_RESULT_UNKNOWN;
    }
}

static mavsdk::Events::LogLevel
translate_log_level_from_c(mavsdk_events_log_level_t c_enum) {
    switch(c_enum) {
        case MAVSDK_EVENTS_LOG_LEVEL_EMERGENCY:
            return mavsdk::Events::LogLevel::Emergency;
        case MAVSDK_EVENTS_LOG_LEVEL_ALERT:
            return mavsdk::Events::LogLevel::Alert;
        case MAVSDK_EVENTS_LOG_LEVEL_CRITICAL:
            return mavsdk::Events::LogLevel::Critical;
        case MAVSDK_EVENTS_LOG_LEVEL_ERROR:
            return mavsdk::Events::LogLevel::Error;
        case MAVSDK_EVENTS_LOG_LEVEL_WARNING:
            return mavsdk::Events::LogLevel::Warning;
        case MAVSDK_EVENTS_LOG_LEVEL_NOTICE:
            return mavsdk::Events::LogLevel::Notice;
        case MAVSDK_EVENTS_LOG_LEVEL_INFO:
            return mavsdk::Events::LogLevel::Info;
        case MAVSDK_EVENTS_LOG_LEVEL_DEBUG:
            return mavsdk::Events::LogLevel::Debug;
    }
    return mavsdk::Events::LogLevel::Emergency;
}

static mavsdk_events_log_level_t
translate_log_level_to_c(mavsdk::Events::LogLevel cpp_enum) {
    switch(cpp_enum) {
        case mavsdk::Events::LogLevel::Emergency:
            return MAVSDK_EVENTS_LOG_LEVEL_EMERGENCY;
        case mavsdk::Events::LogLevel::Alert:
            return MAVSDK_EVENTS_LOG_LEVEL_ALERT;
        case mavsdk::Events::LogLevel::Critical:
            return MAVSDK_EVENTS_LOG_LEVEL_CRITICAL;
        case mavsdk::Events::LogLevel::Error:
            return MAVSDK_EVENTS_LOG_LEVEL_ERROR;
        case mavsdk::Events::LogLevel::Warning:
            return MAVSDK_EVENTS_LOG_LEVEL_WARNING;
        case mavsdk::Events::LogLevel::Notice:
            return MAVSDK_EVENTS_LOG_LEVEL_NOTICE;
        case mavsdk::Events::LogLevel::Info:
            return MAVSDK_EVENTS_LOG_LEVEL_INFO;
        case mavsdk::Events::LogLevel::Debug:
            return MAVSDK_EVENTS_LOG_LEVEL_DEBUG;
    }
    return MAVSDK_EVENTS_LOG_LEVEL_EMERGENCY;
}



static mavsdk::Events::Event
translate_event_from_c(const mavsdk_events_event_t& c_struct) {
    mavsdk::Events::Event cpp_struct{};
    cpp_struct.compid = c_struct.compid;
    if (c_struct.message) {
        cpp_struct.message = c_struct.message;
    }
    if (c_struct.description) {
        cpp_struct.description = c_struct.description;
    }
    cpp_struct.log_level = translate_log_level_from_c(c_struct.log_level);
    if (c_struct.event_namespace) {
        cpp_struct.event_namespace = c_struct.event_namespace;
    }
    if (c_struct.event_name) {
        cpp_struct.event_name = c_struct.event_name;
    }
    return cpp_struct;
}

static mavsdk_events_event_t
translate_event_to_c(const mavsdk::Events::Event& cpp_struct) {
    mavsdk_events_event_t c_struct{};
    c_struct.compid = cpp_struct.compid;
    c_struct.message = strdup(cpp_struct.message.c_str());
    c_struct.description = strdup(cpp_struct.description.c_str());
    c_struct.log_level = translate_log_level_to_c(cpp_struct.log_level);
    c_struct.event_namespace = strdup(cpp_struct.event_namespace.c_str());
    c_struct.event_name = strdup(cpp_struct.event_name.c_str());
    return c_struct;
}

void mavsdk_events_event_destroy(
    mavsdk_events_event_t* target) {
    if (!target) return;
    if (target->message) {
        free((void*)target->message);
        target->message = nullptr;
    }
    if (target->description) {
        free((void*)target->description);
        target->description = nullptr;
    }
    if (target->event_namespace) {
        free((void*)target->event_namespace);
        target->event_namespace = nullptr;
    }
    if (target->event_name) {
        free((void*)target->event_name);
        target->event_name = nullptr;
    }
}

void mavsdk_events_event_array_destroy(
    mavsdk_events_event_t** array,
    size_t size) {
    if (!array || !*array) return;

    for (size_t i = 0; i < size; i++) {
        mavsdk_events_event_destroy(&(*array)[i]);
    }

    delete[] *array;
    *array = nullptr;
}


static mavsdk::Events::HealthAndArmingCheckProblem
translate_health_and_arming_check_problem_from_c(const mavsdk_events_health_and_arming_check_problem_t& c_struct) {
    mavsdk::Events::HealthAndArmingCheckProblem cpp_struct{};
    if (c_struct.message) {
        cpp_struct.message = c_struct.message;
    }
    if (c_struct.description) {
        cpp_struct.description = c_struct.description;
    }
    cpp_struct.log_level = translate_log_level_from_c(c_struct.log_level);
    if (c_struct.health_component) {
        cpp_struct.health_component = c_struct.health_component;
    }
    return cpp_struct;
}

static mavsdk_events_health_and_arming_check_problem_t
translate_health_and_arming_check_problem_to_c(const mavsdk::Events::HealthAndArmingCheckProblem& cpp_struct) {
    mavsdk_events_health_and_arming_check_problem_t c_struct{};
    c_struct.message = strdup(cpp_struct.message.c_str());
    c_struct.description = strdup(cpp_struct.description.c_str());
    c_struct.log_level = translate_log_level_to_c(cpp_struct.log_level);
    c_struct.health_component = strdup(cpp_struct.health_component.c_str());
    return c_struct;
}

void mavsdk_events_health_and_arming_check_problem_destroy(
    mavsdk_events_health_and_arming_check_problem_t* target) {
    if (!target) return;
    if (target->message) {
        free((void*)target->message);
        target->message = nullptr;
    }
    if (target->description) {
        free((void*)target->description);
        target->description = nullptr;
    }
    if (target->health_component) {
        free((void*)target->health_component);
        target->health_component = nullptr;
    }
}

void mavsdk_events_health_and_arming_check_problem_array_destroy(
    mavsdk_events_health_and_arming_check_problem_t** array,
    size_t size) {
    if (!array || !*array) return;

    for (size_t i = 0; i < size; i++) {
        mavsdk_events_health_and_arming_check_problem_destroy(&(*array)[i]);
    }

    delete[] *array;
    *array = nullptr;
}


static mavsdk::Events::HealthAndArmingCheckMode
translate_health_and_arming_check_mode_from_c(const mavsdk_events_health_and_arming_check_mode_t& c_struct) {
    mavsdk::Events::HealthAndArmingCheckMode cpp_struct{};
    if (c_struct.mode_name) {
        cpp_struct.mode_name = c_struct.mode_name;
    }
    cpp_struct.can_arm_or_run = c_struct.can_arm_or_run;
    cpp_struct.problems.reserve(c_struct.problems_size);
    for (size_t i = 0; i < c_struct.problems_size; i++) {
        cpp_struct.problems.push_back(
            translate_health_and_arming_check_problem_from_c(c_struct.problems[i]));
    }
    return cpp_struct;
}

static mavsdk_events_health_and_arming_check_mode_t
translate_health_and_arming_check_mode_to_c(const mavsdk::Events::HealthAndArmingCheckMode& cpp_struct) {
    mavsdk_events_health_and_arming_check_mode_t c_struct{};
    c_struct.mode_name = strdup(cpp_struct.mode_name.c_str());
    c_struct.can_arm_or_run = cpp_struct.can_arm_or_run;
    c_struct.problems_size = cpp_struct.problems.size();
    c_struct.problems = new mavsdk_events_health_and_arming_check_problem_t[c_struct.problems_size];
    for (size_t i = 0; i < c_struct.problems_size; i++) {
        c_struct.problems[i] = translate_health_and_arming_check_problem_to_c(cpp_struct.problems[i]);
    }
    return c_struct;
}

void mavsdk_events_health_and_arming_check_mode_destroy(
    mavsdk_events_health_and_arming_check_mode_t* target) {
    if (!target) return;
    if (target->mode_name) {
        free((void*)target->mode_name);
        target->mode_name = nullptr;
    }
    if (target->problems) {
        for (size_t i = 0; i < target->problems_size; i++) {
            mavsdk_events_health_and_arming_check_problem_destroy(&target->problems[i]);
        }
        delete[] target->problems;
        target->problems = nullptr;
        target->problems_size = 0;
    }
}

void mavsdk_events_health_and_arming_check_mode_array_destroy(
    mavsdk_events_health_and_arming_check_mode_t** array,
    size_t size) {
    if (!array || !*array) return;

    for (size_t i = 0; i < size; i++) {
        mavsdk_events_health_and_arming_check_mode_destroy(&(*array)[i]);
    }

    delete[] *array;
    *array = nullptr;
}


static mavsdk::Events::HealthComponentReport
translate_health_component_report_from_c(const mavsdk_events_health_component_report_t& c_struct) {
    mavsdk::Events::HealthComponentReport cpp_struct{};
    if (c_struct.name) {
        cpp_struct.name = c_struct.name;
    }
    if (c_struct.label) {
        cpp_struct.label = c_struct.label;
    }
    cpp_struct.is_present = c_struct.is_present;
    cpp_struct.has_error = c_struct.has_error;
    cpp_struct.has_warning = c_struct.has_warning;
    return cpp_struct;
}

static mavsdk_events_health_component_report_t
translate_health_component_report_to_c(const mavsdk::Events::HealthComponentReport& cpp_struct) {
    mavsdk_events_health_component_report_t c_struct{};
    c_struct.name = strdup(cpp_struct.name.c_str());
    c_struct.label = strdup(cpp_struct.label.c_str());
    c_struct.is_present = cpp_struct.is_present;
    c_struct.has_error = cpp_struct.has_error;
    c_struct.has_warning = cpp_struct.has_warning;
    return c_struct;
}

void mavsdk_events_health_component_report_destroy(
    mavsdk_events_health_component_report_t* target) {
    if (!target) return;
    if (target->name) {
        free((void*)target->name);
        target->name = nullptr;
    }
    if (target->label) {
        free((void*)target->label);
        target->label = nullptr;
    }
}

void mavsdk_events_health_component_report_array_destroy(
    mavsdk_events_health_component_report_t** array,
    size_t size) {
    if (!array || !*array) return;

    for (size_t i = 0; i < size; i++) {
        mavsdk_events_health_component_report_destroy(&(*array)[i]);
    }

    delete[] *array;
    *array = nullptr;
}


static mavsdk::Events::HealthAndArmingCheckReport
translate_health_and_arming_check_report_from_c(const mavsdk_events_health_and_arming_check_report_t& c_struct) {
    mavsdk::Events::HealthAndArmingCheckReport cpp_struct{};
    cpp_struct.current_mode_intention = translate_health_and_arming_check_mode_from_c(c_struct.current_mode_intention);
    cpp_struct.health_components.reserve(c_struct.health_components_size);
    for (size_t i = 0; i < c_struct.health_components_size; i++) {
        cpp_struct.health_components.push_back(
            translate_health_component_report_from_c(c_struct.health_components[i]));
    }
    cpp_struct.all_problems.reserve(c_struct.all_problems_size);
    for (size_t i = 0; i < c_struct.all_problems_size; i++) {
        cpp_struct.all_problems.push_back(
            translate_health_and_arming_check_problem_from_c(c_struct.all_problems[i]));
    }
    return cpp_struct;
}

static mavsdk_events_health_and_arming_check_report_t
translate_health_and_arming_check_report_to_c(const mavsdk::Events::HealthAndArmingCheckReport& cpp_struct) {
    mavsdk_events_health_and_arming_check_report_t c_struct{};
    c_struct.current_mode_intention = translate_health_and_arming_check_mode_to_c(cpp_struct.current_mode_intention);
    c_struct.health_components_size = cpp_struct.health_components.size();
    c_struct.health_components = new mavsdk_events_health_component_report_t[c_struct.health_components_size];
    for (size_t i = 0; i < c_struct.health_components_size; i++) {
        c_struct.health_components[i] = translate_health_component_report_to_c(cpp_struct.health_components[i]);
    }
    c_struct.all_problems_size = cpp_struct.all_problems.size();
    c_struct.all_problems = new mavsdk_events_health_and_arming_check_problem_t[c_struct.all_problems_size];
    for (size_t i = 0; i < c_struct.all_problems_size; i++) {
        c_struct.all_problems[i] = translate_health_and_arming_check_problem_to_c(cpp_struct.all_problems[i]);
    }
    return c_struct;
}

void mavsdk_events_health_and_arming_check_report_destroy(
    mavsdk_events_health_and_arming_check_report_t* target) {
    if (!target) return;
    if (target->health_components) {
        for (size_t i = 0; i < target->health_components_size; i++) {
            mavsdk_events_health_component_report_destroy(&target->health_components[i]);
        }
        delete[] target->health_components;
        target->health_components = nullptr;
        target->health_components_size = 0;
    }
    if (target->all_problems) {
        for (size_t i = 0; i < target->all_problems_size; i++) {
            mavsdk_events_health_and_arming_check_problem_destroy(&target->all_problems[i]);
        }
        delete[] target->all_problems;
        target->all_problems = nullptr;
        target->all_problems_size = 0;
    }
}

void mavsdk_events_health_and_arming_check_report_array_destroy(
    mavsdk_events_health_and_arming_check_report_t** array,
    size_t size) {
    if (!array || !*array) return;

    for (size_t i = 0; i < size; i++) {
        mavsdk_events_health_and_arming_check_report_destroy(&(*array)[i]);
    }

    delete[] *array;
    *array = nullptr;
}



// ===== Primitive Array Destroy Functions =====
void mavsdk_events_float_array_destroy(float** array) {
    if (!array || !*array) return;
    delete[] *array;
    *array = nullptr;
}

void mavsdk_events_double_array_destroy(double** array) {
    if (!array || !*array) return;
    delete[] *array;
    *array = nullptr;
}

void mavsdk_events_int32t_array_destroy(int32_t** array) {
    if (!array || !*array) return;
    delete[] *array;
    *array = nullptr;
}

void mavsdk_events_uint32t_array_destroy(uint32_t** array) {
    if (!array || !*array) return;
    delete[] *array;
    *array = nullptr;
}

void mavsdk_events_int64t_array_destroy(int64_t** array) {
    if (!array || !*array) return;
    delete[] *array;
    *array = nullptr;
}

void mavsdk_events_uint64t_array_destroy(uint64_t** array) {
    if (!array || !*array) return;
    delete[] *array;
    *array = nullptr;
}

void mavsdk_events_bool_array_destroy(bool** array) {
    if (!array || !*array) return;
    delete[] *array;
    *array = nullptr;
}


void mavsdk_events_string_destroy(char** str) {
    if (!str || !*str) return;
    free(*str);
    *str = nullptr;
}

void mavsdk_events_byte_buffer_destroy(uint8_t** buffer) {
    if (!buffer || !*buffer) return;
    delete[] *buffer;
    *buffer = nullptr;
}

// ===== Events Wrapper =====

struct mavsdk_events_wrapper {
    std::shared_ptr<mavsdk::Events> cpp_plugin;
};

mavsdk_events_t
mavsdk_events_create(mavsdk_system_t system) {
    if (system == nullptr) {
        return nullptr;
    }

    auto wrapper = new mavsdk_events_wrapper();
    auto system_ptr = static_cast<std::shared_ptr<mavsdk::System>*>(system);
    wrapper->cpp_plugin = std::make_shared<mavsdk::Events>(*system_ptr);

    return wrapper;
}

void mavsdk_events_destroy(mavsdk_events_t events) {
    if (events == nullptr) {
        return;
    }

    auto wrapper = static_cast<mavsdk_events_wrapper*>(events);
    delete wrapper;
}

// ===== Method Implementations =====

// Events async
mavsdk_events_events_handle_t mavsdk_events_subscribe_events(
    mavsdk_events_t events,
    mavsdk_events_events_callback_t callback,
    void* user_data)
{
    auto wrapper = static_cast<mavsdk_events_wrapper*>(events);

    auto cpp_handle =    wrapper->cpp_plugin->subscribe_events(
        [callback, user_data](
            mavsdk::Events::Event value) {
                if (callback) {
                    callback(
                        translate_event_to_c(value),
                        user_data);
                }
        });

    auto handle_wrapper = new mavsdk::Events::EventsHandle(std::move(cpp_handle));
    return static_cast<mavsdk_events_events_handle_t>(handle_wrapper);
}

void mavsdk_events_unsubscribe_events(
    mavsdk_events_t events,
    mavsdk_events_events_handle_t handle)
{
    if (handle) {
        auto wrapper = static_cast<mavsdk_events_wrapper*>(events);
        auto cpp_handle = static_cast<mavsdk::Events::EventsHandle*>(handle);
        wrapper->cpp_plugin->unsubscribe_events(std::move(*cpp_handle));
        delete cpp_handle;
    }
}


// HealthAndArmingChecks async
mavsdk_events_health_and_arming_checks_handle_t mavsdk_events_subscribe_health_and_arming_checks(
    mavsdk_events_t events,
    mavsdk_events_health_and_arming_checks_callback_t callback,
    void* user_data)
{
    auto wrapper = static_cast<mavsdk_events_wrapper*>(events);

    auto cpp_handle =    wrapper->cpp_plugin->subscribe_health_and_arming_checks(
        [callback, user_data](
            mavsdk::Events::HealthAndArmingCheckReport value) {
                if (callback) {
                    callback(
                        translate_health_and_arming_check_report_to_c(value),
                        user_data);
                }
        });

    auto handle_wrapper = new mavsdk::Events::HealthAndArmingChecksHandle(std::move(cpp_handle));
    return static_cast<mavsdk_events_health_and_arming_checks_handle_t>(handle_wrapper);
}

void mavsdk_events_unsubscribe_health_and_arming_checks(
    mavsdk_events_t events,
    mavsdk_events_health_and_arming_checks_handle_t handle)
{
    if (handle) {
        auto wrapper = static_cast<mavsdk_events_wrapper*>(events);
        auto cpp_handle = static_cast<mavsdk::Events::HealthAndArmingChecksHandle*>(handle);
        wrapper->cpp_plugin->unsubscribe_health_and_arming_checks(std::move(*cpp_handle));
        delete cpp_handle;
    }
}



// GetHealthAndArmingChecksReport sync
mavsdk_events_result_t
mavsdk_events_get_health_and_arming_checks_report(
    mavsdk_events_t events,
    mavsdk_events_health_and_arming_check_report_t* report_out)
{
    auto wrapper = static_cast<mavsdk_events_wrapper*>(events);

    auto result_pair = wrapper->cpp_plugin->get_health_and_arming_checks_report(
);

    if (report_out != nullptr) {
        *report_out = translate_health_and_arming_check_report_to_c(result_pair.second);
    }

    return translate_result(result_pair.first);
}
