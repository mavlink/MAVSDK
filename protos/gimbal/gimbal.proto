syntax = "proto3";

package mavsdk.rpc.gimbal;

option java_package = "io.mavsdk.gimbal";
option java_outer_classname = "GimbalProto";

// Provide control over a gimbal.
service GimbalService {
    /*
     *
     * Set gimbal pitch and yaw angles.
     *
     * This sets the desired pitch and yaw angles of a gimbal.
     * Will return when the command is accepted, however, it might
     * take the gimbal longer to actually be set to the new angles.
     */
    rpc SetPitchAndYaw(SetPitchAndYawRequest) returns(SetPitchAndYawResponse) {}
    /*
     *
     * Set gimbal angular rates around pitch and yaw axes.
     *
     * This sets the desired angular rates around pitch and yaw axes of a gimbal.
     * Will return when the command is accepted, however, it might
     * take the gimbal longer to actually reach the angular rate.
     */
    rpc SetPitchRateAndYawRate(SetPitchRateAndYawRateRequest) returns(SetPitchRateAndYawRateResponse) {}
    /*
     * Set gimbal mode.
     *
     * This sets the desired yaw mode of a gimbal.
     * Will return when the command is accepted. However, it might
     * take the gimbal longer to actually be set to the new angles.
     */
    rpc SetMode(SetModeRequest) returns(SetModeResponse) {}
    /*
     * Set gimbal region of interest (ROI).
     *
     * This sets a region of interest that the gimbal will point to.
     * The gimbal will continue to point to the specified region until it
     * receives a new command.
     * The function will return when the command is accepted, however, it might
     * take the gimbal longer to actually rotate to the ROI.
     */
     rpc SetRoiLocation(SetRoiLocationRequest) returns(SetRoiLocationResponse) {}
     /*
      * Take control.
      *
      * There can be only two components in control of a gimbal at any given time.
      * One with "primary" control, and one with "secondary" control. The way the
      * secondary control is implemented is not specified and hence depends on the
      * vehicle.
      *
      * Components are expected to be cooperative, which means that they can
      * override each other and should therefore do it carefully.
      */
     rpc TakeControl(TakeControlRequest) returns(TakeControlResponse) {}
     /*
      * Release control.
      *
      * Release control, such that other components can control the gimbal.
      */
     rpc ReleaseControl(ReleaseControlRequest) returns(ReleaseControlResponse) {}
     /*
      * Subscribe to control status updates.
      *
      * This allows a component to know if it has primary, secondary or
      * no control over the gimbal. Also, it gives the system and component ids
      * of the other components in control (if any).
      */
     rpc SubscribeControl(SubscribeControlRequest) returns(stream ControlResponse) {}
}

message SetPitchAndYawRequest {
    float pitch_deg = 1; // Pitch angle in degrees (negative points down)
    float yaw_deg = 2; // Yaw angle in degrees (positive is clock-wise, range: -180 to 180 or 0 to 360)
}
message SetPitchAndYawResponse {
    GimbalResult gimbal_result = 1;
}

message SetPitchRateAndYawRateRequest {
    float pitch_rate_deg_s = 1; // Angular rate around pitch axis in degrees/second (negative downward)
    float yaw_rate_deg_s = 2; // Angular rate around yaw axis in degrees/second (positive is clock-wise)
}
message SetPitchRateAndYawRateResponse {
    GimbalResult gimbal_result = 1;
}

message SetModeRequest {
    GimbalMode gimbal_mode = 1; // The mode to be set.
}
message SetModeResponse {
    GimbalResult gimbal_result = 1;
}

message SetRoiLocationRequest {
    double latitude_deg = 1; // Latitude in degrees
    double longitude_deg = 2; // Longitude in degrees
    float altitude_m = 3; // Altitude in metres (AMSL)
}
message SetRoiLocationResponse {
    GimbalResult gimbal_result = 1;
}

message TakeControlRequest {
    ControlMode control_mode = 1; // Control mode (primary or secondary)
}
message TakeControlResponse {
    GimbalResult gimbal_result = 1;
}

message ReleaseControlRequest {}
message ReleaseControlResponse {
    GimbalResult gimbal_result = 1;
}

message SubscribeControlRequest {}
message ControlResponse {
    ControlStatus control_status = 1; // Control status
}

// Gimbal mode type.
enum GimbalMode {
    GIMBAL_MODE_YAW_FOLLOW = 0; // Yaw follow will point the gimbal to the vehicle heading
    GIMBAL_MODE_YAW_LOCK = 1; // Yaw lock will fix the gimbal poiting to an absolute direction
}

// Control mode
enum ControlMode {
    CONTROL_MODE_NONE = 0; // Indicates that the component does not have control over the gimbal
    CONTROL_MODE_PRIMARY = 1; // To take primary control over the gimbal
    CONTROL_MODE_SECONDARY = 2; // To take secondary control over the gimbal
}

// Control status
message ControlStatus {
    ControlMode control_mode = 1; // Control mode (none, primary or secondary)
    int32 sysid_primary_control = 2; // Sysid of the component that has primary control over the gimbal (0 if no one is in control)
    int32 compid_primary_control = 3; // Compid of the component that has primary control over the gimbal (0 if no one is in control)
    int32 sysid_secondary_control = 4; // Sysid of the component that has secondary control over the gimbal (0 if no one is in control)
    int32 compid_secondary_control = 5; // Compid of the component that has secondary control over the gimbal (0 if no one is in control)
}

// Result type.
message GimbalResult {
    // Possible results returned for gimbal commands.
    enum Result {
        RESULT_UNKNOWN = 0; // Unknown result
        RESULT_SUCCESS = 1; // Command was accepted
        RESULT_ERROR = 2; // Error occurred sending the command
        RESULT_TIMEOUT = 3; // Command timed out
        RESULT_UNSUPPORTED = 4; // Functionality not supported
        RESULT_NO_SYSTEM = 5; // No system connected
    }

    Result result = 1; // Result enum value
    string result_str = 2; // Human-readable English string describing the result
}
