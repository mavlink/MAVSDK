# ruff: noqa: F401
# WARNING: THIS FILE IS AUTOGENERATED! As such, it should not be edited.
# Edits need to be made to the proto files
# (see https://github.com/mavlink/MAVSDK-Proto/blob/main/protos/mission_raw_server/mission_raw_server.proto)
"""
Acts as a vehicle and receives incoming missions from GCS (in raw MAVLINK format).
 Provides current mission item state, so the server can progress through missions.
"""

import asyncio
from typing import AsyncGenerator
from mavsdk.plugins.mission_raw_server import (
    MissionRawServer,
    MissionRawServerResult,
    MissionItem,
    MissionPlan,
    MissionProgress,
)


class MissionRawServerError(Exception):
    """Raised when a MissionRawServer operation fails."""

    def __init__(self, result, origin, *params):
        self._result = result
        self._origin = origin
        self._params = params

    def __str__(self):
        return f"{self._result}: '{self._result.name}'; origin: {self._origin}; params: {self._params}"


class MissionRawServerAsync:
    """
       Acts as a vehicle and receives incoming missions from GCS (in raw MAVLINK format).
    Provides current mission item state, so the server can progress through missions.

       Async wrapper around :class:`MissionRawServer` that mirrors the gRPC-based
       asyncio API while using the ctypes-based C library directly.
    """

    def __init__(self, server_component):
        self._subscription_handles: dict = {}
        self._plugin = MissionRawServer(server_component)

    async def subscribe_incoming_mission(self) -> AsyncGenerator[MissionPlan, None]:
        """
        Subscribe to when a new mission is uploaded (asynchronous).

        Yields
        ------
        mission_plan : MissionPlan
             The next update
        """
        loop = asyncio.get_running_loop()
        queue: asyncio.Queue = asyncio.Queue()

        def callback(data, _user_data):
            loop.call_soon_threadsafe(queue.put_nowait, data)

        handle = self._plugin.subscribe_incoming_mission(callback)
        self._subscription_handles[id(queue)] = handle
        try:
            while True:
                yield await queue.get()
        finally:
            if id(queue) in self._subscription_handles:
                self._subscription_handles.pop(id(queue))
                self._plugin.unsubscribe_incoming_mission(handle)

    async def subscribe_current_item_changed(self) -> AsyncGenerator[MissionItem, None]:
        """
        Subscribe to when a new current item is set

        Yields
        ------
        mission_item : MissionItem
             The next update
        """
        loop = asyncio.get_running_loop()
        queue: asyncio.Queue = asyncio.Queue()

        def callback(data, _user_data):
            loop.call_soon_threadsafe(queue.put_nowait, data)

        handle = self._plugin.subscribe_current_item_changed(callback)
        self._subscription_handles[id(queue)] = handle
        try:
            while True:
                yield await queue.get()
        finally:
            if id(queue) in self._subscription_handles:
                self._subscription_handles.pop(id(queue))
                self._plugin.unsubscribe_current_item_changed(handle)

    async def set_current_item_complete(self):
        """
        Set Current item as completed

        Raises
        ------
        MissionRawServerError
            If the request fails. The error contains the reason for the failure.
        """
        loop = asyncio.get_running_loop()
        return await loop.run_in_executor(
            None, lambda: self._plugin.set_current_item_complete()
        )

    async def subscribe_clear_all(self) -> AsyncGenerator[int, None]:
        """
        Subscribe when a MISSION_CLEAR_ALL is received

        Yields
        ------
         : int
             The next update
        """
        loop = asyncio.get_running_loop()
        queue: asyncio.Queue = asyncio.Queue()

        def callback(data, _user_data):
            loop.call_soon_threadsafe(queue.put_nowait, data)

        handle = self._plugin.subscribe_clear_all(callback)
        self._subscription_handles[id(queue)] = handle
        try:
            while True:
                yield await queue.get()
        finally:
            if id(queue) in self._subscription_handles:
                self._subscription_handles.pop(id(queue))
                self._plugin.unsubscribe_clear_all(handle)

    def destroy(self):
        self._subscription_handles.clear()
        self._plugin.destroy()

    def __del__(self):
        self.destroy()
