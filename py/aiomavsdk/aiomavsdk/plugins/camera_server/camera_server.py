# ruff: noqa: F401
# WARNING: THIS FILE IS AUTOGENERATED! As such, it should not be edited.
# Edits need to be made to the proto files
# (see https://github.com/mavlink/MAVSDK-Proto/blob/main/protos/camera_server/camera_server.proto)
"""
Provides handling of camera interface
"""

import asyncio
from typing import AsyncGenerator
from mavsdk.plugins.camera_server import (
    CameraServer,
    CameraServerResult,
    CameraFeedback,
    Mode,
    Information,
    VideoStreaming,
    Position,
    Quaternion,
    CaptureInfo,
    StorageInformation,
    CaptureStatus,
    TrackPoint,
    TrackRectangle,
)


class CameraServerError(Exception):
    """Raised when a CameraServer operation fails."""

    def __init__(self, result, origin, *params):
        self._result = result
        self._origin = origin
        self._params = params

    def __str__(self):
        return f"{self._result}: '{self._result.name}'; origin: {self._origin}; params: {self._params}"


class CameraServerAsync:
    """
    Provides handling of camera interface

    Async wrapper around :class:`CameraServer` that mirrors the gRPC-based
    asyncio API while using the ctypes-based C library directly.
    """

    def __init__(self, server_component):
        self._subscription_handles: dict = {}
        self._plugin = CameraServer(server_component)

    async def set_information(self, information):
        """
        Sets the camera information. This must be called as soon as the camera server is created.

        Parameters
        ----------
        information : Information
        Raises
        ------
        CameraServerError
            If the request fails. The error contains the reason for the failure.
        """
        loop = asyncio.get_running_loop()
        return await loop.run_in_executor(
            None, lambda: self._plugin.set_information(information)
        )

    async def set_video_streaming(self, video_streaming):
        """
        Sets video streaming settings.

        Parameters
        ----------
        video_streaming : VideoStreaming
        Raises
        ------
        CameraServerError
            If the request fails. The error contains the reason for the failure.
        """
        loop = asyncio.get_running_loop()
        return await loop.run_in_executor(
            None, lambda: self._plugin.set_video_streaming(video_streaming)
        )

    async def set_in_progress(self, in_progress):
        """
        Sets image capture in progress status flags. This should be set to true when the camera is busy taking a photo and false when it is done.

        Parameters
        ----------
        in_progress : bool
        Raises
        ------
        CameraServerError
            If the request fails. The error contains the reason for the failure.
        """
        loop = asyncio.get_running_loop()
        return await loop.run_in_executor(
            None, lambda: self._plugin.set_in_progress(in_progress)
        )

    async def subscribe_take_photo(self) -> AsyncGenerator[int, None]:
        """
        Subscribe to image capture requests. Each request received should respond to using RespondTakePhoto.

        Yields
        ------
         : int
             The next update
        """
        loop = asyncio.get_running_loop()
        queue: asyncio.Queue = asyncio.Queue()

        def callback(data, _user_data):
            loop.call_soon_threadsafe(queue.put_nowait, data)

        handle = self._plugin.subscribe_take_photo(callback)
        self._subscription_handles[id(queue)] = handle
        try:
            while True:
                yield await queue.get()
        finally:
            if id(queue) in self._subscription_handles:
                self._subscription_handles.pop(id(queue))
                self._plugin.unsubscribe_take_photo(handle)

    async def respond_take_photo(self, take_photo_feedback, capture_info):
        """
        Respond to an image capture request from SubscribeTakePhoto.

        Parameters
        ----------
        take_photo_feedback : CameraFeedback
        capture_info : CaptureInfo
        Raises
        ------
        CameraServerError
            If the request fails. The error contains the reason for the failure.
        """
        loop = asyncio.get_running_loop()
        return await loop.run_in_executor(
            None,
            lambda: self._plugin.respond_take_photo(take_photo_feedback, capture_info),
        )

    async def subscribe_start_video(self) -> AsyncGenerator[int, None]:
        """
        Subscribe to start video requests. Each request received should respond to using RespondStartVideo

        Yields
        ------
         : int
             The next update
        """
        loop = asyncio.get_running_loop()
        queue: asyncio.Queue = asyncio.Queue()

        def callback(data, _user_data):
            loop.call_soon_threadsafe(queue.put_nowait, data)

        handle = self._plugin.subscribe_start_video(callback)
        self._subscription_handles[id(queue)] = handle
        try:
            while True:
                yield await queue.get()
        finally:
            if id(queue) in self._subscription_handles:
                self._subscription_handles.pop(id(queue))
                self._plugin.unsubscribe_start_video(handle)

    async def respond_start_video(self, start_video_feedback):
        """
        Subscribe to stop video requests. Each request received should respond using StopVideoResponse

        Parameters
        ----------
        start_video_feedback : CameraFeedback
        Raises
        ------
        CameraServerError
            If the request fails. The error contains the reason for the failure.
        """
        loop = asyncio.get_running_loop()
        return await loop.run_in_executor(
            None, lambda: self._plugin.respond_start_video(start_video_feedback)
        )

    async def subscribe_stop_video(self) -> AsyncGenerator[int, None]:
        """
        Subscribe to stop video requests. Each request received should response to using RespondStopVideo

        Yields
        ------
         : int
             The next update
        """
        loop = asyncio.get_running_loop()
        queue: asyncio.Queue = asyncio.Queue()

        def callback(data, _user_data):
            loop.call_soon_threadsafe(queue.put_nowait, data)

        handle = self._plugin.subscribe_stop_video(callback)
        self._subscription_handles[id(queue)] = handle
        try:
            while True:
                yield await queue.get()
        finally:
            if id(queue) in self._subscription_handles:
                self._subscription_handles.pop(id(queue))
                self._plugin.unsubscribe_stop_video(handle)

    async def respond_stop_video(self, stop_video_feedback):
        """
        Respond to stop video request from SubscribeStopVideo.

        Parameters
        ----------
        stop_video_feedback : CameraFeedback
        Raises
        ------
        CameraServerError
            If the request fails. The error contains the reason for the failure.
        """
        loop = asyncio.get_running_loop()
        return await loop.run_in_executor(
            None, lambda: self._plugin.respond_stop_video(stop_video_feedback)
        )

    async def subscribe_start_video_streaming(self) -> AsyncGenerator[int, None]:
        """
        Subscribe to start video streaming requests. Each request received should response to using RespondStartVideoStreaming

        Yields
        ------
         : int
             The next update
        """
        loop = asyncio.get_running_loop()
        queue: asyncio.Queue = asyncio.Queue()

        def callback(data, _user_data):
            loop.call_soon_threadsafe(queue.put_nowait, data)

        handle = self._plugin.subscribe_start_video_streaming(callback)
        self._subscription_handles[id(queue)] = handle
        try:
            while True:
                yield await queue.get()
        finally:
            if id(queue) in self._subscription_handles:
                self._subscription_handles.pop(id(queue))
                self._plugin.unsubscribe_start_video_streaming(handle)

    async def respond_start_video_streaming(self, start_video_streaming_feedback):
        """
        Respond to start video streaming from SubscribeStartVideoStreaming.

        Parameters
        ----------
        start_video_streaming_feedback : CameraFeedback
        Raises
        ------
        CameraServerError
            If the request fails. The error contains the reason for the failure.
        """
        loop = asyncio.get_running_loop()
        return await loop.run_in_executor(
            None,
            lambda: self._plugin.respond_start_video_streaming(
                start_video_streaming_feedback
            ),
        )

    async def subscribe_stop_video_streaming(self) -> AsyncGenerator[int, None]:
        """
        Subscribe to stop video streaming requests. Each request received should response to using RespondStopVideoStreaming

        Yields
        ------
         : int
             The next update
        """
        loop = asyncio.get_running_loop()
        queue: asyncio.Queue = asyncio.Queue()

        def callback(data, _user_data):
            loop.call_soon_threadsafe(queue.put_nowait, data)

        handle = self._plugin.subscribe_stop_video_streaming(callback)
        self._subscription_handles[id(queue)] = handle
        try:
            while True:
                yield await queue.get()
        finally:
            if id(queue) in self._subscription_handles:
                self._subscription_handles.pop(id(queue))
                self._plugin.unsubscribe_stop_video_streaming(handle)

    async def respond_stop_video_streaming(self, stop_video_streaming_feedback):
        """
        Respond to stop video streaming from SubscribeStopVideoStreaming.

        Parameters
        ----------
        stop_video_streaming_feedback : CameraFeedback
        Raises
        ------
        CameraServerError
            If the request fails. The error contains the reason for the failure.
        """
        loop = asyncio.get_running_loop()
        return await loop.run_in_executor(
            None,
            lambda: self._plugin.respond_stop_video_streaming(
                stop_video_streaming_feedback
            ),
        )

    async def subscribe_set_mode(self) -> AsyncGenerator[Mode, None]:
        """
        Subscribe to set camera mode requests. Each request received should response to using RespondSetMode

        Yields
        ------
        mode : Mode
             The next update
        """
        loop = asyncio.get_running_loop()
        queue: asyncio.Queue = asyncio.Queue()

        def callback(data, _user_data):
            loop.call_soon_threadsafe(queue.put_nowait, data)

        handle = self._plugin.subscribe_set_mode(callback)
        self._subscription_handles[id(queue)] = handle
        try:
            while True:
                yield await queue.get()
        finally:
            if id(queue) in self._subscription_handles:
                self._subscription_handles.pop(id(queue))
                self._plugin.unsubscribe_set_mode(handle)

    async def respond_set_mode(self, set_mode_feedback):
        """
        Respond to set camera mode from SubscribeSetMode.

        Parameters
        ----------
        set_mode_feedback : CameraFeedback
        Raises
        ------
        CameraServerError
            If the request fails. The error contains the reason for the failure.
        """
        loop = asyncio.get_running_loop()
        return await loop.run_in_executor(
            None, lambda: self._plugin.respond_set_mode(set_mode_feedback)
        )

    async def subscribe_storage_information(self) -> AsyncGenerator[int, None]:
        """
        Subscribe to camera storage information requests. Each request received should response to using RespondStorageInformation

        Yields
        ------
         : int
             The next update
        """
        loop = asyncio.get_running_loop()
        queue: asyncio.Queue = asyncio.Queue()

        def callback(data, _user_data):
            loop.call_soon_threadsafe(queue.put_nowait, data)

        handle = self._plugin.subscribe_storage_information(callback)
        self._subscription_handles[id(queue)] = handle
        try:
            while True:
                yield await queue.get()
        finally:
            if id(queue) in self._subscription_handles:
                self._subscription_handles.pop(id(queue))
                self._plugin.unsubscribe_storage_information(handle)

    async def respond_storage_information(
        self, storage_information_feedback, storage_information
    ):
        """
        Respond to camera storage information from SubscribeStorageInformation.

        Parameters
        ----------
        storage_information_feedback : CameraFeedback
        storage_information : StorageInformation
        Raises
        ------
        CameraServerError
            If the request fails. The error contains the reason for the failure.
        """
        loop = asyncio.get_running_loop()
        return await loop.run_in_executor(
            None,
            lambda: self._plugin.respond_storage_information(
                storage_information_feedback, storage_information
            ),
        )

    async def subscribe_capture_status(self) -> AsyncGenerator[int, None]:
        """
        Subscribe to camera capture status requests. Each request received should response to using RespondCaptureStatus

        Yields
        ------
         : int
             The next update
        """
        loop = asyncio.get_running_loop()
        queue: asyncio.Queue = asyncio.Queue()

        def callback(data, _user_data):
            loop.call_soon_threadsafe(queue.put_nowait, data)

        handle = self._plugin.subscribe_capture_status(callback)
        self._subscription_handles[id(queue)] = handle
        try:
            while True:
                yield await queue.get()
        finally:
            if id(queue) in self._subscription_handles:
                self._subscription_handles.pop(id(queue))
                self._plugin.unsubscribe_capture_status(handle)

    async def respond_capture_status(self, capture_status_feedback, capture_status):
        """
        Respond to camera capture status from SubscribeCaptureStatus.

        Parameters
        ----------
        capture_status_feedback : CameraFeedback
        capture_status : CaptureStatus
        Raises
        ------
        CameraServerError
            If the request fails. The error contains the reason for the failure.
        """
        loop = asyncio.get_running_loop()
        return await loop.run_in_executor(
            None,
            lambda: self._plugin.respond_capture_status(
                capture_status_feedback, capture_status
            ),
        )

    async def subscribe_format_storage(self) -> AsyncGenerator[int, None]:
        """
        Subscribe to format storage requests. Each request received should response to using RespondFormatStorage

        Yields
        ------
         : int
             The next update
        """
        loop = asyncio.get_running_loop()
        queue: asyncio.Queue = asyncio.Queue()

        def callback(data, _user_data):
            loop.call_soon_threadsafe(queue.put_nowait, data)

        handle = self._plugin.subscribe_format_storage(callback)
        self._subscription_handles[id(queue)] = handle
        try:
            while True:
                yield await queue.get()
        finally:
            if id(queue) in self._subscription_handles:
                self._subscription_handles.pop(id(queue))
                self._plugin.unsubscribe_format_storage(handle)

    async def respond_format_storage(self, format_storage_feedback):
        """
        Respond to format storage from SubscribeFormatStorage.

        Parameters
        ----------
        format_storage_feedback : CameraFeedback
        Raises
        ------
        CameraServerError
            If the request fails. The error contains the reason for the failure.
        """
        loop = asyncio.get_running_loop()
        return await loop.run_in_executor(
            None, lambda: self._plugin.respond_format_storage(format_storage_feedback)
        )

    async def subscribe_reset_settings(self) -> AsyncGenerator[int, None]:
        """
        Subscribe to reset settings requests. Each request received should response to using RespondResetSettings

        Yields
        ------
         : int
             The next update
        """
        loop = asyncio.get_running_loop()
        queue: asyncio.Queue = asyncio.Queue()

        def callback(data, _user_data):
            loop.call_soon_threadsafe(queue.put_nowait, data)

        handle = self._plugin.subscribe_reset_settings(callback)
        self._subscription_handles[id(queue)] = handle
        try:
            while True:
                yield await queue.get()
        finally:
            if id(queue) in self._subscription_handles:
                self._subscription_handles.pop(id(queue))
                self._plugin.unsubscribe_reset_settings(handle)

    async def respond_reset_settings(self, reset_settings_feedback):
        """
        Respond to reset settings from SubscribeResetSettings.

        Parameters
        ----------
        reset_settings_feedback : CameraFeedback
        Raises
        ------
        CameraServerError
            If the request fails. The error contains the reason for the failure.
        """
        loop = asyncio.get_running_loop()
        return await loop.run_in_executor(
            None, lambda: self._plugin.respond_reset_settings(reset_settings_feedback)
        )

    async def subscribe_zoom_in_start(self) -> AsyncGenerator[int, None]:
        """
        Subscribe to zoom in start command

        Yields
        ------
         : int
             The next update
        """
        loop = asyncio.get_running_loop()
        queue: asyncio.Queue = asyncio.Queue()

        def callback(data, _user_data):
            loop.call_soon_threadsafe(queue.put_nowait, data)

        handle = self._plugin.subscribe_zoom_in_start(callback)
        self._subscription_handles[id(queue)] = handle
        try:
            while True:
                yield await queue.get()
        finally:
            if id(queue) in self._subscription_handles:
                self._subscription_handles.pop(id(queue))
                self._plugin.unsubscribe_zoom_in_start(handle)

    async def respond_zoom_in_start(self, zoom_in_start_feedback):
        """
        Respond to zoom in start.

        Parameters
        ----------
        zoom_in_start_feedback : CameraFeedback
        Raises
        ------
        CameraServerError
            If the request fails. The error contains the reason for the failure.
        """
        loop = asyncio.get_running_loop()
        return await loop.run_in_executor(
            None, lambda: self._plugin.respond_zoom_in_start(zoom_in_start_feedback)
        )

    async def subscribe_zoom_out_start(self) -> AsyncGenerator[int, None]:
        """
        Subscribe to zoom out start command

        Yields
        ------
         : int
             The next update
        """
        loop = asyncio.get_running_loop()
        queue: asyncio.Queue = asyncio.Queue()

        def callback(data, _user_data):
            loop.call_soon_threadsafe(queue.put_nowait, data)

        handle = self._plugin.subscribe_zoom_out_start(callback)
        self._subscription_handles[id(queue)] = handle
        try:
            while True:
                yield await queue.get()
        finally:
            if id(queue) in self._subscription_handles:
                self._subscription_handles.pop(id(queue))
                self._plugin.unsubscribe_zoom_out_start(handle)

    async def respond_zoom_out_start(self, zoom_out_start_feedback):
        """
        Respond to zoom out start.

        Parameters
        ----------
        zoom_out_start_feedback : CameraFeedback
        Raises
        ------
        CameraServerError
            If the request fails. The error contains the reason for the failure.
        """
        loop = asyncio.get_running_loop()
        return await loop.run_in_executor(
            None, lambda: self._plugin.respond_zoom_out_start(zoom_out_start_feedback)
        )

    async def subscribe_zoom_stop(self) -> AsyncGenerator[int, None]:
        """
        Subscribe to zoom stop command

        Yields
        ------
         : int
             The next update
        """
        loop = asyncio.get_running_loop()
        queue: asyncio.Queue = asyncio.Queue()

        def callback(data, _user_data):
            loop.call_soon_threadsafe(queue.put_nowait, data)

        handle = self._plugin.subscribe_zoom_stop(callback)
        self._subscription_handles[id(queue)] = handle
        try:
            while True:
                yield await queue.get()
        finally:
            if id(queue) in self._subscription_handles:
                self._subscription_handles.pop(id(queue))
                self._plugin.unsubscribe_zoom_stop(handle)

    async def respond_zoom_stop(self, zoom_stop_feedback):
        """
        Respond to zoom stop.

        Parameters
        ----------
        zoom_stop_feedback : CameraFeedback
        Raises
        ------
        CameraServerError
            If the request fails. The error contains the reason for the failure.
        """
        loop = asyncio.get_running_loop()
        return await loop.run_in_executor(
            None, lambda: self._plugin.respond_zoom_stop(zoom_stop_feedback)
        )

    async def subscribe_zoom_range(self) -> AsyncGenerator[float, None]:
        """
        Subscribe to zoom range command

        Yields
        ------
         : float
             The next update
        """
        loop = asyncio.get_running_loop()
        queue: asyncio.Queue = asyncio.Queue()

        def callback(data, _user_data):
            loop.call_soon_threadsafe(queue.put_nowait, data)

        handle = self._plugin.subscribe_zoom_range(callback)
        self._subscription_handles[id(queue)] = handle
        try:
            while True:
                yield await queue.get()
        finally:
            if id(queue) in self._subscription_handles:
                self._subscription_handles.pop(id(queue))
                self._plugin.unsubscribe_zoom_range(handle)

    async def respond_zoom_range(self, zoom_range_feedback):
        """
        Respond to zoom range.

        Parameters
        ----------
        zoom_range_feedback : CameraFeedback
        Raises
        ------
        CameraServerError
            If the request fails. The error contains the reason for the failure.
        """
        loop = asyncio.get_running_loop()
        return await loop.run_in_executor(
            None, lambda: self._plugin.respond_zoom_range(zoom_range_feedback)
        )

    async def set_tracking_rectangle_status(self, tracked_rectangle):
        """
        Set/update the current rectangle tracking status.

        Parameters
        ----------
        tracked_rectangle : TrackRectangle
        Raises
        ------
        CameraServerError
            If the request fails. The error contains the reason for the failure.
        """
        loop = asyncio.get_running_loop()
        return await loop.run_in_executor(
            None, lambda: self._plugin.set_tracking_rectangle_status(tracked_rectangle)
        )

    async def set_tracking_off_status(self):
        """
        Set the current tracking status to off.

        Raises
        ------
        CameraServerError
            If the request fails. The error contains the reason for the failure.
        """
        loop = asyncio.get_running_loop()
        return await loop.run_in_executor(
            None, lambda: self._plugin.set_tracking_off_status()
        )

    async def subscribe_tracking_point_command(
        self,
    ) -> AsyncGenerator[TrackPoint, None]:
        """
        Subscribe to incoming tracking point command.

        Yields
        ------
        track_point : TrackPoint
             The next update
        """
        loop = asyncio.get_running_loop()
        queue: asyncio.Queue = asyncio.Queue()

        def callback(data, _user_data):
            loop.call_soon_threadsafe(queue.put_nowait, data)

        handle = self._plugin.subscribe_tracking_point_command(callback)
        self._subscription_handles[id(queue)] = handle
        try:
            while True:
                yield await queue.get()
        finally:
            if id(queue) in self._subscription_handles:
                self._subscription_handles.pop(id(queue))
                self._plugin.unsubscribe_tracking_point_command(handle)

    async def subscribe_tracking_rectangle_command(
        self,
    ) -> AsyncGenerator[TrackRectangle, None]:
        """
        Subscribe to incoming tracking rectangle command.

        Yields
        ------
        track_rectangle : TrackRectangle
             The next update
        """
        loop = asyncio.get_running_loop()
        queue: asyncio.Queue = asyncio.Queue()

        def callback(data, _user_data):
            loop.call_soon_threadsafe(queue.put_nowait, data)

        handle = self._plugin.subscribe_tracking_rectangle_command(callback)
        self._subscription_handles[id(queue)] = handle
        try:
            while True:
                yield await queue.get()
        finally:
            if id(queue) in self._subscription_handles:
                self._subscription_handles.pop(id(queue))
                self._plugin.unsubscribe_tracking_rectangle_command(handle)

    async def subscribe_tracking_off_command(self) -> AsyncGenerator[int, None]:
        """
        Subscribe to incoming tracking off command.

        Yields
        ------
         : int
             The next update
        """
        loop = asyncio.get_running_loop()
        queue: asyncio.Queue = asyncio.Queue()

        def callback(data, _user_data):
            loop.call_soon_threadsafe(queue.put_nowait, data)

        handle = self._plugin.subscribe_tracking_off_command(callback)
        self._subscription_handles[id(queue)] = handle
        try:
            while True:
                yield await queue.get()
        finally:
            if id(queue) in self._subscription_handles:
                self._subscription_handles.pop(id(queue))
                self._plugin.unsubscribe_tracking_off_command(handle)

    async def respond_tracking_point_command(self, stop_video_feedback):
        """
        Respond to an incoming tracking point command.

        Parameters
        ----------
        stop_video_feedback : CameraFeedback
        Raises
        ------
        CameraServerError
            If the request fails. The error contains the reason for the failure.
        """
        loop = asyncio.get_running_loop()
        return await loop.run_in_executor(
            None,
            lambda: self._plugin.respond_tracking_point_command(stop_video_feedback),
        )

    async def respond_tracking_rectangle_command(self, stop_video_feedback):
        """
        Respond to an incoming tracking rectangle command.

        Parameters
        ----------
        stop_video_feedback : CameraFeedback
        Raises
        ------
        CameraServerError
            If the request fails. The error contains the reason for the failure.
        """
        loop = asyncio.get_running_loop()
        return await loop.run_in_executor(
            None,
            lambda: self._plugin.respond_tracking_rectangle_command(
                stop_video_feedback
            ),
        )

    async def respond_tracking_off_command(self, stop_video_feedback):
        """
        Respond to an incoming tracking off command.

        Parameters
        ----------
        stop_video_feedback : CameraFeedback
        Raises
        ------
        CameraServerError
            If the request fails. The error contains the reason for the failure.
        """
        loop = asyncio.get_running_loop()
        return await loop.run_in_executor(
            None, lambda: self._plugin.respond_tracking_off_command(stop_video_feedback)
        )

    def destroy(self):
        self._subscription_handles.clear()
        self._plugin.destroy()

    def __del__(self):
        self.destroy()
