# ruff: noqa: F401
# WARNING: THIS FILE IS AUTOGENERATED! As such, it should not be edited.
# Edits need to be made to the proto files
# (see https://github.com/mavlink/MAVSDK-Proto/blob/main/protos/info/info.proto)
"""
Provide information about the hardware and/or software of a system.
"""

import asyncio
from typing import AsyncGenerator
from mavsdk.plugins.info import (
    Info,
    InfoResult,
    FlightInfo,
    Identification,
    Product,
    Version,
)


class InfoError(Exception):
    """Raised when a Info operation fails."""

    def __init__(self, result, origin, *params):
        self._result = result
        self._origin = origin
        self._params = params

    def __str__(self):
        return f"{self._result}: '{self._result.name}'; origin: {self._origin}; params: {self._params}"


class InfoAsync:
    """
    Provide information about the hardware and/or software of a system.

    Async wrapper around :class:`Info` that mirrors the gRPC-based
    asyncio API while using the ctypes-based C library directly.
    """

    def __init__(self, system):
        self._subscription_handles: dict = {}
        self._plugin = Info(system._system)

    async def get_flight_information(self):
        """
        Get flight information of the system.

        Returns
        -------
        flight_info : FlightInfo
        Raises
        ------
        InfoError
            If the request fails. The error contains the reason for the failure.
        """
        loop = asyncio.get_running_loop()
        return await loop.run_in_executor(
            None, lambda: self._plugin.get_flight_information()
        )

    async def get_identification(self):
        """
        Get the identification of the system.

        Returns
        -------
        identification : Identification
        Raises
        ------
        InfoError
            If the request fails. The error contains the reason for the failure.
        """
        loop = asyncio.get_running_loop()
        return await loop.run_in_executor(
            None, lambda: self._plugin.get_identification()
        )

    async def get_product(self):
        """
        Get product information of the system.

        Returns
        -------
        product : Product
        Raises
        ------
        InfoError
            If the request fails. The error contains the reason for the failure.
        """
        loop = asyncio.get_running_loop()
        return await loop.run_in_executor(None, lambda: self._plugin.get_product())

    async def get_version(self):
        """
        Get the version information of the system.

        Returns
        -------
        version : Version
        Raises
        ------
        InfoError
            If the request fails. The error contains the reason for the failure.
        """
        loop = asyncio.get_running_loop()
        return await loop.run_in_executor(None, lambda: self._plugin.get_version())

    async def get_speed_factor(self):
        """
        Get the speed factor of a simulation (with lockstep a simulation can run faster or slower than realtime).

        Returns
        -------
        speed_factor : float
        Raises
        ------
        InfoError
            If the request fails. The error contains the reason for the failure.
        """
        loop = asyncio.get_running_loop()
        return await loop.run_in_executor(None, lambda: self._plugin.get_speed_factor())

    async def subscribe_flight_information(self) -> AsyncGenerator[FlightInfo, None]:
        """
        Subscribe to 'flight information' updates.

        Yields
        ------
        flight_info : FlightInfo
             The next update
        """
        loop = asyncio.get_running_loop()
        queue: asyncio.Queue = asyncio.Queue()

        def callback(data, _user_data):
            loop.call_soon_threadsafe(queue.put_nowait, data)

        handle = self._plugin.subscribe_flight_information(callback)
        self._subscription_handles[id(queue)] = handle
        try:
            while True:
                yield await queue.get()
        finally:
            if id(queue) in self._subscription_handles:
                self._subscription_handles.pop(id(queue))
                self._plugin.unsubscribe_flight_information(handle)

    def destroy(self):
        self._subscription_handles.clear()
        self._plugin.destroy()

    def __del__(self):
        self.destroy()
