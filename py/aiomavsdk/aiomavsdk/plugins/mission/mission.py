# ruff: noqa: F401
# WARNING: THIS FILE IS AUTOGENERATED! As such, it should not be edited.
# Edits need to be made to the proto files
# (see https://github.com/mavlink/MAVSDK-Proto/blob/main/protos/mission/mission.proto)
"""
Enable waypoint missions.
"""

import asyncio
from typing import AsyncGenerator
from mavsdk.plugins.mission import (
    Mission,
    MissionResult,
    MissionItem,
    MissionPlan,
    MissionProgress,
    ProgressData,
    ProgressDataOrMission,
)


class MissionError(Exception):
    """Raised when a Mission operation fails."""

    def __init__(self, result, origin, *params):
        self._result = result
        self._origin = origin
        self._params = params

    def __str__(self):
        return f"{self._result}: '{self._result.name}'; origin: {self._origin}; params: {self._params}"


class MissionAsync:
    """
    Enable waypoint missions.

    Async wrapper around :class:`Mission` that mirrors the gRPC-based
    asyncio API while using the ctypes-based C library directly.
    """

    def __init__(self, system):
        self._subscription_handles: dict = {}
        self._plugin = Mission(system._system)

    async def upload_mission(self, mission_plan):
        """
               Upload a list of mission items to the system.

        The mission items are uploaded to a drone. Once uploaded the mission can be started and
        executed even if the connection is lost.

               Parameters
               ----------
               mission_plan : MissionPlan
               Raises
               ------
               MissionError
                   If the request fails. The error contains the reason for the failure.
        """
        loop = asyncio.get_running_loop()
        return await loop.run_in_executor(
            None, lambda: self._plugin.upload_mission(mission_plan)
        )

    async def upload_mission_with_progress(self, mission_plan) -> AsyncGenerator:
        """
               Upload a list of mission items to the system and report upload progress.

        The mission items are uploaded to a drone. Once uploaded the mission can be started and
        executed even if the connection is lost.
        """
        loop = asyncio.get_running_loop()
        queue: asyncio.Queue = asyncio.Queue()

        def callback(result, data, _user_data=None):
            loop.call_soon_threadsafe(queue.put_nowait, (result, data))

        self._plugin.upload_mission_with_progress_async(callback)
        while True:
            result, data = await queue.get()
            yield result, data
            if result != MissionResult.NEXT:
                break

    async def cancel_mission_upload(self):
        """
        Cancel an ongoing mission upload.

        Raises
        ------
        MissionError
            If the request fails. The error contains the reason for the failure.
        """
        loop = asyncio.get_running_loop()
        return await loop.run_in_executor(
            None, lambda: self._plugin.cancel_mission_upload()
        )

    async def download_mission(self):
        """
               Download a list of mission items from the system (asynchronous).

        Will fail if any of the downloaded mission items are not supported
        by the MAVSDK API.

               Returns
               -------
               mission_plan : MissionPlan
               Raises
               ------
               MissionError
                   If the request fails. The error contains the reason for the failure.
        """
        loop = asyncio.get_running_loop()
        return await loop.run_in_executor(None, lambda: self._plugin.download_mission())

    async def download_mission_with_progress(self) -> AsyncGenerator:
        """
               Download a list of mission items from the system (asynchronous) and report progress.

        Will fail if any of the downloaded mission items are not supported
        by the MAVSDK API.
        """
        loop = asyncio.get_running_loop()
        queue: asyncio.Queue = asyncio.Queue()

        def callback(result, data, _user_data=None):
            loop.call_soon_threadsafe(queue.put_nowait, (result, data))

        self._plugin.download_mission_with_progress_async(callback)
        while True:
            result, data = await queue.get()
            yield result, data
            if result != MissionResult.NEXT:
                break

    async def cancel_mission_download(self):
        """
        Cancel an ongoing mission download.

        Raises
        ------
        MissionError
            If the request fails. The error contains the reason for the failure.
        """
        loop = asyncio.get_running_loop()
        return await loop.run_in_executor(
            None, lambda: self._plugin.cancel_mission_download()
        )

    async def start_mission(self):
        """
               Start the mission.

        A mission must be uploaded to the vehicle before this can be called.

               Raises
               ------
               MissionError
                   If the request fails. The error contains the reason for the failure.
        """
        loop = asyncio.get_running_loop()
        return await loop.run_in_executor(None, lambda: self._plugin.start_mission())

    async def pause_mission(self):
        """
               Pause the mission.

        Pausing the mission puts the vehicle into
        [HOLD mode](https://docs.px4.io/en/flight_modes/hold.html).
        A multicopter should just hover at the spot while a fixedwing vehicle should loiter
        around the location where it paused.

               Raises
               ------
               MissionError
                   If the request fails. The error contains the reason for the failure.
        """
        loop = asyncio.get_running_loop()
        return await loop.run_in_executor(None, lambda: self._plugin.pause_mission())

    async def clear_mission(self):
        """
        Clear the mission saved on the vehicle.

        Raises
        ------
        MissionError
            If the request fails. The error contains the reason for the failure.
        """
        loop = asyncio.get_running_loop()
        return await loop.run_in_executor(None, lambda: self._plugin.clear_mission())

    async def set_current_mission_item(self, index):
        """
               Sets the mission item index to go to.

        By setting the current index to 0, the mission is restarted from the beginning. If it is set
        to a specific index of a mission item, the mission will be set to this item.

        Note that this is not necessarily true for general missions using MAVLink if loop counters
        are used.

               Parameters
               ----------
               index : int
               Raises
               ------
               MissionError
                   If the request fails. The error contains the reason for the failure.
        """
        loop = asyncio.get_running_loop()
        return await loop.run_in_executor(
            None, lambda: self._plugin.set_current_mission_item(index)
        )

    async def is_mission_finished(self):
        """
        Check if the mission has been finished.

        Returns
        -------
        is_finished : bool
        Raises
        ------
        MissionError
            If the request fails. The error contains the reason for the failure.
        """
        loop = asyncio.get_running_loop()
        return await loop.run_in_executor(
            None, lambda: self._plugin.is_mission_finished()
        )

    async def subscribe_mission_progress(self) -> AsyncGenerator[MissionProgress, None]:
        """
        Subscribe to mission progress updates.

        Yields
        ------
        mission_progress : MissionProgress
             The next update
        """
        loop = asyncio.get_running_loop()
        queue: asyncio.Queue = asyncio.Queue()

        def callback(data, _user_data):
            loop.call_soon_threadsafe(queue.put_nowait, data)

        handle = self._plugin.subscribe_mission_progress(callback)
        self._subscription_handles[id(queue)] = handle
        try:
            while True:
                yield await queue.get()
        finally:
            if id(queue) in self._subscription_handles:
                self._subscription_handles.pop(id(queue))
                self._plugin.unsubscribe_mission_progress(handle)

    async def mission_progress(self):
        """
        Subscribe to mission progress updates.

        Returns
        -------
        mission_progress : MissionProgress
        Raises
        ------
        MissionError
            If the request fails. The error contains the reason for the failure.
        """
        loop = asyncio.get_running_loop()
        return await loop.run_in_executor(None, lambda: self._plugin.mission_progress())

    async def get_return_to_launch_after_mission(self):
        """
               Get whether to trigger Return-to-Launch (RTL) after mission is complete.

        Before getting this option, it needs to be set, or a mission
        needs to be downloaded.

               Returns
               -------
               enable : bool
               Raises
               ------
               MissionError
                   If the request fails. The error contains the reason for the failure.
        """
        loop = asyncio.get_running_loop()
        return await loop.run_in_executor(
            None, lambda: self._plugin.get_return_to_launch_after_mission()
        )

    async def set_return_to_launch_after_mission(self, enable):
        """
               Set whether to trigger Return-to-Launch (RTL) after the mission is complete.

        This will only take effect for the next mission upload, meaning that
        the mission may have to be uploaded again.

               Parameters
               ----------
               enable : bool
               Raises
               ------
               MissionError
                   If the request fails. The error contains the reason for the failure.
        """
        loop = asyncio.get_running_loop()
        return await loop.run_in_executor(
            None, lambda: self._plugin.set_return_to_launch_after_mission(enable)
        )

    def destroy(self):
        self._subscription_handles.clear()
        self._plugin.destroy()

    def __del__(self):
        self.destroy()
