# ruff: noqa: F401

# WARNING: THIS FILE IS AUTOGENERATED! As such, it should not be edited.
# Edits need to be made to the proto files
# (see https://github.com/mavlink/MAVSDK-Proto/blob/main/protos/manual_control/manual_control.proto)

"""
Enable manual control using e.g. a joystick or gamepad.
"""

import atexit
import ctypes

from typing import Callable, Any
from enum import IntEnum

from ...cmavsdk_loader import _cmavsdk_lib


# ===== Enums =====


# ===== Result Enums =====
class ManualControlResult(IntEnum):
    """Possible results returned for manual control requests."""

    UNKNOWN = 0
    SUCCESS = 1
    NO_SYSTEM = 2
    CONNECTION_ERROR = 3
    BUSY = 4
    COMMAND_DENIED = 5
    TIMEOUT = 6
    INPUT_OUT_OF_RANGE = 7
    INPUT_NOT_SET = 8


# ===== Internal C Structures =====

# ===== Structures =====


# ===== Plugin =====
class ManualControl:
    """Enable manual control using e.g. a joystick or gamepad."""

    def __init__(self, system):
        self._lib = _cmavsdk_lib
        self._handle = None
        self._callbacks = []  # Keep references to prevent GC

        if system is None:
            raise ValueError("system cannot be None")

        system_handle = system._handle

        if not system_handle:
            raise ValueError("system handle is null")

        self._handle = self._lib.mavsdk_manual_control_create(system_handle)

        if not self._handle:
            raise RuntimeError(
                "Failed to create ManualControl plugin - C function returned null handle"
            )

        atexit.register(self.destroy)

    def start_position_control_async(self, callback: Callable, user_data: Any = None):
        """Start position control using e.g. joystick input.

        Requires manual control input to be sent regularly already.
        Requires a valid position using e.g. GPS, external vision, or optical flow."""

        def c_callback(result, ud):
            try:
                py_result = ManualControlResult(result)

                callback(py_result, user_data)

            except Exception as e:
                print(f"Error in start_position_control callback: {e}")

        cb = StartPositionControlCallback(c_callback)
        self._callbacks.append(cb)

        self._lib.mavsdk_manual_control_start_position_control_async(
            self._handle, cb, None
        )

    def start_position_control(self):
        """Get start_position_control (blocking)"""

        result_code = self._lib.mavsdk_manual_control_start_position_control(
            self._handle,
        )
        result = ManualControlResult(result_code)
        if result != ManualControlResult.SUCCESS:
            raise Exception(f"start_position_control failed: {result}")

        return result

    def start_altitude_control_async(self, callback: Callable, user_data: Any = None):
        """Start altitude control

        Requires manual control input to be sent regularly already.
        Does not require a  valid position e.g. GPS."""

        def c_callback(result, ud):
            try:
                py_result = ManualControlResult(result)

                callback(py_result, user_data)

            except Exception as e:
                print(f"Error in start_altitude_control callback: {e}")

        cb = StartAltitudeControlCallback(c_callback)
        self._callbacks.append(cb)

        self._lib.mavsdk_manual_control_start_altitude_control_async(
            self._handle, cb, None
        )

    def start_altitude_control(self):
        """Get start_altitude_control (blocking)"""

        result_code = self._lib.mavsdk_manual_control_start_altitude_control(
            self._handle,
        )
        result = ManualControlResult(result_code)
        if result != ManualControlResult.SUCCESS:
            raise Exception(f"start_altitude_control failed: {result}")

        return result

    def set_manual_control_input(self, x, y, z, r):
        """Get set_manual_control_input (blocking)"""

        result_code = self._lib.mavsdk_manual_control_set_manual_control_input(
            self._handle,
            x,
            y,
            z,
            r,
        )
        result = ManualControlResult(result_code)
        if result != ManualControlResult.SUCCESS:
            raise Exception(f"set_manual_control_input failed: {result}")

        return result

    def destroy(self):
        """Destroy the plugin instance"""
        if self._handle:
            self._lib.mavsdk_manual_control_destroy(self._handle)
            self._handle = None

    def __del__(self):
        self.destroy()


# ===== Callback Types =====
StartPositionControlCallback = ctypes.CFUNCTYPE(None, ctypes.c_int, ctypes.c_void_p)
StartAltitudeControlCallback = ctypes.CFUNCTYPE(None, ctypes.c_int, ctypes.c_void_p)

# ===== Setup Functions =====
_cmavsdk_lib.mavsdk_manual_control_create.argtypes = [ctypes.c_void_p]
_cmavsdk_lib.mavsdk_manual_control_create.restype = ctypes.c_void_p

_cmavsdk_lib.mavsdk_manual_control_destroy.argtypes = [ctypes.c_void_p]
_cmavsdk_lib.mavsdk_manual_control_destroy.restype = None


_cmavsdk_lib.mavsdk_manual_control_start_position_control_async.argtypes = [
    ctypes.c_void_p,
    StartPositionControlCallback,
    ctypes.c_void_p,
]

_cmavsdk_lib.mavsdk_manual_control_start_position_control_async.restype = None

_cmavsdk_lib.mavsdk_manual_control_start_position_control.argtypes = [
    ctypes.c_void_p,
]

_cmavsdk_lib.mavsdk_manual_control_start_position_control.restype = ctypes.c_int
_cmavsdk_lib.mavsdk_manual_control_start_altitude_control_async.argtypes = [
    ctypes.c_void_p,
    StartAltitudeControlCallback,
    ctypes.c_void_p,
]

_cmavsdk_lib.mavsdk_manual_control_start_altitude_control_async.restype = None

_cmavsdk_lib.mavsdk_manual_control_start_altitude_control.argtypes = [
    ctypes.c_void_p,
]

_cmavsdk_lib.mavsdk_manual_control_start_altitude_control.restype = ctypes.c_int

_cmavsdk_lib.mavsdk_manual_control_set_manual_control_input.argtypes = [
    ctypes.c_void_p,
    ctypes.c_float,
    ctypes.c_float,
    ctypes.c_float,
    ctypes.c_float,
]

_cmavsdk_lib.mavsdk_manual_control_set_manual_control_input.restype = ctypes.c_int
