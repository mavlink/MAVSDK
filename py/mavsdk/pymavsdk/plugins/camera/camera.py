# ruff: noqa: F401

# WARNING: THIS FILE IS AUTOGENERATED! As such, it should not be edited.
# Edits need to be made to the proto files
# (see https://github.com/mavlink/MAVSDK-Proto/blob/main/protos/camera/camera.proto)

"""
Can be used to manage cameras that implement the MAVLink
 Camera Protocol: https://mavlink.io/en/services/camera.html.

 Currently only a single camera is supported.
 When multiple cameras are supported the plugin will need to be
 instantiated separately for every camera and the camera selected using
 `select_camera`.
"""

import ctypes

from typing import Callable, Any
from enum import IntEnum

from ...cmavsdk_loader import _cmavsdk_lib


# ===== Enums =====
class Mode(IntEnum):
    """Camera mode type."""

    UNKNOWN = 0
    PHOTO = 1
    VIDEO = 2


class PhotosRange(IntEnum):
    """Photos range type."""

    ALL = 0
    SINCE_CONNECTION = 1


# ===== Result Enums =====
class CameraResult(IntEnum):
    """Possible results returned for camera commands"""

    UNKNOWN = 0
    SUCCESS = 1
    IN_PROGRESS = 2
    BUSY = 3
    DENIED = 4
    ERROR = 5
    TIMEOUT = 6
    WRONG_ARGUMENT = 7
    NO_SYSTEM = 8
    PROTOCOL_UNSUPPORTED = 9
    UNAVAILABLE = 10
    CAMERA_ID_INVALID = 11
    ACTION_UNSUPPORTED = 12


# ===== Internal C Structures =====
class OptionCStruct(ctypes.Structure):
    """
    Internal C structure for Option.
    Used only for C library communication.
    """

    _fields_ = [
        ("option_id", ctypes.c_char_p),
        ("option_description", ctypes.c_char_p),
    ]


class SettingCStruct(ctypes.Structure):
    """
    Internal C structure for Setting.
    Used only for C library communication.
    """

    _fields_ = [
        ("setting_id", ctypes.c_char_p),
        ("setting_description", ctypes.c_char_p),
        ("option", OptionCStruct),
        ("is_range", ctypes.c_bool),
    ]


class SettingOptionsCStruct(ctypes.Structure):
    """
    Internal C structure for SettingOptions.
    Used only for C library communication.
    """

    _fields_ = [
        ("component_id", ctypes.c_int32),
        ("setting_id", ctypes.c_char_p),
        ("setting_description", ctypes.c_char_p),
        ("options", ctypes.POINTER(OptionCStruct)),
        ("options_size", ctypes.c_size_t),
        ("is_range", ctypes.c_bool),
    ]


class VideoStreamSettingsCStruct(ctypes.Structure):
    """
    Internal C structure for VideoStreamSettings.
    Used only for C library communication.
    """

    _fields_ = [
        ("frame_rate_hz", ctypes.c_float),
        ("horizontal_resolution_pix", ctypes.c_uint32),
        ("vertical_resolution_pix", ctypes.c_uint32),
        ("bit_rate_b_s", ctypes.c_uint32),
        ("rotation_deg", ctypes.c_uint32),
        ("uri", ctypes.c_char_p),
        ("horizontal_fov_deg", ctypes.c_float),
    ]


class VideoStreamInfoCStruct(ctypes.Structure):
    """
    Internal C structure for VideoStreamInfo.
    Used only for C library communication.
    """

    _fields_ = [
        ("stream_id", ctypes.c_int32),
        ("settings", VideoStreamSettingsCStruct),
        ("status", ctypes.c_int),
        ("spectrum", ctypes.c_int),
    ]


class ModeUpdateCStruct(ctypes.Structure):
    """
    Internal C structure for ModeUpdate.
    Used only for C library communication.
    """

    _fields_ = [
        ("component_id", ctypes.c_int32),
        ("mode", ctypes.c_int),
    ]


class VideoStreamUpdateCStruct(ctypes.Structure):
    """
    Internal C structure for VideoStreamUpdate.
    Used only for C library communication.
    """

    _fields_ = [
        ("component_id", ctypes.c_int32),
        ("video_stream_info", VideoStreamInfoCStruct),
    ]


class StorageCStruct(ctypes.Structure):
    """
    Internal C structure for Storage.
    Used only for C library communication.
    """

    _fields_ = [
        ("component_id", ctypes.c_int32),
        ("video_on", ctypes.c_bool),
        ("photo_interval_on", ctypes.c_bool),
        ("used_storage_mib", ctypes.c_float),
        ("available_storage_mib", ctypes.c_float),
        ("total_storage_mib", ctypes.c_float),
        ("recording_time_s", ctypes.c_float),
        ("media_folder_name", ctypes.c_char_p),
        ("storage_status", ctypes.c_int),
        ("storage_id", ctypes.c_uint32),
        ("storage_type", ctypes.c_int),
    ]


class StorageUpdateCStruct(ctypes.Structure):
    """
    Internal C structure for StorageUpdate.
    Used only for C library communication.
    """

    _fields_ = [
        ("component_id", ctypes.c_int32),
        ("storage", StorageCStruct),
    ]


class CurrentSettingsUpdateCStruct(ctypes.Structure):
    """
    Internal C structure for CurrentSettingsUpdate.
    Used only for C library communication.
    """

    _fields_ = [
        ("component_id", ctypes.c_int32),
        ("current_settings", ctypes.POINTER(SettingCStruct)),
        ("current_settings_size", ctypes.c_size_t),
    ]


class PossibleSettingOptionsUpdateCStruct(ctypes.Structure):
    """
    Internal C structure for PossibleSettingOptionsUpdate.
    Used only for C library communication.
    """

    _fields_ = [
        ("component_id", ctypes.c_int32),
        ("setting_options", ctypes.POINTER(SettingOptionsCStruct)),
        ("setting_options_size", ctypes.c_size_t),
    ]


class PositionCStruct(ctypes.Structure):
    """
    Internal C structure for Position.
    Used only for C library communication.
    """

    _fields_ = [
        ("latitude_deg", ctypes.c_double),
        ("longitude_deg", ctypes.c_double),
        ("absolute_altitude_m", ctypes.c_float),
        ("relative_altitude_m", ctypes.c_float),
    ]


class QuaternionCStruct(ctypes.Structure):
    """
    Internal C structure for Quaternion.
    Used only for C library communication.
    """

    _fields_ = [
        ("w", ctypes.c_float),
        ("x", ctypes.c_float),
        ("y", ctypes.c_float),
        ("z", ctypes.c_float),
    ]


class EulerAngleCStruct(ctypes.Structure):
    """
    Internal C structure for EulerAngle.
    Used only for C library communication.
    """

    _fields_ = [
        ("roll_deg", ctypes.c_float),
        ("pitch_deg", ctypes.c_float),
        ("yaw_deg", ctypes.c_float),
    ]


class CaptureInfoCStruct(ctypes.Structure):
    """
    Internal C structure for CaptureInfo.
    Used only for C library communication.
    """

    _fields_ = [
        ("component_id", ctypes.c_int32),
        ("position", PositionCStruct),
        ("attitude_quaternion", QuaternionCStruct),
        ("attitude_euler_angle", EulerAngleCStruct),
        ("time_utc_us", ctypes.c_uint64),
        ("is_success", ctypes.c_bool),
        ("index", ctypes.c_int32),
        ("file_url", ctypes.c_char_p),
    ]


class InformationCStruct(ctypes.Structure):
    """
    Internal C structure for Information.
    Used only for C library communication.
    """

    _fields_ = [
        ("component_id", ctypes.c_int32),
        ("vendor_name", ctypes.c_char_p),
        ("model_name", ctypes.c_char_p),
        ("focal_length_mm", ctypes.c_float),
        ("horizontal_sensor_size_mm", ctypes.c_float),
        ("vertical_sensor_size_mm", ctypes.c_float),
        ("horizontal_resolution_px", ctypes.c_uint32),
        ("vertical_resolution_px", ctypes.c_uint32),
    ]


class CameraListCStruct(ctypes.Structure):
    """
    Internal C structure for CameraList.
    Used only for C library communication.
    """

    _fields_ = [
        ("cameras", ctypes.POINTER(InformationCStruct)),
        ("cameras_size", ctypes.c_size_t),
    ]


# ===== Structures =====
class Option:
    """
    Type to represent a setting option.
    """

    def __init__(self, option_id=None, option_description=None):
        self.option_id = option_id
        self.option_description = option_description

    @classmethod
    def from_c_struct(cls, c_struct):
        """Convert from C structure to Python object"""
        instance = cls()
        instance.option_id = c_struct.option_id.decode("utf-8")
        instance.option_description = c_struct.option_description.decode("utf-8")
        return instance

    def to_c_struct(self):
        """Convert to C structure for C library calls"""
        c_struct = OptionCStruct()
        c_struct.option_id = self.option_id.encode("utf-8")
        c_struct.option_description = self.option_description.encode("utf-8")
        return c_struct

    def __str__(self):
        fields = []
        fields.append(f"option_id={self.option_id}")
        fields.append(f"option_description={self.option_description}")
        return f"Option({', '.join(fields)})"


class Setting:
    """
    Type to represent a setting with a selected option.
    """

    def __init__(
        self, setting_id=None, setting_description=None, option=None, is_range=None
    ):
        self.setting_id = setting_id
        self.setting_description = setting_description
        self.option = option
        self.is_range = is_range

    @classmethod
    def from_c_struct(cls, c_struct):
        """Convert from C structure to Python object"""
        instance = cls()
        instance.setting_id = c_struct.setting_id.decode("utf-8")
        instance.setting_description = c_struct.setting_description.decode("utf-8")
        instance.option = Option.from_c_struct(c_struct.option)
        instance.is_range = c_struct.is_range
        return instance

    def to_c_struct(self):
        """Convert to C structure for C library calls"""
        c_struct = SettingCStruct()
        c_struct.setting_id = self.setting_id.encode("utf-8")
        c_struct.setting_description = self.setting_description.encode("utf-8")
        c_struct.option = self.option.to_c_struct()
        c_struct.is_range = self.is_range
        return c_struct

    def __str__(self):
        fields = []
        fields.append(f"setting_id={self.setting_id}")
        fields.append(f"setting_description={self.setting_description}")
        fields.append(f"option={self.option}")
        fields.append(f"is_range={self.is_range}")
        return f"Setting({', '.join(fields)})"


class SettingOptions:
    """
    Type to represent a setting with a list of options to choose from.
    """

    def __init__(
        self,
        component_id=None,
        setting_id=None,
        setting_description=None,
        options=None,
        is_range=None,
    ):
        self.component_id = component_id
        self.setting_id = setting_id
        self.setting_description = setting_description
        self.options = options or []
        self.is_range = is_range

    @classmethod
    def from_c_struct(cls, c_struct):
        """Convert from C structure to Python object"""
        instance = cls()
        instance.component_id = c_struct.component_id
        instance.setting_id = c_struct.setting_id.decode("utf-8")
        instance.setting_description = c_struct.setting_description.decode("utf-8")
        if c_struct.options_size > 0:
            instance.options = [
                Option.from_c_struct(c_struct.options[i])
                for i in range(c_struct.options_size)
            ]
        else:
            instance.options = []
        instance.is_range = c_struct.is_range
        return instance

    def to_c_struct(self):
        """Convert to C structure for C library calls"""
        c_struct = SettingOptionsCStruct()
        c_struct.component_id = self.component_id
        c_struct.setting_id = self.setting_id.encode("utf-8")
        c_struct.setting_description = self.setting_description.encode("utf-8")
        array_type = OptionCStruct * len(self.options)
        c_array = array_type()
        for i, item in enumerate(self.options):
            c_array[i] = item.to_c_struct()
        c_struct.options = ctypes.cast(c_array, ctypes.POINTER(OptionCStruct))
        c_struct.options_size = len(self.options)
        c_struct.is_range = self.is_range
        return c_struct

    def __str__(self):
        fields = []
        fields.append(f"component_id={self.component_id}")
        fields.append(f"setting_id={self.setting_id}")
        fields.append(f"setting_description={self.setting_description}")
        fields.append(f"options={self.options}")
        fields.append(f"is_range={self.is_range}")
        return f"SettingOptions({', '.join(fields)})"


class VideoStreamSettings:
    """
    Type for video stream settings.
    """

    def __init__(
        self,
        frame_rate_hz=None,
        horizontal_resolution_pix=None,
        vertical_resolution_pix=None,
        bit_rate_b_s=None,
        rotation_deg=None,
        uri=None,
        horizontal_fov_deg=None,
    ):
        self.frame_rate_hz = frame_rate_hz
        self.horizontal_resolution_pix = horizontal_resolution_pix
        self.vertical_resolution_pix = vertical_resolution_pix
        self.bit_rate_b_s = bit_rate_b_s
        self.rotation_deg = rotation_deg
        self.uri = uri
        self.horizontal_fov_deg = horizontal_fov_deg

    @classmethod
    def from_c_struct(cls, c_struct):
        """Convert from C structure to Python object"""
        instance = cls()
        instance.frame_rate_hz = c_struct.frame_rate_hz
        instance.horizontal_resolution_pix = c_struct.horizontal_resolution_pix
        instance.vertical_resolution_pix = c_struct.vertical_resolution_pix
        instance.bit_rate_b_s = c_struct.bit_rate_b_s
        instance.rotation_deg = c_struct.rotation_deg
        instance.uri = c_struct.uri.decode("utf-8")
        instance.horizontal_fov_deg = c_struct.horizontal_fov_deg
        return instance

    def to_c_struct(self):
        """Convert to C structure for C library calls"""
        c_struct = VideoStreamSettingsCStruct()
        c_struct.frame_rate_hz = self.frame_rate_hz
        c_struct.horizontal_resolution_pix = self.horizontal_resolution_pix
        c_struct.vertical_resolution_pix = self.vertical_resolution_pix
        c_struct.bit_rate_b_s = self.bit_rate_b_s
        c_struct.rotation_deg = self.rotation_deg
        c_struct.uri = self.uri.encode("utf-8")
        c_struct.horizontal_fov_deg = self.horizontal_fov_deg
        return c_struct

    def __str__(self):
        fields = []
        fields.append(f"frame_rate_hz={self.frame_rate_hz}")
        fields.append(f"horizontal_resolution_pix={self.horizontal_resolution_pix}")
        fields.append(f"vertical_resolution_pix={self.vertical_resolution_pix}")
        fields.append(f"bit_rate_b_s={self.bit_rate_b_s}")
        fields.append(f"rotation_deg={self.rotation_deg}")
        fields.append(f"uri={self.uri}")
        fields.append(f"horizontal_fov_deg={self.horizontal_fov_deg}")
        return f"VideoStreamSettings({', '.join(fields)})"


class VideoStreamInfo:
    """
    Information about the video stream.
    """

    class VideoStreamStatus(IntEnum):
        """Video stream status type."""

        NOT_RUNNING = 0
        IN_PROGRESS = 1

    class VideoStreamSpectrum(IntEnum):
        """Video stream light spectrum type"""

        UNKNOWN = 0
        VISIBLE_LIGHT = 1
        INFRARED = 2

    def __init__(self, stream_id=None, settings=None, status=None, spectrum=None):
        self.stream_id = stream_id
        self.settings = settings
        self.status = status
        self.spectrum = spectrum

    @classmethod
    def from_c_struct(cls, c_struct):
        """Convert from C structure to Python object"""
        instance = cls()
        instance.stream_id = c_struct.stream_id
        instance.settings = VideoStreamSettings.from_c_struct(c_struct.settings)
        instance.status = VideoStreamInfo.VideoStreamStatus(c_struct.status)
        instance.spectrum = VideoStreamInfo.VideoStreamSpectrum(c_struct.spectrum)
        return instance

    def to_c_struct(self):
        """Convert to C structure for C library calls"""
        c_struct = VideoStreamInfoCStruct()
        c_struct.stream_id = self.stream_id
        c_struct.settings = self.settings.to_c_struct()
        c_struct.status = int(self.status)
        c_struct.spectrum = int(self.spectrum)
        return c_struct

    def __str__(self):
        fields = []
        fields.append(f"stream_id={self.stream_id}")
        fields.append(f"settings={self.settings}")
        fields.append(f"status={self.status}")
        fields.append(f"spectrum={self.spectrum}")
        return f"VideoStreamInfo({', '.join(fields)})"


class ModeUpdate:
    """
    An update about the current mode
    """

    def __init__(self, component_id=None, mode=None):
        self.component_id = component_id
        self.mode = mode

    @classmethod
    def from_c_struct(cls, c_struct):
        """Convert from C structure to Python object"""
        instance = cls()
        instance.component_id = c_struct.component_id
        instance.mode = Mode(c_struct.mode)
        return instance

    def to_c_struct(self):
        """Convert to C structure for C library calls"""
        c_struct = ModeUpdateCStruct()
        c_struct.component_id = self.component_id
        c_struct.mode = int(self.mode)
        return c_struct

    def __str__(self):
        fields = []
        fields.append(f"component_id={self.component_id}")
        fields.append(f"mode={self.mode}")
        return f"ModeUpdate({', '.join(fields)})"


class VideoStreamUpdate:
    """
    An update about a video stream
    """

    def __init__(self, component_id=None, video_stream_info=None):
        self.component_id = component_id
        self.video_stream_info = video_stream_info

    @classmethod
    def from_c_struct(cls, c_struct):
        """Convert from C structure to Python object"""
        instance = cls()
        instance.component_id = c_struct.component_id
        instance.video_stream_info = VideoStreamInfo.from_c_struct(
            c_struct.video_stream_info
        )
        return instance

    def to_c_struct(self):
        """Convert to C structure for C library calls"""
        c_struct = VideoStreamUpdateCStruct()
        c_struct.component_id = self.component_id
        c_struct.video_stream_info = self.video_stream_info.to_c_struct()
        return c_struct

    def __str__(self):
        fields = []
        fields.append(f"component_id={self.component_id}")
        fields.append(f"video_stream_info={self.video_stream_info}")
        return f"VideoStreamUpdate({', '.join(fields)})"


class Storage:
    """
    Information about the camera's storage status.
    """

    class StorageStatus(IntEnum):
        """Storage status type."""

        NOT_AVAILABLE = 0
        UNFORMATTED = 1
        FORMATTED = 2
        NOT_SUPPORTED = 3

    class StorageType(IntEnum):
        """Storage type."""

        UNKNOWN = 0
        USB_STICK = 1
        SD = 2
        MICROSD = 3
        HD = 4
        OTHER = 5

    def __init__(
        self,
        component_id=None,
        video_on=None,
        photo_interval_on=None,
        used_storage_mib=None,
        available_storage_mib=None,
        total_storage_mib=None,
        recording_time_s=None,
        media_folder_name=None,
        storage_status=None,
        storage_id=None,
        storage_type=None,
    ):
        self.component_id = component_id
        self.video_on = video_on
        self.photo_interval_on = photo_interval_on
        self.used_storage_mib = used_storage_mib
        self.available_storage_mib = available_storage_mib
        self.total_storage_mib = total_storage_mib
        self.recording_time_s = recording_time_s
        self.media_folder_name = media_folder_name
        self.storage_status = storage_status
        self.storage_id = storage_id
        self.storage_type = storage_type

    @classmethod
    def from_c_struct(cls, c_struct):
        """Convert from C structure to Python object"""
        instance = cls()
        instance.component_id = c_struct.component_id
        instance.video_on = c_struct.video_on
        instance.photo_interval_on = c_struct.photo_interval_on
        instance.used_storage_mib = c_struct.used_storage_mib
        instance.available_storage_mib = c_struct.available_storage_mib
        instance.total_storage_mib = c_struct.total_storage_mib
        instance.recording_time_s = c_struct.recording_time_s
        instance.media_folder_name = c_struct.media_folder_name.decode("utf-8")
        instance.storage_status = Storage.StorageStatus(c_struct.storage_status)
        instance.storage_id = c_struct.storage_id
        instance.storage_type = Storage.StorageType(c_struct.storage_type)
        return instance

    def to_c_struct(self):
        """Convert to C structure for C library calls"""
        c_struct = StorageCStruct()
        c_struct.component_id = self.component_id
        c_struct.video_on = self.video_on
        c_struct.photo_interval_on = self.photo_interval_on
        c_struct.used_storage_mib = self.used_storage_mib
        c_struct.available_storage_mib = self.available_storage_mib
        c_struct.total_storage_mib = self.total_storage_mib
        c_struct.recording_time_s = self.recording_time_s
        c_struct.media_folder_name = self.media_folder_name.encode("utf-8")
        c_struct.storage_status = int(self.storage_status)
        c_struct.storage_id = self.storage_id
        c_struct.storage_type = int(self.storage_type)
        return c_struct

    def __str__(self):
        fields = []
        fields.append(f"component_id={self.component_id}")
        fields.append(f"video_on={self.video_on}")
        fields.append(f"photo_interval_on={self.photo_interval_on}")
        fields.append(f"used_storage_mib={self.used_storage_mib}")
        fields.append(f"available_storage_mib={self.available_storage_mib}")
        fields.append(f"total_storage_mib={self.total_storage_mib}")
        fields.append(f"recording_time_s={self.recording_time_s}")
        fields.append(f"media_folder_name={self.media_folder_name}")
        fields.append(f"storage_status={self.storage_status}")
        fields.append(f"storage_id={self.storage_id}")
        fields.append(f"storage_type={self.storage_type}")
        return f"Storage({', '.join(fields)})"


class StorageUpdate:
    """
    An update about storage
    """

    def __init__(self, component_id=None, storage=None):
        self.component_id = component_id
        self.storage = storage

    @classmethod
    def from_c_struct(cls, c_struct):
        """Convert from C structure to Python object"""
        instance = cls()
        instance.component_id = c_struct.component_id
        instance.storage = Storage.from_c_struct(c_struct.storage)
        return instance

    def to_c_struct(self):
        """Convert to C structure for C library calls"""
        c_struct = StorageUpdateCStruct()
        c_struct.component_id = self.component_id
        c_struct.storage = self.storage.to_c_struct()
        return c_struct

    def __str__(self):
        fields = []
        fields.append(f"component_id={self.component_id}")
        fields.append(f"storage={self.storage}")
        return f"StorageUpdate({', '.join(fields)})"


class CurrentSettingsUpdate:
    """
    An update about a current setting
    """

    def __init__(self, component_id=None, current_settings=None):
        self.component_id = component_id
        self.current_settings = current_settings or []

    @classmethod
    def from_c_struct(cls, c_struct):
        """Convert from C structure to Python object"""
        instance = cls()
        instance.component_id = c_struct.component_id
        if c_struct.current_settings_size > 0:
            instance.current_settings = [
                Setting.from_c_struct(c_struct.current_settings[i])
                for i in range(c_struct.current_settings_size)
            ]
        else:
            instance.current_settings = []
        return instance

    def to_c_struct(self):
        """Convert to C structure for C library calls"""
        c_struct = CurrentSettingsUpdateCStruct()
        c_struct.component_id = self.component_id
        array_type = SettingCStruct * len(self.current_settings)
        c_array = array_type()
        for i, item in enumerate(self.current_settings):
            c_array[i] = item.to_c_struct()
        c_struct.current_settings = ctypes.cast(c_array, ctypes.POINTER(SettingCStruct))
        c_struct.current_settings_size = len(self.current_settings)
        return c_struct

    def __str__(self):
        fields = []
        fields.append(f"component_id={self.component_id}")
        fields.append(f"current_settings={self.current_settings}")
        return f"CurrentSettingsUpdate({', '.join(fields)})"


class PossibleSettingOptionsUpdate:
    """
    An update about possible setting options
    """

    def __init__(self, component_id=None, setting_options=None):
        self.component_id = component_id
        self.setting_options = setting_options or []

    @classmethod
    def from_c_struct(cls, c_struct):
        """Convert from C structure to Python object"""
        instance = cls()
        instance.component_id = c_struct.component_id
        if c_struct.setting_options_size > 0:
            instance.setting_options = [
                SettingOptions.from_c_struct(c_struct.setting_options[i])
                for i in range(c_struct.setting_options_size)
            ]
        else:
            instance.setting_options = []
        return instance

    def to_c_struct(self):
        """Convert to C structure for C library calls"""
        c_struct = PossibleSettingOptionsUpdateCStruct()
        c_struct.component_id = self.component_id
        array_type = SettingOptionsCStruct * len(self.setting_options)
        c_array = array_type()
        for i, item in enumerate(self.setting_options):
            c_array[i] = item.to_c_struct()
        c_struct.setting_options = ctypes.cast(
            c_array, ctypes.POINTER(SettingOptionsCStruct)
        )
        c_struct.setting_options_size = len(self.setting_options)
        return c_struct

    def __str__(self):
        fields = []
        fields.append(f"component_id={self.component_id}")
        fields.append(f"setting_options={self.setting_options}")
        return f"PossibleSettingOptionsUpdate({', '.join(fields)})"


class Position:
    """
    Position type in global coordinates.
    """

    def __init__(
        self,
        latitude_deg=None,
        longitude_deg=None,
        absolute_altitude_m=None,
        relative_altitude_m=None,
    ):
        self.latitude_deg = latitude_deg
        self.longitude_deg = longitude_deg
        self.absolute_altitude_m = absolute_altitude_m
        self.relative_altitude_m = relative_altitude_m

    @classmethod
    def from_c_struct(cls, c_struct):
        """Convert from C structure to Python object"""
        instance = cls()
        instance.latitude_deg = c_struct.latitude_deg
        instance.longitude_deg = c_struct.longitude_deg
        instance.absolute_altitude_m = c_struct.absolute_altitude_m
        instance.relative_altitude_m = c_struct.relative_altitude_m
        return instance

    def to_c_struct(self):
        """Convert to C structure for C library calls"""
        c_struct = PositionCStruct()
        c_struct.latitude_deg = self.latitude_deg
        c_struct.longitude_deg = self.longitude_deg
        c_struct.absolute_altitude_m = self.absolute_altitude_m
        c_struct.relative_altitude_m = self.relative_altitude_m
        return c_struct

    def __str__(self):
        fields = []
        fields.append(f"latitude_deg={self.latitude_deg}")
        fields.append(f"longitude_deg={self.longitude_deg}")
        fields.append(f"absolute_altitude_m={self.absolute_altitude_m}")
        fields.append(f"relative_altitude_m={self.relative_altitude_m}")
        return f"Position({', '.join(fields)})"


class Quaternion:
    """
       Quaternion type.

    All rotations and axis systems follow the right-hand rule.
    The Hamilton quaternion product definition is used.
    A zero-rotation quaternion is represented by (1,0,0,0).
    The quaternion could also be written as w + xi + yj + zk.

    For more info see: https://en.wikipedia.org/wiki/Quaternion
    """

    def __init__(self, w=None, x=None, y=None, z=None):
        self.w = w
        self.x = x
        self.y = y
        self.z = z

    @classmethod
    def from_c_struct(cls, c_struct):
        """Convert from C structure to Python object"""
        instance = cls()
        instance.w = c_struct.w
        instance.x = c_struct.x
        instance.y = c_struct.y
        instance.z = c_struct.z
        return instance

    def to_c_struct(self):
        """Convert to C structure for C library calls"""
        c_struct = QuaternionCStruct()
        c_struct.w = self.w
        c_struct.x = self.x
        c_struct.y = self.y
        c_struct.z = self.z
        return c_struct

    def __str__(self):
        fields = []
        fields.append(f"w={self.w}")
        fields.append(f"x={self.x}")
        fields.append(f"y={self.y}")
        fields.append(f"z={self.z}")
        return f"Quaternion({', '.join(fields)})"


class EulerAngle:
    """
       Euler angle type.

    All rotations and axis systems follow the right-hand rule.
    The Euler angles follow the convention of a 3-2-1 intrinsic Tait-Bryan rotation sequence.

    For more info see https://en.wikipedia.org/wiki/Euler_angles
    """

    def __init__(self, roll_deg=None, pitch_deg=None, yaw_deg=None):
        self.roll_deg = roll_deg
        self.pitch_deg = pitch_deg
        self.yaw_deg = yaw_deg

    @classmethod
    def from_c_struct(cls, c_struct):
        """Convert from C structure to Python object"""
        instance = cls()
        instance.roll_deg = c_struct.roll_deg
        instance.pitch_deg = c_struct.pitch_deg
        instance.yaw_deg = c_struct.yaw_deg
        return instance

    def to_c_struct(self):
        """Convert to C structure for C library calls"""
        c_struct = EulerAngleCStruct()
        c_struct.roll_deg = self.roll_deg
        c_struct.pitch_deg = self.pitch_deg
        c_struct.yaw_deg = self.yaw_deg
        return c_struct

    def __str__(self):
        fields = []
        fields.append(f"roll_deg={self.roll_deg}")
        fields.append(f"pitch_deg={self.pitch_deg}")
        fields.append(f"yaw_deg={self.yaw_deg}")
        return f"EulerAngle({', '.join(fields)})"


class CaptureInfo:
    """
    Information about a picture just captured.
    """

    def __init__(
        self,
        component_id=None,
        position=None,
        attitude_quaternion=None,
        attitude_euler_angle=None,
        time_utc_us=None,
        is_success=None,
        index=None,
        file_url=None,
    ):
        self.component_id = component_id
        self.position = position
        self.attitude_quaternion = attitude_quaternion
        self.attitude_euler_angle = attitude_euler_angle
        self.time_utc_us = time_utc_us
        self.is_success = is_success
        self.index = index
        self.file_url = file_url

    @classmethod
    def from_c_struct(cls, c_struct):
        """Convert from C structure to Python object"""
        instance = cls()
        instance.component_id = c_struct.component_id
        instance.position = Position.from_c_struct(c_struct.position)
        instance.attitude_quaternion = Quaternion.from_c_struct(
            c_struct.attitude_quaternion
        )
        instance.attitude_euler_angle = EulerAngle.from_c_struct(
            c_struct.attitude_euler_angle
        )
        instance.time_utc_us = c_struct.time_utc_us
        instance.is_success = c_struct.is_success
        instance.index = c_struct.index
        instance.file_url = c_struct.file_url.decode("utf-8")
        return instance

    def to_c_struct(self):
        """Convert to C structure for C library calls"""
        c_struct = CaptureInfoCStruct()
        c_struct.component_id = self.component_id
        c_struct.position = self.position.to_c_struct()
        c_struct.attitude_quaternion = self.attitude_quaternion.to_c_struct()
        c_struct.attitude_euler_angle = self.attitude_euler_angle.to_c_struct()
        c_struct.time_utc_us = self.time_utc_us
        c_struct.is_success = self.is_success
        c_struct.index = self.index
        c_struct.file_url = self.file_url.encode("utf-8")
        return c_struct

    def __str__(self):
        fields = []
        fields.append(f"component_id={self.component_id}")
        fields.append(f"position={self.position}")
        fields.append(f"attitude_quaternion={self.attitude_quaternion}")
        fields.append(f"attitude_euler_angle={self.attitude_euler_angle}")
        fields.append(f"time_utc_us={self.time_utc_us}")
        fields.append(f"is_success={self.is_success}")
        fields.append(f"index={self.index}")
        fields.append(f"file_url={self.file_url}")
        return f"CaptureInfo({', '.join(fields)})"


class Information:
    """
    Type to represent a camera information.
    """

    def __init__(
        self,
        component_id=None,
        vendor_name=None,
        model_name=None,
        focal_length_mm=None,
        horizontal_sensor_size_mm=None,
        vertical_sensor_size_mm=None,
        horizontal_resolution_px=None,
        vertical_resolution_px=None,
    ):
        self.component_id = component_id
        self.vendor_name = vendor_name
        self.model_name = model_name
        self.focal_length_mm = focal_length_mm
        self.horizontal_sensor_size_mm = horizontal_sensor_size_mm
        self.vertical_sensor_size_mm = vertical_sensor_size_mm
        self.horizontal_resolution_px = horizontal_resolution_px
        self.vertical_resolution_px = vertical_resolution_px

    @classmethod
    def from_c_struct(cls, c_struct):
        """Convert from C structure to Python object"""
        instance = cls()
        instance.component_id = c_struct.component_id
        instance.vendor_name = c_struct.vendor_name.decode("utf-8")
        instance.model_name = c_struct.model_name.decode("utf-8")
        instance.focal_length_mm = c_struct.focal_length_mm
        instance.horizontal_sensor_size_mm = c_struct.horizontal_sensor_size_mm
        instance.vertical_sensor_size_mm = c_struct.vertical_sensor_size_mm
        instance.horizontal_resolution_px = c_struct.horizontal_resolution_px
        instance.vertical_resolution_px = c_struct.vertical_resolution_px
        return instance

    def to_c_struct(self):
        """Convert to C structure for C library calls"""
        c_struct = InformationCStruct()
        c_struct.component_id = self.component_id
        c_struct.vendor_name = self.vendor_name.encode("utf-8")
        c_struct.model_name = self.model_name.encode("utf-8")
        c_struct.focal_length_mm = self.focal_length_mm
        c_struct.horizontal_sensor_size_mm = self.horizontal_sensor_size_mm
        c_struct.vertical_sensor_size_mm = self.vertical_sensor_size_mm
        c_struct.horizontal_resolution_px = self.horizontal_resolution_px
        c_struct.vertical_resolution_px = self.vertical_resolution_px
        return c_struct

    def __str__(self):
        fields = []
        fields.append(f"component_id={self.component_id}")
        fields.append(f"vendor_name={self.vendor_name}")
        fields.append(f"model_name={self.model_name}")
        fields.append(f"focal_length_mm={self.focal_length_mm}")
        fields.append(f"horizontal_sensor_size_mm={self.horizontal_sensor_size_mm}")
        fields.append(f"vertical_sensor_size_mm={self.vertical_sensor_size_mm}")
        fields.append(f"horizontal_resolution_px={self.horizontal_resolution_px}")
        fields.append(f"vertical_resolution_px={self.vertical_resolution_px}")
        return f"Information({', '.join(fields)})"


class CameraList:
    """
    Camera list
    """

    def __init__(self, cameras=None):
        self.cameras = cameras or []

    @classmethod
    def from_c_struct(cls, c_struct):
        """Convert from C structure to Python object"""
        instance = cls()
        if c_struct.cameras_size > 0:
            instance.cameras = [
                Information.from_c_struct(c_struct.cameras[i])
                for i in range(c_struct.cameras_size)
            ]
        else:
            instance.cameras = []
        return instance

    def to_c_struct(self):
        """Convert to C structure for C library calls"""
        c_struct = CameraListCStruct()
        array_type = InformationCStruct * len(self.cameras)
        c_array = array_type()
        for i, item in enumerate(self.cameras):
            c_array[i] = item.to_c_struct()
        c_struct.cameras = ctypes.cast(c_array, ctypes.POINTER(InformationCStruct))
        c_struct.cameras_size = len(self.cameras)
        return c_struct

    def __str__(self):
        fields = []
        fields.append(f"cameras={self.cameras}")
        return f"CameraList({', '.join(fields)})"


# ===== Plugin =====
class Camera:
    """Can be used to manage cameras that implement the MAVLink
    Camera Protocol: https://mavlink.io/en/services/camera.html.

    Currently only a single camera is supported.
    When multiple cameras are supported the plugin will need to be
    instantiated separately for every camera and the camera selected using
    `select_camera`."""

    def __init__(self, system):
        self._lib = _cmavsdk_lib
        self._handle = None
        self._callbacks = []  # Keep references to prevent GC

        if system is None:
            raise ValueError("system cannot be None")

        system_handle = system._handle

        if not system_handle:
            raise ValueError("system handle is null")

        self._handle = self._lib.mavsdk_camera_create(system_handle)

        if not self._handle:
            raise RuntimeError(
                "Failed to create Camera plugin - C function returned null handle"
            )

    def take_photo_async(self, component_id, callback: Callable, user_data: Any = None):
        """Take one photo."""

        def c_callback(result, ud):
            try:
                py_result = CameraResult(result)

                callback(py_result, user_data)

            except Exception as e:
                print(f"Error in take_photo callback: {e}")

        cb = TakePhotoCallback(c_callback)
        self._callbacks.append(cb)

        self._lib.mavsdk_camera_take_photo_async(self._handle, component_id, cb, None)

    def take_photo(self, component_id):
        """Get take_photo (blocking)"""

        result_code = self._lib.mavsdk_camera_take_photo(
            self._handle,
            component_id,
        )
        result = CameraResult(result_code)
        if result != CameraResult.SUCCESS:
            raise Exception(f"take_photo failed: {result}")

        return result

    def start_photo_interval_async(
        self, component_id, interval_s, callback: Callable, user_data: Any = None
    ):
        """Start photo timelapse with a given interval."""

        def c_callback(result, ud):
            try:
                py_result = CameraResult(result)

                callback(py_result, user_data)

            except Exception as e:
                print(f"Error in start_photo_interval callback: {e}")

        cb = StartPhotoIntervalCallback(c_callback)
        self._callbacks.append(cb)

        self._lib.mavsdk_camera_start_photo_interval_async(
            self._handle, component_id, interval_s, cb, None
        )

    def start_photo_interval(self, component_id, interval_s):
        """Get start_photo_interval (blocking)"""

        result_code = self._lib.mavsdk_camera_start_photo_interval(
            self._handle,
            component_id,
            interval_s,
        )
        result = CameraResult(result_code)
        if result != CameraResult.SUCCESS:
            raise Exception(f"start_photo_interval failed: {result}")

        return result

    def stop_photo_interval_async(
        self, component_id, callback: Callable, user_data: Any = None
    ):
        """Stop a running photo timelapse."""

        def c_callback(result, ud):
            try:
                py_result = CameraResult(result)

                callback(py_result, user_data)

            except Exception as e:
                print(f"Error in stop_photo_interval callback: {e}")

        cb = StopPhotoIntervalCallback(c_callback)
        self._callbacks.append(cb)

        self._lib.mavsdk_camera_stop_photo_interval_async(
            self._handle, component_id, cb, None
        )

    def stop_photo_interval(self, component_id):
        """Get stop_photo_interval (blocking)"""

        result_code = self._lib.mavsdk_camera_stop_photo_interval(
            self._handle,
            component_id,
        )
        result = CameraResult(result_code)
        if result != CameraResult.SUCCESS:
            raise Exception(f"stop_photo_interval failed: {result}")

        return result

    def start_video_async(
        self, component_id, callback: Callable, user_data: Any = None
    ):
        """Start a video recording."""

        def c_callback(result, ud):
            try:
                py_result = CameraResult(result)

                callback(py_result, user_data)

            except Exception as e:
                print(f"Error in start_video callback: {e}")

        cb = StartVideoCallback(c_callback)
        self._callbacks.append(cb)

        self._lib.mavsdk_camera_start_video_async(self._handle, component_id, cb, None)

    def start_video(self, component_id):
        """Get start_video (blocking)"""

        result_code = self._lib.mavsdk_camera_start_video(
            self._handle,
            component_id,
        )
        result = CameraResult(result_code)
        if result != CameraResult.SUCCESS:
            raise Exception(f"start_video failed: {result}")

        return result

    def stop_video_async(self, component_id, callback: Callable, user_data: Any = None):
        """Stop a running video recording."""

        def c_callback(result, ud):
            try:
                py_result = CameraResult(result)

                callback(py_result, user_data)

            except Exception as e:
                print(f"Error in stop_video callback: {e}")

        cb = StopVideoCallback(c_callback)
        self._callbacks.append(cb)

        self._lib.mavsdk_camera_stop_video_async(self._handle, component_id, cb, None)

    def stop_video(self, component_id):
        """Get stop_video (blocking)"""

        result_code = self._lib.mavsdk_camera_stop_video(
            self._handle,
            component_id,
        )
        result = CameraResult(result_code)
        if result != CameraResult.SUCCESS:
            raise Exception(f"stop_video failed: {result}")

        return result

    def start_video_streaming(self, component_id, stream_id):
        """Get start_video_streaming (blocking)"""

        result_code = self._lib.mavsdk_camera_start_video_streaming(
            self._handle,
            component_id,
            stream_id,
        )
        result = CameraResult(result_code)
        if result != CameraResult.SUCCESS:
            raise Exception(f"start_video_streaming failed: {result}")

        return result

    def stop_video_streaming(self, component_id, stream_id):
        """Get stop_video_streaming (blocking)"""

        result_code = self._lib.mavsdk_camera_stop_video_streaming(
            self._handle,
            component_id,
            stream_id,
        )
        result = CameraResult(result_code)
        if result != CameraResult.SUCCESS:
            raise Exception(f"stop_video_streaming failed: {result}")

        return result

    def set_mode_async(
        self, component_id, mode, callback: Callable, user_data: Any = None
    ):
        """Set camera mode."""

        def c_callback(result, ud):
            try:
                py_result = CameraResult(result)

                callback(py_result, user_data)

            except Exception as e:
                print(f"Error in set_mode callback: {e}")

        cb = SetModeCallback(c_callback)
        self._callbacks.append(cb)

        self._lib.mavsdk_camera_set_mode_async(
            self._handle, component_id, mode, cb, None
        )

    def set_mode(self, component_id, mode):
        """Get set_mode (blocking)"""

        result_code = self._lib.mavsdk_camera_set_mode(
            self._handle,
            component_id,
            mode,
        )
        result = CameraResult(result_code)
        if result != CameraResult.SUCCESS:
            raise Exception(f"set_mode failed: {result}")

        return result

    def list_photos_async(
        self, component_id, photos_range, callback: Callable, user_data: Any = None
    ):
        """List photos available on the camera.

        Note that this might need to be called initially to set the PhotosRange accordingly.
        Once set to 'all' rather than 'since connection', it will try to request the previous
        images over time."""

        def c_callback(result, c_data, size, ud):
            try:
                py_result = CameraResult(result)

                py_data = []
                if c_data and size.value > 0:
                    for i in range(size.value):
                        py_data.append(CaptureInfo.from_c_struct(c_data[i]))

                self._lib.mavsdk_camera_capture_info_destroy(c_data)

                callback(py_result, py_data, user_data)

            except Exception as e:
                print(f"Error in list_photos callback: {e}")

        cb = ListPhotosCallback(c_callback)
        self._callbacks.append(cb)

        self._lib.mavsdk_camera_list_photos_async(
            self._handle, component_id, photos_range, cb, None
        )

    def list_photos(self, component_id, photos_range):
        """Get list_photos (blocking)"""

        result_ptr = ctypes.POINTER(CaptureInfoCStruct)()
        size = ctypes.c_size_t()

        result_code = self._lib.mavsdk_camera_list_photos(
            self._handle,
            component_id,
            photos_range,
            ctypes.byref(result_ptr),
            ctypes.byref(size),
        )
        result = CameraResult(result_code)
        if result != CameraResult.SUCCESS:
            raise Exception(f"list_photos failed: {result}")

        py_result = [
            CaptureInfo.from_c_struct(result_ptr[i]) for i in range(size.value)
        ]
        self._lib.mavsdk_camera_capture_info_destroy(result_ptr)
        return py_result

    def subscribe_camera_list(self, callback: Callable, user_data: Any = None):
        """Subscribe to list of cameras.

        This allows to find out what cameras are connected to the system.
        Based on the camera ID, we can then address a specific camera."""

        def c_callback(c_data, ud):
            try:
                py_data = CameraList.from_c_struct(c_data)

                self._lib.mavsdk_camera_camera_list_destroy(ctypes.byref(c_data))

                callback(py_data, user_data)

            except Exception as e:
                print(f"Error in camera_list callback: {e}")

        cb = CameraListCallback(c_callback)
        self._callbacks.append(cb)

        return self._lib.mavsdk_camera_subscribe_camera_list(self._handle, cb, None)

    def unsubscribe_camera_list(self, handle: ctypes.c_void_p):
        """Unsubscribe from camera_list"""
        self._lib.mavsdk_camera_unsubscribe_camera_list(self._handle, handle)

    def camera_list(self):
        """Get camera_list (blocking)"""

        result_out = CameraListCStruct()

        self._lib.mavsdk_camera_camera_list(self._handle, ctypes.byref(result_out))

        py_result = CameraList.from_c_struct(result_out)
        self._lib.mavsdk_camera_camera_list_destroy(ctypes.byref(result_out))
        return py_result

    def subscribe_mode(self, callback: Callable, user_data: Any = None):
        """Subscribe to camera mode updates."""

        def c_callback(c_data, ud):
            try:
                py_data = ModeUpdate.from_c_struct(c_data)

                self._lib.mavsdk_camera_mode_update_destroy(ctypes.byref(c_data))

                callback(py_data, user_data)

            except Exception as e:
                print(f"Error in mode callback: {e}")

        cb = ModeCallback(c_callback)
        self._callbacks.append(cb)

        return self._lib.mavsdk_camera_subscribe_mode(self._handle, cb, None)

    def unsubscribe_mode(self, handle: ctypes.c_void_p):
        """Unsubscribe from mode"""
        self._lib.mavsdk_camera_unsubscribe_mode(self._handle, handle)

    def get_mode(self, component_id):
        """Get get_mode (blocking)"""

        result_out = ctypes.c_int()

        result_code = self._lib.mavsdk_camera_get_mode(
            self._handle, component_id, ctypes.byref(result_out)
        )
        result = CameraResult(result_code)
        if result != CameraResult.SUCCESS:
            raise Exception(f"get_mode failed: {result}")

        return mode(result_out.value)

    def subscribe_video_stream_info(self, callback: Callable, user_data: Any = None):
        """Subscribe to video stream info updates."""

        def c_callback(c_data, ud):
            try:
                py_data = VideoStreamUpdate.from_c_struct(c_data)

                self._lib.mavsdk_camera_video_stream_update_destroy(
                    ctypes.byref(c_data)
                )

                callback(py_data, user_data)

            except Exception as e:
                print(f"Error in video_stream_info callback: {e}")

        cb = VideoStreamInfoCallback(c_callback)
        self._callbacks.append(cb)

        return self._lib.mavsdk_camera_subscribe_video_stream_info(
            self._handle, cb, None
        )

    def unsubscribe_video_stream_info(self, handle: ctypes.c_void_p):
        """Unsubscribe from video_stream_info"""
        self._lib.mavsdk_camera_unsubscribe_video_stream_info(self._handle, handle)

    def get_video_stream_info(self, component_id):
        """Get get_video_stream_info (blocking)"""

        result_out = VideoStreamInfoCStruct()

        result_code = self._lib.mavsdk_camera_get_video_stream_info(
            self._handle, component_id, ctypes.byref(result_out)
        )
        result = CameraResult(result_code)
        if result != CameraResult.SUCCESS:
            raise Exception(f"get_video_stream_info failed: {result}")

        py_result = VideoStreamInfo.from_c_struct(result_out)
        self._lib.mavsdk_camera_video_stream_info_destroy(ctypes.byref(result_out))
        return py_result

    def subscribe_capture_info(self, callback: Callable, user_data: Any = None):
        """Subscribe to capture info updates."""

        def c_callback(c_data, ud):
            try:
                py_data = CaptureInfo.from_c_struct(c_data)

                self._lib.mavsdk_camera_capture_info_destroy(ctypes.byref(c_data))

                callback(py_data, user_data)

            except Exception as e:
                print(f"Error in capture_info callback: {e}")

        cb = CaptureInfoCallback(c_callback)
        self._callbacks.append(cb)

        return self._lib.mavsdk_camera_subscribe_capture_info(self._handle, cb, None)

    def unsubscribe_capture_info(self, handle: ctypes.c_void_p):
        """Unsubscribe from capture_info"""
        self._lib.mavsdk_camera_unsubscribe_capture_info(self._handle, handle)

    def subscribe_storage(self, callback: Callable, user_data: Any = None):
        """Subscribe to camera's storage status updates."""

        def c_callback(c_data, ud):
            try:
                py_data = StorageUpdate.from_c_struct(c_data)

                self._lib.mavsdk_camera_storage_update_destroy(ctypes.byref(c_data))

                callback(py_data, user_data)

            except Exception as e:
                print(f"Error in storage callback: {e}")

        cb = StorageCallback(c_callback)
        self._callbacks.append(cb)

        return self._lib.mavsdk_camera_subscribe_storage(self._handle, cb, None)

    def unsubscribe_storage(self, handle: ctypes.c_void_p):
        """Unsubscribe from storage"""
        self._lib.mavsdk_camera_unsubscribe_storage(self._handle, handle)

    def get_storage(self, component_id):
        """Get get_storage (blocking)"""

        result_out = StorageCStruct()

        result_code = self._lib.mavsdk_camera_get_storage(
            self._handle, component_id, ctypes.byref(result_out)
        )
        result = CameraResult(result_code)
        if result != CameraResult.SUCCESS:
            raise Exception(f"get_storage failed: {result}")

        py_result = Storage.from_c_struct(result_out)
        self._lib.mavsdk_camera_storage_destroy(ctypes.byref(result_out))
        return py_result

    def subscribe_current_settings(self, callback: Callable, user_data: Any = None):
        """Get the list of current camera settings."""

        def c_callback(c_data, ud):
            try:
                py_data = CurrentSettingsUpdate.from_c_struct(c_data)

                self._lib.mavsdk_camera_current_settings_update_destroy(
                    ctypes.byref(c_data)
                )

                callback(py_data, user_data)

            except Exception as e:
                print(f"Error in current_settings callback: {e}")

        cb = CurrentSettingsCallback(c_callback)
        self._callbacks.append(cb)

        return self._lib.mavsdk_camera_subscribe_current_settings(
            self._handle, cb, None
        )

    def unsubscribe_current_settings(self, handle: ctypes.c_void_p):
        """Unsubscribe from current_settings"""
        self._lib.mavsdk_camera_unsubscribe_current_settings(self._handle, handle)

    def get_current_settings(self, component_id):
        """Get get_current_settings (blocking)"""

        result_ptr = ctypes.POINTER(SettingCStruct)()
        size = ctypes.c_size_t()

        result_code = self._lib.mavsdk_camera_get_current_settings(
            self._handle, component_id, ctypes.byref(result_ptr), ctypes.byref(size)
        )
        result = CameraResult(result_code)
        if result != CameraResult.SUCCESS:
            raise Exception(f"get_current_settings failed: {result}")

        py_result = [Setting.from_c_struct(result_ptr[i]) for i in range(size.value)]
        self._lib.mavsdk_camera_setting_destroy(result_ptr)
        return py_result

    def subscribe_possible_setting_options(
        self, callback: Callable, user_data: Any = None
    ):
        """Get the list of settings that can be changed."""

        def c_callback(c_data, ud):
            try:
                py_data = PossibleSettingOptionsUpdate.from_c_struct(c_data)

                self._lib.mavsdk_camera_possible_setting_options_update_destroy(
                    ctypes.byref(c_data)
                )

                callback(py_data, user_data)

            except Exception as e:
                print(f"Error in possible_setting_options callback: {e}")

        cb = PossibleSettingOptionsCallback(c_callback)
        self._callbacks.append(cb)

        return self._lib.mavsdk_camera_subscribe_possible_setting_options(
            self._handle, cb, None
        )

    def unsubscribe_possible_setting_options(self, handle: ctypes.c_void_p):
        """Unsubscribe from possible_setting_options"""
        self._lib.mavsdk_camera_unsubscribe_possible_setting_options(
            self._handle, handle
        )

    def get_possible_setting_options(self, component_id):
        """Get get_possible_setting_options (blocking)"""

        result_ptr = ctypes.POINTER(SettingOptionsCStruct)()
        size = ctypes.c_size_t()

        result_code = self._lib.mavsdk_camera_get_possible_setting_options(
            self._handle, component_id, ctypes.byref(result_ptr), ctypes.byref(size)
        )
        result = CameraResult(result_code)
        if result != CameraResult.SUCCESS:
            raise Exception(f"get_possible_setting_options failed: {result}")

        py_result = [
            SettingOptions.from_c_struct(result_ptr[i]) for i in range(size.value)
        ]
        self._lib.mavsdk_camera_setting_options_destroy(result_ptr)
        return py_result

    def set_setting_async(
        self, component_id, setting, callback: Callable, user_data: Any = None
    ):
        """Set a setting to some value.

        Only setting_id of setting and option_id of option needs to be set."""

        def c_callback(result, ud):
            try:
                py_result = CameraResult(result)

                callback(py_result, user_data)

            except Exception as e:
                print(f"Error in set_setting callback: {e}")

        cb = SetSettingCallback(c_callback)
        self._callbacks.append(cb)

        self._lib.mavsdk_camera_set_setting_async(
            self._handle, component_id, setting, cb, None
        )

    def set_setting(self, component_id, setting):
        """Get set_setting (blocking)"""

        result_code = self._lib.mavsdk_camera_set_setting(
            self._handle,
            component_id,
            setting.to_c_struct(),
        )
        result = CameraResult(result_code)
        if result != CameraResult.SUCCESS:
            raise Exception(f"set_setting failed: {result}")

        return result

    def get_setting_async(
        self, component_id, setting, callback: Callable, user_data: Any = None
    ):
        """Get a setting.

        Only setting_id of setting needs to be set."""

        def c_callback(result, c_data, ud):
            try:
                py_result = CameraResult(result)

                py_data = Setting.from_c_struct(c_data)

                self._lib.mavsdk_camera_setting_destroy(ctypes.byref(c_data))

                callback(py_result, py_data, user_data)

            except Exception as e:
                print(f"Error in get_setting callback: {e}")

        cb = GetSettingCallback(c_callback)
        self._callbacks.append(cb)

        self._lib.mavsdk_camera_get_setting_async(
            self._handle, component_id, setting, cb, None
        )

    def get_setting(self, component_id, setting):
        """Get get_setting (blocking)"""

        result_out = SettingCStruct()

        result_code = self._lib.mavsdk_camera_get_setting(
            self._handle, component_id, setting.to_c_struct(), ctypes.byref(result_out)
        )
        result = CameraResult(result_code)
        if result != CameraResult.SUCCESS:
            raise Exception(f"get_setting failed: {result}")

        py_result = Setting.from_c_struct(result_out)
        self._lib.mavsdk_camera_setting_destroy(ctypes.byref(result_out))
        return py_result

    def format_storage_async(
        self, component_id, storage_id, callback: Callable, user_data: Any = None
    ):
        """Format storage (e.g. SD card) in camera.

        This will delete all content of the camera storage!"""

        def c_callback(result, ud):
            try:
                py_result = CameraResult(result)

                callback(py_result, user_data)

            except Exception as e:
                print(f"Error in format_storage callback: {e}")

        cb = FormatStorageCallback(c_callback)
        self._callbacks.append(cb)

        self._lib.mavsdk_camera_format_storage_async(
            self._handle, component_id, storage_id, cb, None
        )

    def format_storage(self, component_id, storage_id):
        """Get format_storage (blocking)"""

        result_code = self._lib.mavsdk_camera_format_storage(
            self._handle,
            component_id,
            storage_id,
        )
        result = CameraResult(result_code)
        if result != CameraResult.SUCCESS:
            raise Exception(f"format_storage failed: {result}")

        return result

    def reset_settings_async(
        self, component_id, callback: Callable, user_data: Any = None
    ):
        """Reset all settings in camera.

        This will reset all camera settings to default value"""

        def c_callback(result, ud):
            try:
                py_result = CameraResult(result)

                callback(py_result, user_data)

            except Exception as e:
                print(f"Error in reset_settings callback: {e}")

        cb = ResetSettingsCallback(c_callback)
        self._callbacks.append(cb)

        self._lib.mavsdk_camera_reset_settings_async(
            self._handle, component_id, cb, None
        )

    def reset_settings(self, component_id):
        """Get reset_settings (blocking)"""

        result_code = self._lib.mavsdk_camera_reset_settings(
            self._handle,
            component_id,
        )
        result = CameraResult(result_code)
        if result != CameraResult.SUCCESS:
            raise Exception(f"reset_settings failed: {result}")

        return result

    def zoom_in_start_async(
        self, component_id, callback: Callable, user_data: Any = None
    ):
        """Start zooming in."""

        def c_callback(result, ud):
            try:
                py_result = CameraResult(result)

                callback(py_result, user_data)

            except Exception as e:
                print(f"Error in zoom_in_start callback: {e}")

        cb = ZoomInStartCallback(c_callback)
        self._callbacks.append(cb)

        self._lib.mavsdk_camera_zoom_in_start_async(
            self._handle, component_id, cb, None
        )

    def zoom_in_start(self, component_id):
        """Get zoom_in_start (blocking)"""

        result_code = self._lib.mavsdk_camera_zoom_in_start(
            self._handle,
            component_id,
        )
        result = CameraResult(result_code)
        if result != CameraResult.SUCCESS:
            raise Exception(f"zoom_in_start failed: {result}")

        return result

    def zoom_out_start_async(
        self, component_id, callback: Callable, user_data: Any = None
    ):
        """Start zooming out."""

        def c_callback(result, ud):
            try:
                py_result = CameraResult(result)

                callback(py_result, user_data)

            except Exception as e:
                print(f"Error in zoom_out_start callback: {e}")

        cb = ZoomOutStartCallback(c_callback)
        self._callbacks.append(cb)

        self._lib.mavsdk_camera_zoom_out_start_async(
            self._handle, component_id, cb, None
        )

    def zoom_out_start(self, component_id):
        """Get zoom_out_start (blocking)"""

        result_code = self._lib.mavsdk_camera_zoom_out_start(
            self._handle,
            component_id,
        )
        result = CameraResult(result_code)
        if result != CameraResult.SUCCESS:
            raise Exception(f"zoom_out_start failed: {result}")

        return result

    def zoom_stop_async(self, component_id, callback: Callable, user_data: Any = None):
        """Stop zooming."""

        def c_callback(result, ud):
            try:
                py_result = CameraResult(result)

                callback(py_result, user_data)

            except Exception as e:
                print(f"Error in zoom_stop callback: {e}")

        cb = ZoomStopCallback(c_callback)
        self._callbacks.append(cb)

        self._lib.mavsdk_camera_zoom_stop_async(self._handle, component_id, cb, None)

    def zoom_stop(self, component_id):
        """Get zoom_stop (blocking)"""

        result_code = self._lib.mavsdk_camera_zoom_stop(
            self._handle,
            component_id,
        )
        result = CameraResult(result_code)
        if result != CameraResult.SUCCESS:
            raise Exception(f"zoom_stop failed: {result}")

        return result

    def zoom_range_async(
        self, component_id, range, callback: Callable, user_data: Any = None
    ):
        """Zoom to value as proportion of full camera range (percentage between 0.0 and 100.0)."""

        def c_callback(result, ud):
            try:
                py_result = CameraResult(result)

                callback(py_result, user_data)

            except Exception as e:
                print(f"Error in zoom_range callback: {e}")

        cb = ZoomRangeCallback(c_callback)
        self._callbacks.append(cb)

        self._lib.mavsdk_camera_zoom_range_async(
            self._handle, component_id, range, cb, None
        )

    def zoom_range(self, component_id, range):
        """Get zoom_range (blocking)"""

        result_code = self._lib.mavsdk_camera_zoom_range(
            self._handle,
            component_id,
            range,
        )
        result = CameraResult(result_code)
        if result != CameraResult.SUCCESS:
            raise Exception(f"zoom_range failed: {result}")

        return result

    def track_point_async(
        self,
        component_id,
        point_x,
        point_y,
        radius,
        callback: Callable,
        user_data: Any = None,
    ):
        """Track point."""

        def c_callback(result, ud):
            try:
                py_result = CameraResult(result)

                callback(py_result, user_data)

            except Exception as e:
                print(f"Error in track_point callback: {e}")

        cb = TrackPointCallback(c_callback)
        self._callbacks.append(cb)

        self._lib.mavsdk_camera_track_point_async(
            self._handle, component_id, point_x, point_y, radius, cb, None
        )

    def track_point(self, component_id, point_x, point_y, radius):
        """Get track_point (blocking)"""

        result_code = self._lib.mavsdk_camera_track_point(
            self._handle,
            component_id,
            point_x,
            point_y,
            radius,
        )
        result = CameraResult(result_code)
        if result != CameraResult.SUCCESS:
            raise Exception(f"track_point failed: {result}")

        return result

    def track_rectangle_async(
        self,
        component_id,
        top_left_x,
        top_left_y,
        bottom_right_x,
        bottom_right_y,
        callback: Callable,
        user_data: Any = None,
    ):
        """Track rectangle."""

        def c_callback(result, ud):
            try:
                py_result = CameraResult(result)

                callback(py_result, user_data)

            except Exception as e:
                print(f"Error in track_rectangle callback: {e}")

        cb = TrackRectangleCallback(c_callback)
        self._callbacks.append(cb)

        self._lib.mavsdk_camera_track_rectangle_async(
            self._handle,
            component_id,
            top_left_x,
            top_left_y,
            bottom_right_x,
            bottom_right_y,
            cb,
            None,
        )

    def track_rectangle(
        self, component_id, top_left_x, top_left_y, bottom_right_x, bottom_right_y
    ):
        """Get track_rectangle (blocking)"""

        result_code = self._lib.mavsdk_camera_track_rectangle(
            self._handle,
            component_id,
            top_left_x,
            top_left_y,
            bottom_right_x,
            bottom_right_y,
        )
        result = CameraResult(result_code)
        if result != CameraResult.SUCCESS:
            raise Exception(f"track_rectangle failed: {result}")

        return result

    def track_stop_async(self, component_id, callback: Callable, user_data: Any = None):
        """Stop tracking."""

        def c_callback(result, ud):
            try:
                py_result = CameraResult(result)

                callback(py_result, user_data)

            except Exception as e:
                print(f"Error in track_stop callback: {e}")

        cb = TrackStopCallback(c_callback)
        self._callbacks.append(cb)

        self._lib.mavsdk_camera_track_stop_async(self._handle, component_id, cb, None)

    def track_stop(self, component_id):
        """Get track_stop (blocking)"""

        result_code = self._lib.mavsdk_camera_track_stop(
            self._handle,
            component_id,
        )
        result = CameraResult(result_code)
        if result != CameraResult.SUCCESS:
            raise Exception(f"track_stop failed: {result}")

        return result

    def focus_in_start_async(
        self, component_id, callback: Callable, user_data: Any = None
    ):
        """Start focusing in."""

        def c_callback(result, ud):
            try:
                py_result = CameraResult(result)

                callback(py_result, user_data)

            except Exception as e:
                print(f"Error in focus_in_start callback: {e}")

        cb = FocusInStartCallback(c_callback)
        self._callbacks.append(cb)

        self._lib.mavsdk_camera_focus_in_start_async(
            self._handle, component_id, cb, None
        )

    def focus_in_start(self, component_id):
        """Get focus_in_start (blocking)"""

        result_code = self._lib.mavsdk_camera_focus_in_start(
            self._handle,
            component_id,
        )
        result = CameraResult(result_code)
        if result != CameraResult.SUCCESS:
            raise Exception(f"focus_in_start failed: {result}")

        return result

    def focus_out_start_async(
        self, component_id, callback: Callable, user_data: Any = None
    ):
        """Start focusing out."""

        def c_callback(result, ud):
            try:
                py_result = CameraResult(result)

                callback(py_result, user_data)

            except Exception as e:
                print(f"Error in focus_out_start callback: {e}")

        cb = FocusOutStartCallback(c_callback)
        self._callbacks.append(cb)

        self._lib.mavsdk_camera_focus_out_start_async(
            self._handle, component_id, cb, None
        )

    def focus_out_start(self, component_id):
        """Get focus_out_start (blocking)"""

        result_code = self._lib.mavsdk_camera_focus_out_start(
            self._handle,
            component_id,
        )
        result = CameraResult(result_code)
        if result != CameraResult.SUCCESS:
            raise Exception(f"focus_out_start failed: {result}")

        return result

    def focus_stop_async(self, component_id, callback: Callable, user_data: Any = None):
        """Stop focus."""

        def c_callback(result, ud):
            try:
                py_result = CameraResult(result)

                callback(py_result, user_data)

            except Exception as e:
                print(f"Error in focus_stop callback: {e}")

        cb = FocusStopCallback(c_callback)
        self._callbacks.append(cb)

        self._lib.mavsdk_camera_focus_stop_async(self._handle, component_id, cb, None)

    def focus_stop(self, component_id):
        """Get focus_stop (blocking)"""

        result_code = self._lib.mavsdk_camera_focus_stop(
            self._handle,
            component_id,
        )
        result = CameraResult(result_code)
        if result != CameraResult.SUCCESS:
            raise Exception(f"focus_stop failed: {result}")

        return result

    def focus_range_async(
        self, component_id, range, callback: Callable, user_data: Any = None
    ):
        """Focus with range value of full range (value between 0.0 and 100.0)."""

        def c_callback(result, ud):
            try:
                py_result = CameraResult(result)

                callback(py_result, user_data)

            except Exception as e:
                print(f"Error in focus_range callback: {e}")

        cb = FocusRangeCallback(c_callback)
        self._callbacks.append(cb)

        self._lib.mavsdk_camera_focus_range_async(
            self._handle, component_id, range, cb, None
        )

    def focus_range(self, component_id, range):
        """Get focus_range (blocking)"""

        result_code = self._lib.mavsdk_camera_focus_range(
            self._handle,
            component_id,
            range,
        )
        result = CameraResult(result_code)
        if result != CameraResult.SUCCESS:
            raise Exception(f"focus_range failed: {result}")

        return result

    def destroy(self):
        """Destroy the plugin instance"""
        if self._handle:
            self._lib.mavsdk_camera_destroy(self._handle)
            self._handle = None

    def __del__(self):
        self.destroy()


# ===== Callback Types =====
TakePhotoCallback = ctypes.CFUNCTYPE(None, ctypes.c_int, ctypes.c_void_p)
StartPhotoIntervalCallback = ctypes.CFUNCTYPE(None, ctypes.c_int, ctypes.c_void_p)
StopPhotoIntervalCallback = ctypes.CFUNCTYPE(None, ctypes.c_int, ctypes.c_void_p)
StartVideoCallback = ctypes.CFUNCTYPE(None, ctypes.c_int, ctypes.c_void_p)
StopVideoCallback = ctypes.CFUNCTYPE(None, ctypes.c_int, ctypes.c_void_p)
SetModeCallback = ctypes.CFUNCTYPE(None, ctypes.c_int, ctypes.c_void_p)
ListPhotosCallback = ctypes.CFUNCTYPE(
    None,
    ctypes.c_int,
    ctypes.POINTER(CaptureInfoCStruct),
    ctypes.c_size_t,
    ctypes.c_void_p,
)
CameraListCallback = ctypes.CFUNCTYPE(None, CameraListCStruct, ctypes.c_void_p)
ModeCallback = ctypes.CFUNCTYPE(None, ModeUpdateCStruct, ctypes.c_void_p)
VideoStreamInfoCallback = ctypes.CFUNCTYPE(
    None, VideoStreamUpdateCStruct, ctypes.c_void_p
)
CaptureInfoCallback = ctypes.CFUNCTYPE(None, CaptureInfoCStruct, ctypes.c_void_p)
StorageCallback = ctypes.CFUNCTYPE(None, StorageUpdateCStruct, ctypes.c_void_p)
CurrentSettingsCallback = ctypes.CFUNCTYPE(
    None, CurrentSettingsUpdateCStruct, ctypes.c_void_p
)
PossibleSettingOptionsCallback = ctypes.CFUNCTYPE(
    None, PossibleSettingOptionsUpdateCStruct, ctypes.c_void_p
)
SetSettingCallback = ctypes.CFUNCTYPE(None, ctypes.c_int, ctypes.c_void_p)
GetSettingCallback = ctypes.CFUNCTYPE(
    None, ctypes.c_int, SettingCStruct, ctypes.c_void_p
)
FormatStorageCallback = ctypes.CFUNCTYPE(None, ctypes.c_int, ctypes.c_void_p)
ResetSettingsCallback = ctypes.CFUNCTYPE(None, ctypes.c_int, ctypes.c_void_p)
ZoomInStartCallback = ctypes.CFUNCTYPE(None, ctypes.c_int, ctypes.c_void_p)
ZoomOutStartCallback = ctypes.CFUNCTYPE(None, ctypes.c_int, ctypes.c_void_p)
ZoomStopCallback = ctypes.CFUNCTYPE(None, ctypes.c_int, ctypes.c_void_p)
ZoomRangeCallback = ctypes.CFUNCTYPE(None, ctypes.c_int, ctypes.c_void_p)
TrackPointCallback = ctypes.CFUNCTYPE(None, ctypes.c_int, ctypes.c_void_p)
TrackRectangleCallback = ctypes.CFUNCTYPE(None, ctypes.c_int, ctypes.c_void_p)
TrackStopCallback = ctypes.CFUNCTYPE(None, ctypes.c_int, ctypes.c_void_p)
FocusInStartCallback = ctypes.CFUNCTYPE(None, ctypes.c_int, ctypes.c_void_p)
FocusOutStartCallback = ctypes.CFUNCTYPE(None, ctypes.c_int, ctypes.c_void_p)
FocusStopCallback = ctypes.CFUNCTYPE(None, ctypes.c_int, ctypes.c_void_p)
FocusRangeCallback = ctypes.CFUNCTYPE(None, ctypes.c_int, ctypes.c_void_p)

# ===== Setup Functions =====
_cmavsdk_lib.mavsdk_camera_create.argtypes = [ctypes.c_void_p]
_cmavsdk_lib.mavsdk_camera_create.restype = ctypes.c_void_p

_cmavsdk_lib.mavsdk_camera_destroy.argtypes = [ctypes.c_void_p]
_cmavsdk_lib.mavsdk_camera_destroy.restype = None

_cmavsdk_lib.mavsdk_camera_option_destroy.argtypes = [ctypes.POINTER(OptionCStruct)]
_cmavsdk_lib.mavsdk_camera_option_destroy.restype = None

_cmavsdk_lib.mavsdk_camera_setting_destroy.argtypes = [ctypes.POINTER(SettingCStruct)]
_cmavsdk_lib.mavsdk_camera_setting_destroy.restype = None

_cmavsdk_lib.mavsdk_camera_setting_options_destroy.argtypes = [
    ctypes.POINTER(SettingOptionsCStruct)
]
_cmavsdk_lib.mavsdk_camera_setting_options_destroy.restype = None

_cmavsdk_lib.mavsdk_camera_video_stream_settings_destroy.argtypes = [
    ctypes.POINTER(VideoStreamSettingsCStruct)
]
_cmavsdk_lib.mavsdk_camera_video_stream_settings_destroy.restype = None

_cmavsdk_lib.mavsdk_camera_video_stream_info_destroy.argtypes = [
    ctypes.POINTER(VideoStreamInfoCStruct)
]
_cmavsdk_lib.mavsdk_camera_video_stream_info_destroy.restype = None

_cmavsdk_lib.mavsdk_camera_mode_update_destroy.argtypes = [
    ctypes.POINTER(ModeUpdateCStruct)
]
_cmavsdk_lib.mavsdk_camera_mode_update_destroy.restype = None

_cmavsdk_lib.mavsdk_camera_video_stream_update_destroy.argtypes = [
    ctypes.POINTER(VideoStreamUpdateCStruct)
]
_cmavsdk_lib.mavsdk_camera_video_stream_update_destroy.restype = None

_cmavsdk_lib.mavsdk_camera_storage_destroy.argtypes = [ctypes.POINTER(StorageCStruct)]
_cmavsdk_lib.mavsdk_camera_storage_destroy.restype = None

_cmavsdk_lib.mavsdk_camera_storage_update_destroy.argtypes = [
    ctypes.POINTER(StorageUpdateCStruct)
]
_cmavsdk_lib.mavsdk_camera_storage_update_destroy.restype = None

_cmavsdk_lib.mavsdk_camera_current_settings_update_destroy.argtypes = [
    ctypes.POINTER(CurrentSettingsUpdateCStruct)
]
_cmavsdk_lib.mavsdk_camera_current_settings_update_destroy.restype = None

_cmavsdk_lib.mavsdk_camera_possible_setting_options_update_destroy.argtypes = [
    ctypes.POINTER(PossibleSettingOptionsUpdateCStruct)
]
_cmavsdk_lib.mavsdk_camera_possible_setting_options_update_destroy.restype = None

_cmavsdk_lib.mavsdk_camera_position_destroy.argtypes = [ctypes.POINTER(PositionCStruct)]
_cmavsdk_lib.mavsdk_camera_position_destroy.restype = None

_cmavsdk_lib.mavsdk_camera_quaternion_destroy.argtypes = [
    ctypes.POINTER(QuaternionCStruct)
]
_cmavsdk_lib.mavsdk_camera_quaternion_destroy.restype = None

_cmavsdk_lib.mavsdk_camera_euler_angle_destroy.argtypes = [
    ctypes.POINTER(EulerAngleCStruct)
]
_cmavsdk_lib.mavsdk_camera_euler_angle_destroy.restype = None

_cmavsdk_lib.mavsdk_camera_capture_info_destroy.argtypes = [
    ctypes.POINTER(CaptureInfoCStruct)
]
_cmavsdk_lib.mavsdk_camera_capture_info_destroy.restype = None

_cmavsdk_lib.mavsdk_camera_information_destroy.argtypes = [
    ctypes.POINTER(InformationCStruct)
]
_cmavsdk_lib.mavsdk_camera_information_destroy.restype = None

_cmavsdk_lib.mavsdk_camera_camera_list_destroy.argtypes = [
    ctypes.POINTER(CameraListCStruct)
]
_cmavsdk_lib.mavsdk_camera_camera_list_destroy.restype = None


_cmavsdk_lib.mavsdk_camera_take_photo_async.argtypes = [
    ctypes.c_void_p,
    ctypes.c_int32,
    TakePhotoCallback,
    ctypes.c_void_p,
]

_cmavsdk_lib.mavsdk_camera_take_photo_async.restype = None

_cmavsdk_lib.mavsdk_camera_take_photo.argtypes = [
    ctypes.c_void_p,
    ctypes.c_int32,
]

_cmavsdk_lib.mavsdk_camera_take_photo.restype = ctypes.c_int
_cmavsdk_lib.mavsdk_camera_start_photo_interval_async.argtypes = [
    ctypes.c_void_p,
    ctypes.c_int32,
    ctypes.c_float,
    StartPhotoIntervalCallback,
    ctypes.c_void_p,
]

_cmavsdk_lib.mavsdk_camera_start_photo_interval_async.restype = None

_cmavsdk_lib.mavsdk_camera_start_photo_interval.argtypes = [
    ctypes.c_void_p,
    ctypes.c_int32,
    ctypes.c_float,
]

_cmavsdk_lib.mavsdk_camera_start_photo_interval.restype = ctypes.c_int
_cmavsdk_lib.mavsdk_camera_stop_photo_interval_async.argtypes = [
    ctypes.c_void_p,
    ctypes.c_int32,
    StopPhotoIntervalCallback,
    ctypes.c_void_p,
]

_cmavsdk_lib.mavsdk_camera_stop_photo_interval_async.restype = None

_cmavsdk_lib.mavsdk_camera_stop_photo_interval.argtypes = [
    ctypes.c_void_p,
    ctypes.c_int32,
]

_cmavsdk_lib.mavsdk_camera_stop_photo_interval.restype = ctypes.c_int
_cmavsdk_lib.mavsdk_camera_start_video_async.argtypes = [
    ctypes.c_void_p,
    ctypes.c_int32,
    StartVideoCallback,
    ctypes.c_void_p,
]

_cmavsdk_lib.mavsdk_camera_start_video_async.restype = None

_cmavsdk_lib.mavsdk_camera_start_video.argtypes = [
    ctypes.c_void_p,
    ctypes.c_int32,
]

_cmavsdk_lib.mavsdk_camera_start_video.restype = ctypes.c_int
_cmavsdk_lib.mavsdk_camera_stop_video_async.argtypes = [
    ctypes.c_void_p,
    ctypes.c_int32,
    StopVideoCallback,
    ctypes.c_void_p,
]

_cmavsdk_lib.mavsdk_camera_stop_video_async.restype = None

_cmavsdk_lib.mavsdk_camera_stop_video.argtypes = [
    ctypes.c_void_p,
    ctypes.c_int32,
]

_cmavsdk_lib.mavsdk_camera_stop_video.restype = ctypes.c_int

_cmavsdk_lib.mavsdk_camera_start_video_streaming.argtypes = [
    ctypes.c_void_p,
    ctypes.c_int32,
    ctypes.c_int32,
]

_cmavsdk_lib.mavsdk_camera_start_video_streaming.restype = ctypes.c_int

_cmavsdk_lib.mavsdk_camera_stop_video_streaming.argtypes = [
    ctypes.c_void_p,
    ctypes.c_int32,
    ctypes.c_int32,
]

_cmavsdk_lib.mavsdk_camera_stop_video_streaming.restype = ctypes.c_int
_cmavsdk_lib.mavsdk_camera_set_mode_async.argtypes = [
    ctypes.c_void_p,
    ctypes.c_int32,
    ctypes.c_int,
    SetModeCallback,
    ctypes.c_void_p,
]

_cmavsdk_lib.mavsdk_camera_set_mode_async.restype = None

_cmavsdk_lib.mavsdk_camera_set_mode.argtypes = [
    ctypes.c_void_p,
    ctypes.c_int32,
    ctypes.c_int,
]

_cmavsdk_lib.mavsdk_camera_set_mode.restype = ctypes.c_int
_cmavsdk_lib.mavsdk_camera_list_photos_async.argtypes = [
    ctypes.c_void_p,
    ctypes.c_int32,
    ctypes.c_int,
    ListPhotosCallback,
    ctypes.c_void_p,
]

_cmavsdk_lib.mavsdk_camera_list_photos_async.restype = None

_cmavsdk_lib.mavsdk_camera_list_photos.argtypes = [
    ctypes.c_void_p,
    ctypes.c_int32,
    ctypes.c_int,
    ctypes.POINTER(ctypes.POINTER(CaptureInfoCStruct)),
    ctypes.POINTER(ctypes.c_size_t),
]

_cmavsdk_lib.mavsdk_camera_list_photos.restype = ctypes.c_int
_cmavsdk_lib.mavsdk_camera_subscribe_camera_list.argtypes = [
    ctypes.c_void_p,
    CameraListCallback,
    ctypes.c_void_p,
]

_cmavsdk_lib.mavsdk_camera_subscribe_camera_list.restype = ctypes.c_void_p
# Unsubscribe
_cmavsdk_lib.mavsdk_camera_unsubscribe_camera_list.argtypes = [
    ctypes.c_void_p,
    ctypes.c_void_p,
]

_cmavsdk_lib.mavsdk_camera_unsubscribe_camera_list.restype = None

_cmavsdk_lib.mavsdk_camera_camera_list.argtypes = [
    ctypes.c_void_p,
    ctypes.POINTER(CameraListCStruct),
]

_cmavsdk_lib.mavsdk_camera_camera_list.restype = None
_cmavsdk_lib.mavsdk_camera_subscribe_mode.argtypes = [
    ctypes.c_void_p,
    ModeCallback,
    ctypes.c_void_p,
]

_cmavsdk_lib.mavsdk_camera_subscribe_mode.restype = ctypes.c_void_p
# Unsubscribe
_cmavsdk_lib.mavsdk_camera_unsubscribe_mode.argtypes = [
    ctypes.c_void_p,
    ctypes.c_void_p,
]

_cmavsdk_lib.mavsdk_camera_unsubscribe_mode.restype = None


_cmavsdk_lib.mavsdk_camera_get_mode.argtypes = [
    ctypes.c_void_p,
    ctypes.c_int32,
    ctypes.POINTER(ctypes.c_int),
]

_cmavsdk_lib.mavsdk_camera_get_mode.restype = ctypes.c_int
_cmavsdk_lib.mavsdk_camera_subscribe_video_stream_info.argtypes = [
    ctypes.c_void_p,
    VideoStreamInfoCallback,
    ctypes.c_void_p,
]

_cmavsdk_lib.mavsdk_camera_subscribe_video_stream_info.restype = ctypes.c_void_p
# Unsubscribe
_cmavsdk_lib.mavsdk_camera_unsubscribe_video_stream_info.argtypes = [
    ctypes.c_void_p,
    ctypes.c_void_p,
]

_cmavsdk_lib.mavsdk_camera_unsubscribe_video_stream_info.restype = None


_cmavsdk_lib.mavsdk_camera_get_video_stream_info.argtypes = [
    ctypes.c_void_p,
    ctypes.c_int32,
    ctypes.POINTER(VideoStreamInfoCStruct),
]

_cmavsdk_lib.mavsdk_camera_get_video_stream_info.restype = ctypes.c_int
_cmavsdk_lib.mavsdk_camera_subscribe_capture_info.argtypes = [
    ctypes.c_void_p,
    CaptureInfoCallback,
    ctypes.c_void_p,
]

_cmavsdk_lib.mavsdk_camera_subscribe_capture_info.restype = ctypes.c_void_p
# Unsubscribe
_cmavsdk_lib.mavsdk_camera_unsubscribe_capture_info.argtypes = [
    ctypes.c_void_p,
    ctypes.c_void_p,
]

_cmavsdk_lib.mavsdk_camera_unsubscribe_capture_info.restype = None

_cmavsdk_lib.mavsdk_camera_subscribe_storage.argtypes = [
    ctypes.c_void_p,
    StorageCallback,
    ctypes.c_void_p,
]

_cmavsdk_lib.mavsdk_camera_subscribe_storage.restype = ctypes.c_void_p
# Unsubscribe
_cmavsdk_lib.mavsdk_camera_unsubscribe_storage.argtypes = [
    ctypes.c_void_p,
    ctypes.c_void_p,
]

_cmavsdk_lib.mavsdk_camera_unsubscribe_storage.restype = None


_cmavsdk_lib.mavsdk_camera_get_storage.argtypes = [
    ctypes.c_void_p,
    ctypes.c_int32,
    ctypes.POINTER(StorageCStruct),
]

_cmavsdk_lib.mavsdk_camera_get_storage.restype = ctypes.c_int
_cmavsdk_lib.mavsdk_camera_subscribe_current_settings.argtypes = [
    ctypes.c_void_p,
    CurrentSettingsCallback,
    ctypes.c_void_p,
]

_cmavsdk_lib.mavsdk_camera_subscribe_current_settings.restype = ctypes.c_void_p
# Unsubscribe
_cmavsdk_lib.mavsdk_camera_unsubscribe_current_settings.argtypes = [
    ctypes.c_void_p,
    ctypes.c_void_p,
]

_cmavsdk_lib.mavsdk_camera_unsubscribe_current_settings.restype = None


_cmavsdk_lib.mavsdk_camera_get_current_settings.argtypes = [
    ctypes.c_void_p,
    ctypes.c_int32,
    ctypes.POINTER(ctypes.POINTER(SettingCStruct)),
    ctypes.POINTER(ctypes.c_size_t),
]

_cmavsdk_lib.mavsdk_camera_get_current_settings.restype = ctypes.c_int
_cmavsdk_lib.mavsdk_camera_subscribe_possible_setting_options.argtypes = [
    ctypes.c_void_p,
    PossibleSettingOptionsCallback,
    ctypes.c_void_p,
]

_cmavsdk_lib.mavsdk_camera_subscribe_possible_setting_options.restype = ctypes.c_void_p
# Unsubscribe
_cmavsdk_lib.mavsdk_camera_unsubscribe_possible_setting_options.argtypes = [
    ctypes.c_void_p,
    ctypes.c_void_p,
]

_cmavsdk_lib.mavsdk_camera_unsubscribe_possible_setting_options.restype = None


_cmavsdk_lib.mavsdk_camera_get_possible_setting_options.argtypes = [
    ctypes.c_void_p,
    ctypes.c_int32,
    ctypes.POINTER(ctypes.POINTER(SettingOptionsCStruct)),
    ctypes.POINTER(ctypes.c_size_t),
]

_cmavsdk_lib.mavsdk_camera_get_possible_setting_options.restype = ctypes.c_int
_cmavsdk_lib.mavsdk_camera_set_setting_async.argtypes = [
    ctypes.c_void_p,
    ctypes.c_int32,
    SettingCStruct,
    SetSettingCallback,
    ctypes.c_void_p,
]

_cmavsdk_lib.mavsdk_camera_set_setting_async.restype = None

_cmavsdk_lib.mavsdk_camera_set_setting.argtypes = [
    ctypes.c_void_p,
    ctypes.c_int32,
    SettingCStruct,
]

_cmavsdk_lib.mavsdk_camera_set_setting.restype = ctypes.c_int
_cmavsdk_lib.mavsdk_camera_get_setting_async.argtypes = [
    ctypes.c_void_p,
    ctypes.c_int32,
    SettingCStruct,
    GetSettingCallback,
    ctypes.c_void_p,
]

_cmavsdk_lib.mavsdk_camera_get_setting_async.restype = None

_cmavsdk_lib.mavsdk_camera_get_setting.argtypes = [
    ctypes.c_void_p,
    ctypes.c_int32,
    SettingCStruct,
    ctypes.POINTER(SettingCStruct),
]

_cmavsdk_lib.mavsdk_camera_get_setting.restype = ctypes.c_int
_cmavsdk_lib.mavsdk_camera_format_storage_async.argtypes = [
    ctypes.c_void_p,
    ctypes.c_int32,
    ctypes.c_int32,
    FormatStorageCallback,
    ctypes.c_void_p,
]

_cmavsdk_lib.mavsdk_camera_format_storage_async.restype = None

_cmavsdk_lib.mavsdk_camera_format_storage.argtypes = [
    ctypes.c_void_p,
    ctypes.c_int32,
    ctypes.c_int32,
]

_cmavsdk_lib.mavsdk_camera_format_storage.restype = ctypes.c_int
_cmavsdk_lib.mavsdk_camera_reset_settings_async.argtypes = [
    ctypes.c_void_p,
    ctypes.c_int32,
    ResetSettingsCallback,
    ctypes.c_void_p,
]

_cmavsdk_lib.mavsdk_camera_reset_settings_async.restype = None

_cmavsdk_lib.mavsdk_camera_reset_settings.argtypes = [
    ctypes.c_void_p,
    ctypes.c_int32,
]

_cmavsdk_lib.mavsdk_camera_reset_settings.restype = ctypes.c_int
_cmavsdk_lib.mavsdk_camera_zoom_in_start_async.argtypes = [
    ctypes.c_void_p,
    ctypes.c_int32,
    ZoomInStartCallback,
    ctypes.c_void_p,
]

_cmavsdk_lib.mavsdk_camera_zoom_in_start_async.restype = None

_cmavsdk_lib.mavsdk_camera_zoom_in_start.argtypes = [
    ctypes.c_void_p,
    ctypes.c_int32,
]

_cmavsdk_lib.mavsdk_camera_zoom_in_start.restype = ctypes.c_int
_cmavsdk_lib.mavsdk_camera_zoom_out_start_async.argtypes = [
    ctypes.c_void_p,
    ctypes.c_int32,
    ZoomOutStartCallback,
    ctypes.c_void_p,
]

_cmavsdk_lib.mavsdk_camera_zoom_out_start_async.restype = None

_cmavsdk_lib.mavsdk_camera_zoom_out_start.argtypes = [
    ctypes.c_void_p,
    ctypes.c_int32,
]

_cmavsdk_lib.mavsdk_camera_zoom_out_start.restype = ctypes.c_int
_cmavsdk_lib.mavsdk_camera_zoom_stop_async.argtypes = [
    ctypes.c_void_p,
    ctypes.c_int32,
    ZoomStopCallback,
    ctypes.c_void_p,
]

_cmavsdk_lib.mavsdk_camera_zoom_stop_async.restype = None

_cmavsdk_lib.mavsdk_camera_zoom_stop.argtypes = [
    ctypes.c_void_p,
    ctypes.c_int32,
]

_cmavsdk_lib.mavsdk_camera_zoom_stop.restype = ctypes.c_int
_cmavsdk_lib.mavsdk_camera_zoom_range_async.argtypes = [
    ctypes.c_void_p,
    ctypes.c_int32,
    ctypes.c_float,
    ZoomRangeCallback,
    ctypes.c_void_p,
]

_cmavsdk_lib.mavsdk_camera_zoom_range_async.restype = None

_cmavsdk_lib.mavsdk_camera_zoom_range.argtypes = [
    ctypes.c_void_p,
    ctypes.c_int32,
    ctypes.c_float,
]

_cmavsdk_lib.mavsdk_camera_zoom_range.restype = ctypes.c_int
_cmavsdk_lib.mavsdk_camera_track_point_async.argtypes = [
    ctypes.c_void_p,
    ctypes.c_int32,
    ctypes.c_float,
    ctypes.c_float,
    ctypes.c_float,
    TrackPointCallback,
    ctypes.c_void_p,
]

_cmavsdk_lib.mavsdk_camera_track_point_async.restype = None

_cmavsdk_lib.mavsdk_camera_track_point.argtypes = [
    ctypes.c_void_p,
    ctypes.c_int32,
    ctypes.c_float,
    ctypes.c_float,
    ctypes.c_float,
]

_cmavsdk_lib.mavsdk_camera_track_point.restype = ctypes.c_int
_cmavsdk_lib.mavsdk_camera_track_rectangle_async.argtypes = [
    ctypes.c_void_p,
    ctypes.c_int32,
    ctypes.c_float,
    ctypes.c_float,
    ctypes.c_float,
    ctypes.c_float,
    TrackRectangleCallback,
    ctypes.c_void_p,
]

_cmavsdk_lib.mavsdk_camera_track_rectangle_async.restype = None

_cmavsdk_lib.mavsdk_camera_track_rectangle.argtypes = [
    ctypes.c_void_p,
    ctypes.c_int32,
    ctypes.c_float,
    ctypes.c_float,
    ctypes.c_float,
    ctypes.c_float,
]

_cmavsdk_lib.mavsdk_camera_track_rectangle.restype = ctypes.c_int
_cmavsdk_lib.mavsdk_camera_track_stop_async.argtypes = [
    ctypes.c_void_p,
    ctypes.c_int32,
    TrackStopCallback,
    ctypes.c_void_p,
]

_cmavsdk_lib.mavsdk_camera_track_stop_async.restype = None

_cmavsdk_lib.mavsdk_camera_track_stop.argtypes = [
    ctypes.c_void_p,
    ctypes.c_int32,
]

_cmavsdk_lib.mavsdk_camera_track_stop.restype = ctypes.c_int
_cmavsdk_lib.mavsdk_camera_focus_in_start_async.argtypes = [
    ctypes.c_void_p,
    ctypes.c_int32,
    FocusInStartCallback,
    ctypes.c_void_p,
]

_cmavsdk_lib.mavsdk_camera_focus_in_start_async.restype = None

_cmavsdk_lib.mavsdk_camera_focus_in_start.argtypes = [
    ctypes.c_void_p,
    ctypes.c_int32,
]

_cmavsdk_lib.mavsdk_camera_focus_in_start.restype = ctypes.c_int
_cmavsdk_lib.mavsdk_camera_focus_out_start_async.argtypes = [
    ctypes.c_void_p,
    ctypes.c_int32,
    FocusOutStartCallback,
    ctypes.c_void_p,
]

_cmavsdk_lib.mavsdk_camera_focus_out_start_async.restype = None

_cmavsdk_lib.mavsdk_camera_focus_out_start.argtypes = [
    ctypes.c_void_p,
    ctypes.c_int32,
]

_cmavsdk_lib.mavsdk_camera_focus_out_start.restype = ctypes.c_int
_cmavsdk_lib.mavsdk_camera_focus_stop_async.argtypes = [
    ctypes.c_void_p,
    ctypes.c_int32,
    FocusStopCallback,
    ctypes.c_void_p,
]

_cmavsdk_lib.mavsdk_camera_focus_stop_async.restype = None

_cmavsdk_lib.mavsdk_camera_focus_stop.argtypes = [
    ctypes.c_void_p,
    ctypes.c_int32,
]

_cmavsdk_lib.mavsdk_camera_focus_stop.restype = ctypes.c_int
_cmavsdk_lib.mavsdk_camera_focus_range_async.argtypes = [
    ctypes.c_void_p,
    ctypes.c_int32,
    ctypes.c_float,
    FocusRangeCallback,
    ctypes.c_void_p,
]

_cmavsdk_lib.mavsdk_camera_focus_range_async.restype = None

_cmavsdk_lib.mavsdk_camera_focus_range.argtypes = [
    ctypes.c_void_p,
    ctypes.c_int32,
    ctypes.c_float,
]

_cmavsdk_lib.mavsdk_camera_focus_range.restype = ctypes.c_int
