# ruff: noqa: F401

# WARNING: THIS FILE IS AUTOGENERATED! As such, it should not be edited.
# Edits need to be made to the proto files
# (see https://github.com/mavlink/MAVSDK-Proto/blob/main/protos/geofence/geofence.proto)

"""
Enable setting a geofence.
"""

import ctypes

from typing import Callable, Any
from enum import IntEnum

from ...cmavsdk_loader import _cmavsdk_lib


# ===== Enums =====
class FenceType(IntEnum):
    """Geofence types."""

    INCLUSION = 0
    EXCLUSION = 1


# ===== Result Enums =====
class GeofenceResult(IntEnum):
    """Possible results returned for geofence requests."""

    UNKNOWN = 0
    SUCCESS = 1
    ERROR = 2
    TOO_MANY_GEOFENCE_ITEMS = 3
    BUSY = 4
    TIMEOUT = 5
    INVALID_ARGUMENT = 6
    NO_SYSTEM = 7


# ===== Internal C Structures =====
class PointCStruct(ctypes.Structure):
    """
    Internal C structure for Point.
    Used only for C library communication.
    """

    _fields_ = [
        ("latitude_deg", ctypes.c_double),
        ("longitude_deg", ctypes.c_double),
    ]


class PolygonCStruct(ctypes.Structure):
    """
    Internal C structure for Polygon.
    Used only for C library communication.
    """

    _fields_ = [
        ("points", ctypes.POINTER(PointCStruct)),
        ("points_size", ctypes.c_size_t),
        ("fence_type", ctypes.c_int),
    ]


class CircleCStruct(ctypes.Structure):
    """
    Internal C structure for Circle.
    Used only for C library communication.
    """

    _fields_ = [
        ("point", PointCStruct),
        ("radius", ctypes.c_float),
        ("fence_type", ctypes.c_int),
    ]


class GeofenceDataCStruct(ctypes.Structure):
    """
    Internal C structure for GeofenceData.
    Used only for C library communication.
    """

    _fields_ = [
        ("polygons", ctypes.POINTER(PolygonCStruct)),
        ("polygons_size", ctypes.c_size_t),
        ("circles", ctypes.POINTER(CircleCStruct)),
        ("circles_size", ctypes.c_size_t),
    ]


# ===== Structures =====
class Point:
    """
    Point type.
    """

    def __init__(self, latitude_deg=None, longitude_deg=None):
        self.latitude_deg = latitude_deg
        self.longitude_deg = longitude_deg

    @classmethod
    def from_c_struct(cls, c_struct):
        """Convert from C structure to Python object"""
        instance = cls()
        instance.latitude_deg = c_struct.latitude_deg
        instance.longitude_deg = c_struct.longitude_deg
        return instance

    def to_c_struct(self):
        """Convert to C structure for C library calls"""
        c_struct = PointCStruct()
        c_struct.latitude_deg = self.latitude_deg
        c_struct.longitude_deg = self.longitude_deg
        return c_struct

    def __str__(self):
        fields = []
        fields.append(f"latitude_deg={self.latitude_deg}")
        fields.append(f"longitude_deg={self.longitude_deg}")
        return f"Point({', '.join(fields)})"


class Polygon:
    """
    Polygon type.
    """

    def __init__(self, points=None, fence_type=None):
        self.points = points or []
        self.fence_type = fence_type

    @classmethod
    def from_c_struct(cls, c_struct):
        """Convert from C structure to Python object"""
        instance = cls()
        if c_struct.points_size > 0:
            instance.points = [
                Point.from_c_struct(c_struct.points[i])
                for i in range(c_struct.points_size)
            ]
        else:
            instance.points = []
        instance.fence_type = FenceType(c_struct.fence_type)
        return instance

    def to_c_struct(self):
        """Convert to C structure for C library calls"""
        c_struct = PolygonCStruct()
        array_type = PointCStruct * len(self.points)
        c_array = array_type()
        for i, item in enumerate(self.points):
            c_array[i] = item.to_c_struct()
        c_struct.points = ctypes.cast(c_array, ctypes.POINTER(PointCStruct))
        c_struct.points_size = len(self.points)
        c_struct.fence_type = int(self.fence_type)
        return c_struct

    def __str__(self):
        fields = []
        fields.append(f"points={self.points}")
        fields.append(f"fence_type={self.fence_type}")
        return f"Polygon({', '.join(fields)})"


class Circle:
    """
    Circular type.
    """

    def __init__(self, point=None, radius=None, fence_type=None):
        self.point = point
        self.radius = radius
        self.fence_type = fence_type

    @classmethod
    def from_c_struct(cls, c_struct):
        """Convert from C structure to Python object"""
        instance = cls()
        instance.point = Point.from_c_struct(c_struct.point)
        instance.radius = c_struct.radius
        instance.fence_type = FenceType(c_struct.fence_type)
        return instance

    def to_c_struct(self):
        """Convert to C structure for C library calls"""
        c_struct = CircleCStruct()
        c_struct.point = self.point.to_c_struct()
        c_struct.radius = self.radius
        c_struct.fence_type = int(self.fence_type)
        return c_struct

    def __str__(self):
        fields = []
        fields.append(f"point={self.point}")
        fields.append(f"radius={self.radius}")
        fields.append(f"fence_type={self.fence_type}")
        return f"Circle({', '.join(fields)})"


class GeofenceData:
    """
    Geofence data type.
    """

    def __init__(self, polygons=None, circles=None):
        self.polygons = polygons or []
        self.circles = circles or []

    @classmethod
    def from_c_struct(cls, c_struct):
        """Convert from C structure to Python object"""
        instance = cls()
        if c_struct.polygons_size > 0:
            instance.polygons = [
                Polygon.from_c_struct(c_struct.polygons[i])
                for i in range(c_struct.polygons_size)
            ]
        else:
            instance.polygons = []
        if c_struct.circles_size > 0:
            instance.circles = [
                Circle.from_c_struct(c_struct.circles[i])
                for i in range(c_struct.circles_size)
            ]
        else:
            instance.circles = []
        return instance

    def to_c_struct(self):
        """Convert to C structure for C library calls"""
        c_struct = GeofenceDataCStruct()
        array_type = PolygonCStruct * len(self.polygons)
        c_array = array_type()
        for i, item in enumerate(self.polygons):
            c_array[i] = item.to_c_struct()
        c_struct.polygons = ctypes.cast(c_array, ctypes.POINTER(PolygonCStruct))
        c_struct.polygons_size = len(self.polygons)
        array_type = CircleCStruct * len(self.circles)
        c_array = array_type()
        for i, item in enumerate(self.circles):
            c_array[i] = item.to_c_struct()
        c_struct.circles = ctypes.cast(c_array, ctypes.POINTER(CircleCStruct))
        c_struct.circles_size = len(self.circles)
        return c_struct

    def __str__(self):
        fields = []
        fields.append(f"polygons={self.polygons}")
        fields.append(f"circles={self.circles}")
        return f"GeofenceData({', '.join(fields)})"


# ===== Plugin =====
class Geofence:
    """Enable setting a geofence."""

    def __init__(self, system):
        self._lib = _cmavsdk_lib
        self._handle = None
        self._callbacks = []  # Keep references to prevent GC

        if system is None:
            raise ValueError("system cannot be None")

        system_handle = system._handle

        if not system_handle:
            raise ValueError("system handle is null")

        self._handle = self._lib.mavsdk_geofence_create(system_handle)

        if not self._handle:
            raise RuntimeError(
                "Failed to create Geofence plugin - C function returned null handle"
            )

    def upload_geofence_async(
        self, geofence_data, callback: Callable, user_data: Any = None
    ):
        """Upload geofences.

        Polygon and Circular geofences are uploaded to a drone. Once uploaded, the geofence will remain
        on the drone even if a connection is lost."""

        def c_callback(result, ud):
            try:
                py_result = GeofenceResult(result)

                callback(py_result, user_data)

            except Exception as e:
                print(f"Error in upload_geofence callback: {e}")

        cb = UploadGeofenceCallback(c_callback)
        self._callbacks.append(cb)

        self._lib.mavsdk_geofence_upload_geofence_async(
            self._handle, geofence_data, cb, None
        )

    def upload_geofence(self, geofence_data):
        """Get upload_geofence (blocking)"""

        result_code = self._lib.mavsdk_geofence_upload_geofence(
            self._handle,
            geofence_data.to_c_struct(),
        )
        result = GeofenceResult(result_code)
        if result != GeofenceResult.SUCCESS:
            raise Exception(f"upload_geofence failed: {result}")

        return result

    def clear_geofence_async(self, callback: Callable, user_data: Any = None):
        """Clear all geofences saved on the vehicle."""

        def c_callback(result, ud):
            try:
                py_result = GeofenceResult(result)

                callback(py_result, user_data)

            except Exception as e:
                print(f"Error in clear_geofence callback: {e}")

        cb = ClearGeofenceCallback(c_callback)
        self._callbacks.append(cb)

        self._lib.mavsdk_geofence_clear_geofence_async(self._handle, cb, None)

    def clear_geofence(self):
        """Get clear_geofence (blocking)"""

        result_code = self._lib.mavsdk_geofence_clear_geofence(
            self._handle,
        )
        result = GeofenceResult(result_code)
        if result != GeofenceResult.SUCCESS:
            raise Exception(f"clear_geofence failed: {result}")

        return result

    def destroy(self):
        """Destroy the plugin instance"""
        if self._handle:
            self._lib.mavsdk_geofence_destroy(self._handle)
            self._handle = None

    def __del__(self):
        self.destroy()


# ===== Callback Types =====
UploadGeofenceCallback = ctypes.CFUNCTYPE(None, ctypes.c_int, ctypes.c_void_p)
ClearGeofenceCallback = ctypes.CFUNCTYPE(None, ctypes.c_int, ctypes.c_void_p)

# ===== Setup Functions =====
_cmavsdk_lib.mavsdk_geofence_create.argtypes = [ctypes.c_void_p]
_cmavsdk_lib.mavsdk_geofence_create.restype = ctypes.c_void_p

_cmavsdk_lib.mavsdk_geofence_destroy.argtypes = [ctypes.c_void_p]
_cmavsdk_lib.mavsdk_geofence_destroy.restype = None

_cmavsdk_lib.mavsdk_geofence_point_destroy.argtypes = [ctypes.POINTER(PointCStruct)]
_cmavsdk_lib.mavsdk_geofence_point_destroy.restype = None

_cmavsdk_lib.mavsdk_geofence_polygon_destroy.argtypes = [ctypes.POINTER(PolygonCStruct)]
_cmavsdk_lib.mavsdk_geofence_polygon_destroy.restype = None

_cmavsdk_lib.mavsdk_geofence_circle_destroy.argtypes = [ctypes.POINTER(CircleCStruct)]
_cmavsdk_lib.mavsdk_geofence_circle_destroy.restype = None

_cmavsdk_lib.mavsdk_geofence_geofence_data_destroy.argtypes = [
    ctypes.POINTER(GeofenceDataCStruct)
]
_cmavsdk_lib.mavsdk_geofence_geofence_data_destroy.restype = None


_cmavsdk_lib.mavsdk_geofence_upload_geofence_async.argtypes = [
    ctypes.c_void_p,
    GeofenceDataCStruct,
    UploadGeofenceCallback,
    ctypes.c_void_p,
]

_cmavsdk_lib.mavsdk_geofence_upload_geofence_async.restype = None

_cmavsdk_lib.mavsdk_geofence_upload_geofence.argtypes = [
    ctypes.c_void_p,
    GeofenceDataCStruct,
]

_cmavsdk_lib.mavsdk_geofence_upload_geofence.restype = ctypes.c_int
_cmavsdk_lib.mavsdk_geofence_clear_geofence_async.argtypes = [
    ctypes.c_void_p,
    ClearGeofenceCallback,
    ctypes.c_void_p,
]

_cmavsdk_lib.mavsdk_geofence_clear_geofence_async.restype = None

_cmavsdk_lib.mavsdk_geofence_clear_geofence.argtypes = [
    ctypes.c_void_p,
]

_cmavsdk_lib.mavsdk_geofence_clear_geofence.restype = ctypes.c_int
